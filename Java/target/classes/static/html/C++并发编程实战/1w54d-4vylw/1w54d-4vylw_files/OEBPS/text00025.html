<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>

    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>

  


<link href="../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet" />

</head>
<body>

<div class="calibreMeta">
  <div class="calibreMetaTitle">
  
  
    
    <h1>
      <a href="../../1w54d-4vylw.html">C++并发编程实战
</a>
    </h1>
    
    
  
  </div>
  <div class="calibreMetaAuthor">
    威廉姆斯(Anthony Williams)

  </div>
</div>

<div class="calibreMain">

  <div class="calibreEbookContent">
    
      <div class="calibreEbNavTop">
        
          <a href="text00024.html" class="calibreAPrev">previous page
</a>
        

        
          <a href="text00026.html" class="calibreANext">next page
</a>
        
      </div>
    

    
<h1 id="nav_point_203" class="not-in-toc">附录D　C++线程类库参考</h1>
<h2 id="nav_point_204" class="calibre11">D.1　&lt;chrono&gt;头文件</h2>
<p class="zw">
<code class="calibre10">&lt;chrono&gt;</code>
 头文件提供了表示时间点和<code class="calibre10">duration</code>
 的类，以及可作为<code class="calibre10">time_point</code>
 源的时钟类。每个时钟都有一个<code class="calibre10">is_steady</code>
 静态数据成员，能够指示该时钟是否为一个按照一致的速率（并且不能被调整）行进的<strong class="calibre3">匀速</strong>
 时钟。<code class="calibre10">std::chrono::steady_clock</code>
 类是唯一一个确保<strong class="calibre3">匀速</strong>
 的时钟。</p>
<p class="zw">
<strong class="calibre3">头文件内容</strong>
</p>
<p class="calibre16"><img alt="..\tu\360.tif" src="Image00392.gif" class="calibre15"/>
</p>
<h3 id="nav_point_205" class="calibre14">D.1.1　std::chrono::duration类模板</h3>
<p class="zw">
<code class="calibre10">std::chrono::duration</code>
 类模板提供了一个代表时间段的工具。模板的参数<code class="calibre10">Rep</code>
 和<code class="calibre10">Period</code>
 是用来存储时间段值的数据类型，还有一个<code class="calibre10">std::ratio</code>
 类模板的实例用来指示与下一个时钟周期之间的时间长度（单位是几分之一秒）。因此<code class="calibre10">std::chrono::duration&lt;int, std::milli&gt;</code>
 是以<code class="calibre10">int</code>
 类型值存储的毫秒数，<code class="calibre10">std::chrono::duration&lt;short, std::ratio&lt;1, 50&gt;&gt;</code>
 是以<code class="calibre10">short</code>
 值类型存储的50分之一秒的数量，<code class="calibre10">std::chrono::duration&lt;long long, std::ration&lt;60, 1&gt;&gt;</code>
 是以<code class="calibre10">long long</code>
 值类型存储的分钟数。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\361.tif" src="Image00393.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\362a.tif" src="Image00394.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">需求</strong>
</p>
<p class="zw">
<code class="calibre10">Rep</code>
 必须是内置的数值类型，或者是类似数字的用户定义类型。<code class="calibre10">Period</code>
 必须是<code class="calibre10">std::ratio&lt;&gt;</code>
 的一个实例。</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::rep typedef</h4>
<p class="zw">该typedef定义的类型用于保存<code class="calibre10">duration</code>
 值中的刻度数目。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\362B.tif" src="Image00395.gif" class="calibre15"/>
</p>
<p class="zw">
<code class="calibre10">rep</code>
 是一个用来存放<code class="calibre10">duration</code>
 对象的内部表示值的类型。</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::period typedef</h4>
<p class="zw">该typedef定义了一个<code class="calibre10">std::ratio</code>
 类模板实例，该实例规定了时间段的计数值的单位是多少分之一秒。例如，如果<code class="calibre10">peroid</code>
 是<code class="calibre10">std::ratio&lt;1, 50&gt;</code>
 ，那么一个<code class="calibre10">count()</code>
 为<em class="calibre9">N</em>
 的时间段值表示50分之<em class="calibre9">N</em>
 秒。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\362C.tif" src="Image00396.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration默认构造函数</h4>
<p class="zw">用默认值构造<code class="calibre10">std::chrono::duration</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\362D.tif" src="Image00397.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">
<code class="calibre10">duration</code>
 （类型为<code class="calibre10">rep</code>
 ）的内部值被默认初始化。</p>
<h4 class="sigil_not_in_toc">std::chrono::duration来自计数值的转换构造函数</h4>
<p class="zw">用指定的计数值构造一个<code class="calibre10">std::chrono::duration</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\362E.tif" src="Image00398.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">
<code class="calibre10">duration</code>
 对象的内部值被初始化为<code class="calibre10">static_cast&lt;rep&gt;(r)</code>
 。</p>
<p class="zw">
<strong class="calibre3">需求</strong>
</p>
<p class="zw">只有当<code class="calibre10">Rep2</code>
 可以隐式转换为<code class="calibre10">Rep</code>
 ，并且<code class="calibre10">Rep</code>
 是浮点类型或者<code class="calibre10">Rep2</code>
 <strong class="calibre3">不是</strong>
 浮点类型的时候，此构造函数才会参与到重载方案中。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="calibre16"><img alt="..\tu\363a.tif" src="Image00399.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration来自另一个STD::CHRONO::DURATION值的转换构造函数</h4>
<p class="zw">通过比例缩放另一个<code class="calibre10">std::chrono::duration</code>
 对象的计数值，构造<code class="calibre10">std::chrono::duration</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\363B.tif" src="Image00400.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">用<code class="calibre10">duration_cast&lt;duration&lt;Rep, Period&gt;&gt;(d).count()</code>
 来初始化<code class="calibre10">duration</code>
 对象的内部值。</p>
<p class="zw">
<strong class="calibre3">需求</strong>
</p>
<p class="zw">只有当<code class="calibre10">Rep</code>
 是浮点类型，或者<code class="calibre10">Rep2</code>
 不是一个浮点类型并且<code class="calibre10">Period2</code>
 是<code class="calibre10">Peroid</code>
 的整数倍时（即<code class="calibre10">ratio_divide&lt;Period2, Period&gt;::den ==1</code>
 ），此构造函数才会参与到重载方案中。这样可以在将一个较短的时间存储到代表较长时间间隔的变量时，避免意料之外的截断（同时导致精度的损失）。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="calibre16"><img alt="..\tu\363C.tif" src="Image00401.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">示例</strong>
</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00402.jpg" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::count成员函数</h4>
<p class="zw">获取时间段值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\363E.tif" src="Image00403.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">
<code class="calibre10">duration</code>
 对象的内部值，以<code class="calibre10">rep</code>
 类型表示。</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::operator+一元加号运算符</h4>
<p class="zw">这其实没有运算：仅返回<code class="calibre10">*this</code>
 的副本。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\363F.tif" src="Image00404.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\363G.tif" src="Image00405.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::operator-一元减号运算符</h4>
<p class="zw">返回一个时间段值，其<code class="calibre10">count()</code>
 值是<code class="calibre10">this-&gt;count()</code>
 的负值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\364a.tif" src="Image00406.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\364B.tif" src="Image00407.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration:operator++前置自增运算符</h4>
<p class="zw">增加内部计数。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\364C.tif" src="Image00408.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\364D.tif" src="Image00409.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\363G.tif" src="Image00410.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::operator++后置自增运算符</h4>
<p class="zw">增加内部计数，并且返回增加前的<code class="calibre10">*this</code>
 值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\364F.tif" src="Image00411.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\364G.tif" src="Image00412.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::operator--前置自减运算符</h4>
<p class="zw">减小内部计数。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\364H.tif" src="Image00413.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\364I.tif" src="Image00414.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\363G.tif" src="Image00415.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::operator--后置自减运算符</h4>
<p class="zw">减小内部计数，并且返回减小前的<code class="calibre10">*this</code>
 值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\364K.tif" src="Image00416.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\364L.tif" src="Image00417.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::operator+=复合赋值运算符</h4>
<p class="zw">将另一个<code class="calibre10">duration</code>
 对象的计数值加到<code class="calibre10">*this</code>
 的内部计数值上。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\365a.tif" src="Image00418.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\365B.tif" src="Image00419.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\365C.tif" src="Image00420.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::operator-=复合赋值运算符</h4>
<p class="zw">从<code class="calibre10">*this</code>
 内部的计数值减去另一个<code class="calibre10">duration</code>
 对象的计数值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\365D.tif" src="Image00421.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\365E.tif" src="Image00422.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\365F.tif" src="Image00423.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::operator*=复合赋值运算符</h4>
<p class="zw">将<code class="calibre10">*this</code>
 内部计数值乘以给定的数值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\365G.tif" src="Image00424.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\365H.tif" src="Image00425.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\365I.tif" src="Image00426.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::operator/=复合赋值运算符</h4>
<p class="zw">将<code class="calibre10">*this</code>
 的内部计数值除以给定的数值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\365J.tif" src="Image00427.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\365K.tif" src="Image00428.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\365L.tif" src="Image00429.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::operator%=复合赋值运算符</h4>
<p class="zw">将<code class="calibre10">*this</code>
 内部计数值设为其与给定数值相除的余数。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\365M.tif" src="Image00430.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\365N.tif" src="Image00431.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回值</strong>
</p>
<p class="calibre16"><img alt="..\tu\365O.tif" src="Image00432.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::operator%=复合赋值运算符</h4>
<p class="zw">将<code class="calibre10">*this</code>
 内部计数值设为其与另一<code class="calibre10">duration</code>
 对象计数值相除的余数。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\366a.tif" src="Image00433.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\366B.tif" src="Image00434.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回值</strong>
</p>
<p class="calibre16"><img alt="..\tu\366C.tif" src="Image00435.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::zero静态成员函数</h4>
<p class="zw">返回一个表示零值的<code class="calibre10">duration</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\366D.tif" src="Image00436.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回值</strong>
</p>
<p class="calibre16"><img alt="..\tu\366E.tif" src="Image00437.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::min静态成员函数</h4>
<p class="zw">返回一个<code class="calibre10">duration</code>
 对象，该对象保存着给定实例最小的可能值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\366F.tif" src="Image00438.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回值</strong>
</p>
<p class="calibre16"><img alt="..\tu\366G.tif" src="Image00439.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration::max静态成员函数</h4>
<p class="zw">返回一个<code class="calibre10">duration</code>
 对象，该对象保存着给定实例最大的可能值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\366H.tif" src="Image00440.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回值</strong>
</p>
<p class="calibre16"><img alt="..\tu\366I.tif" src="Image00441.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration相等比较运算符</h4>
<p class="zw">比较两个<code class="calibre10">duration</code>
 对象是否相等，即便它们具有不同的表现形式和周期。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\366J.tif" src="Image00442.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">需求</strong>
</p>
<p class="zw">每个<code class="calibre10">lhs</code>
 必须可以隐式地转换到<code class="calibre10">rhs</code>
 ，反之亦然。如果它们不能彼此进行隐式转换，或者它们是不同的<code class="calibre10">duration</code>
 实例化结果但能够相互隐式转换，该表达式都是不规范的。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果<code class="calibre10">CommonDuration</code>
 是<code class="calibre10">std::common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;::type</code>
 的同义词，那么<code class="calibre10">lhs==rhs</code>
 返回<code class="calibre10">CommonDuration(lhs).count()==CommonDuration(rhs).count()</code>
 的结果。</p>
<h4 class="sigil_not_in_toc">std::chrono::duration不等比较运算符</h4>
<p class="zw">比较两个<code class="calibre10">duration</code>
 对象是否不相等，即便它们具有不同的表现形式和/或周期。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\367a.tif" src="Image00443.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">需求</strong>
</p>
<p class="zw">每个<code class="calibre10">lhs</code>
 必须可以隐式地转换到<code class="calibre10">rhs</code>
 ，反之亦然。如果它们不能彼此进行隐式转换，或者它们是不同的<code class="calibre10">duration</code>
 实例化结果但能够相互隐式转换，该表达式都是不规范的。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\367B.tif" src="Image00444.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration小于比较运算符</h4>
<p class="zw">比较两个<code class="calibre10">duration</code>
 对象，看其中一个是否小于另一个，即便它们具有不同的表现形式和/或周期。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\367C.tif" src="Image00445.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">需求</strong>
</p>
<p class="zw">每个<code class="calibre10">lhs</code>
 必须可以隐式地转换到<code class="calibre10">rhs</code>
 ，反之亦然。如果它们不能彼此进行隐式转换，或者它们是不同的<code class="calibre10">duration</code>
 实例化结果但能够相互隐式转换，该表达式都是不规范的。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果<code class="calibre10">CommonDuration</code>
 是<code class="calibre10">std::common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;::type</code>
 的同义词，那么<code class="calibre10">lhs&lt;rhs</code>
 返回<code class="calibre10">CommonDuration(lhs).count()&lt;CommonDuration(rhs).count()</code>
 的结果。</p>
<h4 class="sigil_not_in_toc">std::chrono::duration大于比较运算符</h4>
<p class="zw">比较两个<code class="calibre10">duration</code>
 对象，看其中一个是否大于另一个，即便它们具有不同的表现形式和/或周期。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\367D.tif" src="Image00446.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">需求</strong>
</p>
<p class="zw">每个<code class="calibre10">lhs</code>
 必须可以隐式地转换到<code class="calibre10">rhs</code>
 ，反之亦然。如果它们不能彼此进行隐式转换，或者它们是不同的<code class="calibre10">duration</code>
 实例化结果但能够相互隐式转换，该表达式都是不规范的。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\368a.tif" src="Image00447.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration小于或等于比较运算符</h4>
<p class="zw">比较两个<code class="calibre10">duration</code>
 对象，看其中一个是否小于或者等于另一个，即便它们具有不同的表现形式和/或周期。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\368B.tif" src="Image00448.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">需求</strong>
</p>
<p class="zw">每个<code class="calibre10">lhs</code>
 必须可以隐式地转换到<code class="calibre10">rhs</code>
 ，反之亦然。如果它们不能彼此进行隐式转换，或者它们是不同的<code class="calibre10">duration</code>
 实例化结果但能够相互隐式转换，该表达式都是不规范的。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\368C.tif" src="Image00449.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration大于或等于比较运算符</h4>
<p class="zw">比较两个<code class="calibre10">duration</code>
 对象，看其中一个是否大于或者等于另一个，即便它们具有不同的表现形式和周期。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\368D.tif" src="Image00450.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">需求</strong>
</p>
<p class="zw">每个<code class="calibre10">lhs</code>
 必须可以隐式地转换到<code class="calibre10">rhs</code>
 ，反之亦然。如果它们不能彼此进行隐式转换，或者它们是不同的<code class="calibre10">duration</code>
 实例化结果但能够相互隐式转换，该表达式都是不规范的。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\368E.tif" src="Image00451.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::duration_cast非成员函数</h4>
<p class="zw">显式地将一个<code class="calibre10">std::chrono::duration</code>
 对象转换为指定的<code class="calibre10">std::chrono::duration</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\368F.tif" src="Image00452.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">需求</strong>
</p>
<p class="zw">
<code class="calibre10">ToDuration</code>
 必须是<code class="calibre10">std::chrono::duration</code>
 的实例。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">时间段<code class="calibre10">d</code>
 被转换为<code class="calibre10">ToDuration</code>
 所指定的时间段类型。这种方法能够尽量减少不同尺度和表示类型之间的转换所造成的精度损失。</p>
<h3 id="nav_point_206" class="calibre14">D.1.2　std::chrono::time_point类模板</h3>
<p class="zw">
<code class="calibre10">std::chrono::time_point</code>
 类模板表示一个以特定时钟来计量的时间点。它被指定为特定时钟所经过的一段<strong class="calibre3">纪元（epoch）</strong>
 。模板参数<code class="calibre10">Clock</code>
 指定了这一时钟（每个不同的时钟必须具备单独的类型），同时<code class="calibre10">Duration</code>
 模板参数是用来计量经过时间的类型，且必须是<code class="calibre10">std::chrono::duration</code>
 类模板的实例。<code class="calibre10">Duration</code>
 默认情况下是<code class="calibre10">Clock</code>
 的默认时间段类型。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\369a.tif" src="Image00453.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::time_point默认构造函数</h4>
<p class="zw">构造一个<code class="calibre10">time_point</code>
 ，表示相关联的<code class="calibre10">Clock</code>
 的间隔；其内部的时间段被初始化为<code class="calibre10">Duration::zero()</code>
 。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\369B.tif" src="Image00454.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">对于新的默认构造<code class="calibre10">time_point</code>
 对象<code class="calibre10">tp</code>
 ，<code class="calibre10">tp.time_since_epoch() == tp::duration::zero()</code>
 。</p>
<h4 class="sigil_not_in_toc">std::chrono::time_point时间段构造函数</h4>
<p class="zw">构造<code class="calibre10">time_point</code>
 ，表示其相关联的<code class="calibre10">Clock</code>
 的间隔为指定的时间段。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\370a.tif" src="Image00455.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">对于<code class="calibre10">time_point</code>
 对象<code class="calibre10">tp</code>
 ，以表示时间段<code class="calibre10">d</code>
 的<code class="calibre10">tp(d)</code>
 进行构造，<code class="calibre10">tp.time_since_epoch() == d</code>
 。</p>
<h4 class="sigil_not_in_toc">std::chrono::time_point转换构造函数</h4>
<p class="zw">从另一个具有相同<code class="calibre10">Clock</code>
 但不同的<code class="calibre10">Duration</code>
 的<code class="calibre10">time_point</code>
 对象，来构造一个<code class="calibre10">time_point</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\370B.tif" src="Image00456.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">需求</strong>
</p>
<p class="zw">
<code class="calibre10">Duration2</code>
 必须能够隐式地转换为<code class="calibre10">Duration</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">例如<code class="calibre10">time_point(t.time_since_epoch())</code>
 。<code class="calibre10">t.time_since_epoch()</code>
 的返回值被隐式转换为<code class="calibre10">Duration</code>
 类型的对象，且该值被存储在新构造的<code class="calibre10">time_point</code>
 对象中。</p>
<h4 class="sigil_not_in_toc">std::chrono::time_point::time_since_epoch成员函数</h4>
<p class="zw">获取特定<code class="calibre10">time_point</code>
 对象的时钟间隔时间段。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\370C.tif" src="Image00457.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 中存储的<code class="calibre10">duration</code>
 值。</p>
<h4 class="sigil_not_in_toc">std::chrono::time_point::operator+=复合赋值运算符</h4>
<p class="zw">将指定的<code class="calibre10">duration</code>
 加到指定的<code class="calibre10">time_point</code>
 对象所存储的值上。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\370D.tif" src="Image00458.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">将<code class="calibre10">d</code>
 加到<code class="calibre10">*this</code>
 内部的<code class="calibre10">duration</code>
 对象上，例如：</p>
<p class="calibre16"><img alt="..\tu\370E.tif" src="Image00459.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\370F.tif" src="Image00460.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::time_point::operator-=复合赋值运算符</h4>
<p class="zw">将指定的<code class="calibre10">time_point</code>
 对象中存储的值中减去指定的<code class="calibre10">duration</code>
 。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\370G.tif" src="Image00461.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">从<code class="calibre10">*this</code>
 内部的<code class="calibre10">duration</code>
 对象减去<code class="calibre10">d</code>
 ，例如：</p>
<p class="calibre16"><img alt="..\tu\371a.tif" src="Image00462.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\371B.tif" src="Image00463.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::time_point::min静态成员函数</h4>
<p class="zw">得到一个代表其类型的最小可能值的time_point对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\371C.tif" src="Image00464.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<pre class="dai_ma_wu_xing_hao">
<code class="calibre10">time_point(time_point::duration::min())</code>

</pre>
<h4 class="sigil_not_in_toc">td::chrono::time_point::max静态成员函数</h4>
<p class="zw">得到一个代表其类型的最大可能值的<code class="calibre10">time_point</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\371D.tif" src="Image00465.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<pre class="dai_ma_wu_xing_hao">
<code class="calibre10">time_point(time_point::duration::max())</code>

</pre>
<h3 id="nav_point_207" class="calibre14">D.1.3　std::chrono::system_clock类</h3>
<p class="zw">
<code class="calibre10">std::chrono::system_clock</code>
 类提供了从系统真实时间获取当前挂钟时间的方法。当前时间可以通过调用<code class="calibre10">std::chrono::system_clock::now()</code>
 来获得。<code class="calibre10">std::chrono::system_clock::time_point</code>
 的实例可以通过<code class="calibre10">std::chrono::system_clock::to_time_t()</code>
 和<code class="calibre10">std::chrono::system_clock::to_time_point()</code>
 函数，而与<code class="calibre10">time_t</code>
 相互转换。系统时钟不是<strong class="calibre3">匀速</strong>
 的，所以之后对<code class="calibre10">std::chrono::system_clock::now()</code>
 的调用，可能会返回比之前的调用更早的时间（比如，操作系统的时钟被手动调整过或是与外部时钟进行了同步）。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\371F.tif" src="Image00466.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::system_clock::rep typedef</h4>
<p class="zw">某个整数类型的类型别名，用来存储<code class="calibre10">duration</code>
 值中的刻度数量。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\372a.tif" src="Image00467.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::system_clock::periodtypedef</h4>
<p class="zw">某<code class="calibre10">std::ratio</code>
 类模板实例的类型别名，用来指定在两个<code class="calibre10">duration</code>
 或<code class="calibre10">time_point</code>
 间最小的秒数（或几分之一秒）。<code class="calibre10">period</code>
 指定了时钟的<strong class="calibre3">精度</strong>
 ，而非其步进频率。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\372B.tif" src="Image00468.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::system_clock::durationtypedef</h4>
<p class="zw">
<code class="calibre10">std::chrono::duration</code>
 类模板的实例，它能够保存由系统范围实时时钟所返回的任意两个时间点的差值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\372C.tif" src="Image00469.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::system_clock::time_pointtypedef</h4>
<p class="zw">
<code class="calibre10">std::chrono::time_point</code>
 类模板的实例，它能够保存由系统范围实时时钟返回的时间点。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\372D.tif" src="Image00470.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::system_clock::now静态成员函数</h4>
<p class="zw">从系统范围实时时钟获取当前的挂钟时间。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\372E.tif" src="Image00471.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">代表当前系统范围实时时钟的当前时间的<code class="calibre10">time_point</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果发生错误，引发<code class="calibre10">std::system_error</code>
 类型的异常。</p>
<h4 class="sigil_not_in_toc">std::chrono::system_clock::to_time_t静态成员函数</h4>
<p class="zw">将<code class="calibre10">time_point</code>
 实例转换到<code class="calibre10">time_t</code>
 。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\372F.tif" src="Image00472.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">表示与<code class="calibre10">t</code>
 相同时间点的<code class="calibre10">time_t</code>
 值，<code class="calibre10">t</code>
 会被进位或截取至秒的精度。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果发生错误，引发<code class="calibre10">std::system_error</code>
 类型的异常。</p>
<h4 class="sigil_not_in_toc">std::chrono::system_clock::from_time_t静态成员函数</h4>
<p class="zw">将<code class="calibre10">time_t</code>
 实例转换到<code class="calibre10">time_point</code>
 。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\373a.tif" src="Image00473.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">代表与<code class="calibre10">t</code>
 相同时间点的<code class="calibre10">time_point</code>
 值。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果发生错误，引发<code class="calibre10">std::system_error</code>
 类型的异常。</p>
<h3 id="nav_point_208" class="calibre14">D.1.4　std::chrono::steady_clock类</h3>
<p class="zw">
<code class="calibre10">std::chrono::steady_clock</code>
 类提供了对系统范围匀速时钟的访问。当前时间可以通过调用<code class="calibre10">std::chrono::steady_clock::now()</code>
 来获取。在<code class="calibre10">std::chrono::steady_clock::now()</code>
 和挂钟时间之间并没有固定的关系。匀速的时钟不能往回走，所以如果一个对<code class="calibre10">std::chrono::steady_clock::now()</code>
 的调用在另一个对它的调用之前，那么第二个调用必须返回与第一个相同或比它更晚的时间点。此时钟以统一的速率，尽可能久地前进。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\373B.tif" src="Image00474.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::steady_clock::rep typedef</h4>
<p class="zw">某个整数类型的类型别名，用来存储<code class="calibre10">duration</code>
 值中的刻度数量。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\373C.tif" src="Image00475.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::steady_clock::period typedef</h4>
<p class="zw">某<code class="calibre10">std::ratio</code>
 类模板实例的类型别名，用来指定在两个<code class="calibre10">duration</code>
 或<code class="calibre10">time_point</code>
 间最小的秒数（或几分之一秒）。<code class="calibre10">period</code>
 指定了时钟的<strong class="calibre3">精度</strong>
 ，而非其步进频率。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\373D.tif" src="Image00476.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::steady_clock::duration typedef</h4>
<p class="zw">
<code class="calibre10">std::chrono::duration</code>
 类模板的实例，它能够保存由系统范围匀速的时钟所返回的任意两个时间点的差值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\374a.tif" src="Image00477.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::steady_clock::time_pointtypedef</h4>
<p class="zw">
<code class="calibre10">std::chrono::time_point</code>
 类模板的实例，它能够保存由系统范围匀速的时钟返回的时间点。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\374B.tif" src="Image00478.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::chrono::steady_clock::now静态成员函数</h4>
<p class="zw">从系统范围匀速的时钟获取当前的时间。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\374C.tif" src="Image00479.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">代表当前系统范围匀速时钟的当前时间的<code class="calibre10">time_point</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果发生错误，引发<code class="calibre10">std::system_error</code>
 类型的异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">如果一个对<code class="calibre10">std:;chrono::steady_clock::now()</code>
 的调用发生在另一个之前，那么第一个调用所返回的<code class="calibre10">time_point</code>
 必须小于或等于第二个调用所返回的值。</p>
<h3 id="nav_point_209" class="calibre14">D.1.5　std::chrono::high_resolution_clock typedef</h3>
<p class="zw">
<code class="calibre10">std::chrono::high_resolution_clock</code>
 类以高精度提供了对系统范围时钟的访问。对于所有的时钟，当前时间可以通过调用<code class="calibre10">std::chrono::high_resolution_clock::now()</code>
 来获取。<code class="calibre10">std::chrono::high_resolution_clock</code>
 可以是<code class="calibre10">std::chrono::system_clock</code>
 类或者是<code class="calibre10">std::chrono::steady_clock</code>
 类的typedef，或者它可以是单独的类型。</p>
<p class="zw">尽管<code class="calibre10">std::chrono::high_resolution_clock</code>
 具有所有库中提供的时钟的最高精度，<code class="calibre10">std::chrono::high_resolution_clock::now()</code>
 仍然会占用一定的时间量。在对短操作进行计时的时候你必须小心的评估对<code class="calibre10">std::chrono::high_resolution_clock::now()</code>
 调用的开销。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\374D.tif" src="Image00480.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\375a.tif" src="Image00481.gif" class="calibre15"/>
</p>
<h2 id="nav_point_210" class="calibre11">D.2　&lt;condition_variable&gt;头文件</h2>
<p class="zw">
<code class="calibre10">&lt;condition_variable&gt;</code>
 头文件提供了条件变量。这些都是基本级别的同步机制，可以允许一个线程阻塞直到某些条件为真或者经过了超时期限。</p>
<p class="zw">
<strong class="calibre3">头文件内容</strong>
</p>
<p class="calibre16"><img alt="..\tu\375B.tif" src="Image00482.gif" class="calibre15"/>
</p>
<h3 id="nav_point_211" class="calibre14">D.2.1　std::condition_variable类</h3>
<p class="zw">
<code class="calibre10">std::condition_variable</code>
 类允许线程等待一个条件变为<code class="calibre10">true</code>
 。</p>
<p class="zw">
<code class="calibre10">std::condition_variable</code>
 的实例，不是<code class="calibre10">CopyAssignable</code>
 、<code class="calibre10">CopyConstructible</code>
 、<code class="calibre10">MoveAssignable</code>
 和<code class="calibre10">MoveConstructible</code>
 的。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\375C.tif" src="Image00483.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\376a.tif" src="Image00484.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::condition_variable默认构造函数</h4>
<p class="zw">构造<code class="calibre10">std::condition_variable</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\376B.tif" src="Image00485.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造一个新的<code class="calibre10">std::condition_variable</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果条件变量无法构造，抛出<code class="calibre10">std::system_error</code>
 类型的异常。</p>
<h4 class="sigil_not_in_toc">std::condition_variable析构函数</h4>
<p class="zw">销毁<code class="calibre10">std::condition_variable</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\376C.tif" src="Image00486.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">在对<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用中，没有线程被阻塞在<code class="calibre10">*this</code>
 上。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">销毁<code class="calibre10">*this</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::condition_variable::notify_one成员函数</h4>
<p class="zw">唤醒当前在<code class="calibre10">std::condition_variable</code>
 上等待的其中一条线程。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\376D.tif" src="Image00487.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">在调用处，唤醒在<code class="calibre10">*this</code>
 上等待的其中一条线程。如果没有线程等待着，此调用没有任何效果。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::condition_variable::notify_all成员函数</h4>
<p class="zw">唤醒当前在<code class="calibre10">std::condition_variable</code>
 上等待的全部线程。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\377a.tif" src="Image00488.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">在调用处，唤醒在<code class="calibre10">*this</code>
 上等待的所有线程。如果没有线程等待着，此调用没有任何效果。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::condition_variable::wait成员函数</h4>
<p class="zw">一直等待，直到<code class="calibre10">std::condition_variable</code>
 通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 或伪唤醒而被唤醒。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\377C.tif" src="Image00489.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">lock.owns_lock()</code>
 为真，且该锁为调用线程所拥有。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">原子级解锁所提供的<code class="calibre10">lock</code>
 对象并阻塞，直到该线程被另一个线程通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 而唤醒，或是线程自己伪唤醒。在对<code class="calibre10">wait()</code>
 的调用返回之前，<code class="calibre10">lock</code>
 对象被再次锁定。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。如果<code class="calibre10">lock</code>
 对象在调用<code class="calibre10">wait()</code>
 之中被解锁，它会在退出时再次被锁定，即便函数经由异常而退出。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 伪唤醒的意思是调用<code class="calibre10">wait()</code>
 的线程可能在没有线程调用过<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的情况下唤醒。因此建议如果可能的话，首选接受断言的<code class="calibre10">wait()</code>
 重载版本。否则，建议在一个测试与条件变量关联的断言的循环中来调用<code class="calibre10">wait()</code>
 。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::condition_variable::wait成员函数之接受断言的重载版本</h4>
<p class="zw">一直等待，直到<code class="calibre10">std::condition_variable</code>
 通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 而被唤醒，且断言为<code class="calibre10">true</code>
 。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\378a.tif" src="Image00490.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">表达式<code class="calibre10">pred()</code>
 必须有效，且其返回的可转换为<code class="calibre10">bool.lock.owns_lock()</code>
 的值必须为<code class="calibre10">true</code>
 ，且该锁必须被调用<code class="calibre10">wait()</code>
 的线程所拥有。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">类似于</p>
<p class="calibre16"><img alt="..\tu\378B.tif" src="Image00491.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">因调用<code class="calibre10">pred</code>
 所引发的所有异常，或者如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 潜在的伪唤醒的意思是无法确定<code class="calibre10">pred</code>
 会被调用多少次。<code class="calibre10">pred</code>
 总是被<code class="calibre10">lock</code>
 锁定的互斥元调用，而且当（且仅当）<code class="calibre10">(bool)pred()</code>
 返回<code class="calibre10">true</code>
 时该函数才会返回。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::condition_variable::wait_for成员函数</h4>
<p class="zw">一直等待，直到<code class="calibre10">std::condition_variable</code>
 通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 或伪唤醒而被唤醒，或者直到一个指定的时间段逝去或线程被伪唤醒。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\378C.tif" src="Image00492.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">lock.owns_lock()</code>
 为真，且该锁为调用线程所拥有。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">原子级解锁所提供的<code class="calibre10">lock</code>
 对象并阻塞，直到该线程被另一个线程通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 而唤醒，或者<code class="calibre10">relative_time</code>
 指定的时间段逝去，或是线程自己伪唤醒。在对<code class="calibre10">wait_for()</code>
 的调用返回之前，<code class="calibre10">lock</code>
 对象被再次锁定。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。如果<code class="calibre10">lock</code>
 对象在调用<code class="calibre10">wait()</code>
 之中被解锁，它会在退出时再次被锁定，即便函数经由异常而退出。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 伪唤醒的意思是调用<code class="calibre10">wait_for()</code>
 的线程可能在没有线程调用过<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的情况下唤醒。因此建议如果可能的话，首选接受断言的<code class="calibre10">wait_for()</code>
 重载版本。否则，建议在一个测试与条件变量关联的断言的循环中来调用<code class="calibre10">wait_for()</code>
 。当做此工作来确保超时仍然有效的时候必须注意，<code class="calibre10">wait_until()</code>
 在多数场合下可能会更合适。线程可能会比指定的时间段阻塞更久。如果可能，逝去的时间应决定于匀速时钟。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::condition_variable::wait_for成员函数之接受断言的重载版本</h4>
<p class="zw">一直等待，直到<code class="calibre10">std::condition_variable</code>
 通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 且断言为<code class="calibre10">true</code>
 ，或者直到一个指定的时间段逝去。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\379.tif" src="Image00493.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">表达式<code class="calibre10">pred()</code>
 必须有效，且其返回的可转换为<code class="calibre10">bool.lock.owns_lock()</code>
 的值必须为<code class="calibre10">true</code>
 ，且该锁必须被调用<code class="calibre10">wait_for()</code>
 的线程所拥有。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">类似于</p>
<p class="calibre16"><img alt="..\tu\380a.tif" src="Image00494.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果对<code class="calibre10">pred()</code>
 最近的调用返回<code class="calibre10">true</code>
 ，则返回<code class="calibre10">true</code>
 ，如果由<code class="calibre10">relative_time</code>
 指定的时间间隔逝去且<code class="calibre10">pred()</code>
 返回<code class="calibre10">false</code>
 ，则返回<code class="calibre10">false</code>
 。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 潜在的伪唤醒的意思是无法确定<code class="calibre10">pred</code>
 会被调用多少次。<code class="calibre10">pred</code>
 总是被<code class="calibre10">lock</code>
 锁定的互斥元调用，而且当（且仅当）<code class="calibre10">(bool)pred()</code>
 返回<code class="calibre10">true</code>
 或者<code class="calibre10">relative_time</code>
 指定的时间段逝去时该函数才会返回。线程可能会比指定的时间段阻塞更久。如果可能，逝去的时间应决定于匀速时钟。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">因调用<code class="calibre10">pred</code>
 所引发的所有异常，或者如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::condition_variable::wait_until成员函数</h4>
<p class="zw">一直等待，直到<code class="calibre10">std::condition_variable</code>
 通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 或伪唤醒而被唤醒，或者达到一个指定的时间，或线程被伪唤醒。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\380B.tif" src="Image00495.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">lock.owns_lock()</code>
 为真，且该锁为调用线程所拥有。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">原子地解锁所提供的<code class="calibre10">lock</code>
 对象并阻塞，直到该线程被另一个线程通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 而唤醒，或者<code class="calibre10">Clock::now()</code>
 返回了一个等于或晚于<code class="calibre10">absolute_time</code>
 的时间，或是线程自己伪唤醒。在对<code class="calibre10">wait_until()</code>
 的调用返回之前，<code class="calibre10">lock</code>
 对象被再次锁定。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果线程被<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用唤醒或者伪唤醒，返回<code class="calibre10">std::cv_status::no_timeout</code>
 ，否则返回<code class="calibre10">std::cv_status::timeout</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。如果<code class="calibre10">lock</code>
 对象在调用<code class="calibre10">wait()</code>
 之中被解锁，它会在退出时再次被锁定，即便函数经由异常而退出。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 伪唤醒的意思是调用<code class="calibre10">wait_until()</code>
 的线程可能在没有线程调用过<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的情况下唤醒。因此建议如果可能的话，首选接受断言的<code class="calibre10">wait_until()</code>
 重载版本。否则，建议在一个测试与条件变量关联的断言的循环中来调用<code class="calibre10">wait_until()</code>
 。没有保证说调用线程会被阻塞多久，只有当函数返回<code class="calibre10">false</code>
 ，且<code class="calibre10">Clock::now()</code>
 返回的时间等于或晚于<code class="calibre10">absolute_time</code>
 的时间点，线程才会解除阻塞。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::condition_variable::wait_until成员函数之接受断言的重载版本</h4>
<p class="zw">一直等待，直到<code class="calibre10">std::condition_variable</code>
 通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 且断言为<code class="calibre10">true</code>
 ，或者达到直到一个指定的时间。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\381a.tif" src="Image00496.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">表达式<code class="calibre10">pred()</code>
 必须有效，且其返回的可转换为<code class="calibre10">bool.lock.owns_lock()</code>
 的值必须为<code class="calibre10">true</code>
 ，且该锁必须被调用<code class="calibre10">wait_until()</code>
 的线程所拥有。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">类似于</p>
<p class="calibre16"><img alt="..\tu\381B.tif" src="Image00497.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果对<code class="calibre10">pred()</code>
 最近的调用返回<code class="calibre10">true</code>
 ，则返回<code class="calibre10">true</code>
 ，如果由<code class="calibre10">relative_time</code>
 指定的时间间隔逝去且<code class="calibre10">pred()</code>
 返回<code class="calibre10">false</code>
 ，则返回<code class="calibre10">false</code>
 。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 潜在的伪唤醒的意思是无法确定<code class="calibre10">pred</code>
 会被调用多少次。<code class="calibre10">pred</code>
 总是被<code class="calibre10">lock</code>
 锁定的互斥元调用，而且当（且仅当）<code class="calibre10">(bool)pred()</code>
 返回<code class="calibre10">true</code>
 或者<code class="calibre10">Clock::now()</code>
 返回一个等于或晚于<code class="calibre10">absolute_time</code>
 的时间，函数才会返回。没有保证说调用线程会被阻塞多久，只有当函数返回<code class="calibre10">false</code>
 ，且<code class="calibre10">Clock::now()</code>
 返回的时间等于或晚于<code class="calibre10">absolute_time</code>
 的时间点，线程才会解除阻塞。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">因调用<code class="calibre10">pred</code>
 所引发的所有异常，或者如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::notify_all_at_thread_exit非成员函数</h4>
<p class="zw">在当前线程退出时，唤醒所有等待<code class="calibre10">std::condition_variable</code>
 的线程。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\382a.tif" src="Image00498.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">lk.owns_lock()</code>
 为<code class="calibre10">true</code>
 ，并且该锁被调用线程持有。<code class="calibre10">lk.mutex()</code>
 应该返回相同的值，作为任意提供给<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 或<code class="calibre10">wait_until()</code>
 的锁对象，在来自当前等待线程的cv上。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">将<code class="calibre10">lk</code>
 持有的锁的所有权转移给内部存储，并且计划当调用线程退出时通知<code class="calibre10">cv</code>
 。此通知应该类似于：</p>
<p class="calibre16"><img alt="..\tu\382B.tif" src="Image00499.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果无法达成该结果，引发<code class="calibre10">std:system_error</code>
 异常。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 锁会一直持有到线程退出，所以必须小心避免死锁。建议调用线程应尽早退出，并且在该线程上不要进行阻塞操作。</p>
</blockquote>
<p class="zw">用户应该确保等待线程不会在被唤醒的时候错误地假设线程已退出，尤其有潜在的伪唤醒时。要达到这一目的，可以在等待线程上测试一个只会做出<code class="calibre10">true</code>
 的断言，在互斥元的保护下通知线程，且不在调用<code class="calibre10">notify_all_at_thread_exit</code>
 之前释放互斥元上的锁。</p>
<h3 id="nav_point_212" class="calibre14">D.2.2　std::condition_variable_any类</h3>
<p class="zw">
<code class="calibre10">std::condition_variable</code>
 类允许线程等待一个条件变为<code class="calibre10">true</code>
 。这里<code class="calibre10">std::condition_variable</code>
 只能与<code class="calibre10">std::unique_lock&lt;std::mutex&gt;</code>
 一起使用，<code class="calibre10">std::condition_variable_any</code>
 可以与<strong class="calibre3">任意</strong>
 符合<code class="calibre10">Lockable</code>
 需求的类型一起使用。</p>
<p class="zw">
<code class="calibre10">std::condition_variable_any</code>
 的实例，不是<code class="calibre10">CopyAssignable</code>
 、<code class="calibre10">CopyConstructible</code>
 、<code class="calibre10">MoveAssignable</code>
 和<code class="calibre10">MoveConstructible</code>
 的。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00500.jpg" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::condition_variable_any默认构造函数</h4>
<p class="zw">构造<code class="calibre10">std::condition_variable_any</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\384B.tif" src="Image00501.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造一个新的<code class="calibre10">std::condition_variable_any</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果条件变量无法构造，引发<code class="calibre10">std::system_error</code>
 类型的异常。</p>
<h4 class="sigil_not_in_toc">std::condition_variable_any析构函数</h4>
<p class="zw">销毁<code class="calibre10">std::condition_variable_any</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\384C.tif" src="Image00502.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">在对<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用中，没有线程被阻塞在<code class="calibre10">*this</code>
 上。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">销毁<code class="calibre10">*this</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::condition_variable_any::notify_one成员函数</h4>
<p class="zw">唤醒当前在<code class="calibre10">std::condition_variable_any</code>
 上等待的其中一条线程。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\384D.tif" src="Image00503.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">在调用处，唤醒在<code class="calibre10">*this</code>
 上等待的其中以一条线程。如果没有线程等待着，此调用没有任何效果。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable_any</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::condition_variable_any::notify_all成员函数</h4>
<p class="zw">唤醒当前在<code class="calibre10">std::condition_variable_any</code>
 上等待的全部线程。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\385a.tif" src="Image00504.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">在调用处，唤醒在<code class="calibre10">*this</code>
 上等待的所有线程。如果没有线程等待着，此调用没有任何效果。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable_any</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::condition_variable_any::wait成员函数</h4>
<p class="zw">一直等待，直到<code class="calibre10">std::condition_variable_any</code>
 通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 而被唤醒或伪唤醒。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\385B.tif" src="Image00505.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">Lockable</code>
 满足<code class="calibre10">Lockable</code>
 需求，且<code class="calibre10">lock</code>
 拥有锁<code class="calibre10">。</code>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">原子级解锁所提供的<code class="calibre10">lock</code>
 对象并阻塞，直到该线程被另一个线程通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 而唤醒，或是线程自己伪唤醒。在对<code class="calibre10">wait()</code>
 的调用返回之前，<code class="calibre10">lock</code>
 对象被再次锁定。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。如果<code class="calibre10">lock</code>
 对象在调用<code class="calibre10">wait()</code>
 之中被解锁，它会在退出时再次被锁定，即便函数经由异常而退出。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 伪唤醒的意思是调用<code class="calibre10">wait()</code>
 的线程可能在没有线程调用过<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的情况下唤醒。因此建议如果可能的话，首选接受断言的<code class="calibre10">wait()</code>
 重载版本。否则，建议在一个测试与条件变量关联的断言的循环中来调用<code class="calibre10">wait()</code>
 。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable_any</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::condition_variable_any::wait成员函数之接受断言的重载版本</h4>
<p class="zw">一直等待，直到<code class="calibre10">std::condition_variable_any</code>
 通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 而被唤醒，且断言为<code class="calibre10">true</code>
 。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\386a.tif" src="Image00506.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">表达式<code class="calibre10">pred()</code>
 必须有效，且其返回的可转换为<code class="calibre10">bool.lock.owns_lock()</code>
 的值必须为<code class="calibre10">true</code>
 。<code class="calibre10">Lockable</code>
 满足<code class="calibre10">Lockable</code>
 需求，且<code class="calibre10">lock</code>
 拥有锁<code class="calibre10">。</code>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">类似于</p>
<p class="calibre16"><img alt="..\tu\386B.tif" src="Image00507.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">因调用<code class="calibre10">pred</code>
 所引发的所有异常，或者如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 潜在的伪唤醒的意思是无法确定<code class="calibre10">pred</code>
 会被调用多少次。<code class="calibre10">pred</code>
 总是被<code class="calibre10">lock</code>
 锁定的互斥元调用，而且当（且仅当）<code class="calibre10">(bool)pred()</code>
 返回<code class="calibre10">true</code>
 时该函数才会返回。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable_any</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::condition_variable_any::wait_for成员函数</h4>
<p class="zw">一直等待，直到<code class="calibre10">std::condition_variable</code>
 通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 或伪唤醒而被唤醒，或者直到一个指定的时间段逝去或线程被伪唤醒。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\386C.tif" src="Image00508.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">Lockable</code>
 满足<code class="calibre10">Lockable</code>
 需求，且<code class="calibre10">lock</code>
 拥有锁<code class="calibre10">。</code>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">原子级解锁所提供的<code class="calibre10">lock</code>
 对象并阻塞，直到该线程被另一个线程通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 而唤醒，或者<code class="calibre10">relative_time</code>
 指定的时间段逝去，或是线程自己伪唤醒。在对<code class="calibre10">wait_for()</code>
 的调用返回之前，<code class="calibre10">lock</code>
 对象被再次锁定。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。如果<code class="calibre10">lock</code>
 对象在调用<code class="calibre10">wait()</code>
 之中被解锁，它会在退出时再次被锁定，即便函数经由异常而退出。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 伪唤醒的意思是调用<code class="calibre10">wait_for()</code>
 的线程可能在没有线程调用过<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的情况下唤醒。因此建议如果可能的话，首选接受断言的<code class="calibre10">wait_for()</code>
 重载版本。否则，建议在一个测试与条件变量关联的断言的循环中来调用<code class="calibre10">wait_for()</code>
 。当做此工作来确保超时仍然有效的时候必须注意；<code class="calibre10">wait_until()</code>
 在多数场合下可能会更合适。线程可能会比指定的时间段阻塞更久。如果可能，逝去的时间应决定于匀速时钟。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable_any</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::condition_variable_any::wait_for成员函数之接受断言的重载版本</h4>
<p class="zw">一直等待，直到<code class="calibre10">std::condition_variable_any</code>
 通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 且断言为<code class="calibre10">true</code>
 ，或者直到一个指定的时间段逝去。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\387a.tif" src="Image00509.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">表达式<code class="calibre10">pred()</code>
 必须有效，且其返回的可转换为<code class="calibre10">bool.lock</code>
 。<code class="calibre10">Lockable</code>
 满足<code class="calibre10">Lockable</code>
 需求，且<code class="calibre10">lock</code>
 拥有锁<code class="calibre10">。</code>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">类似于</p>
<p class="calibre16"><img alt="..\tu\387B.tif" src="Image00510.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果对<code class="calibre10">pred()</code>
 最近的调用返回<code class="calibre10">true</code>
 ，则返回<code class="calibre10">true</code>
 ，如果由<code class="calibre10">relative_time</code>
 指定的时间间隔逝去且<code class="calibre10">pred()</code>
 返回<code class="calibre10">false</code>
 ，则返回<code class="calibre10">false</code>
 。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 潜在的伪唤醒的意思是无法确定<code class="calibre10">pred</code>
 会被调用多少次。<code class="calibre10">pred</code>
 总是被<code class="calibre10">lock</code>
 锁定的互斥元调用，而且当（且仅当）<code class="calibre10">(bool)pred()</code>
 返回<code class="calibre10">true</code>
 或者<code class="calibre10">relative_time</code>
 指定的时间段逝去时该函数才会返回。线程可能会比指定的时间段阻塞更久。如果可能，逝去的时间应决定于匀速时钟。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">因调用<code class="calibre10">pred</code>
 所引发的所有异常，或者如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable_any</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::condition_variable::wait_until成员函数</h4>
<p class="zw">一直等待，直到<code class="calibre10">std::condition_variable</code>
 通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 或伪唤醒而被唤醒，或者达到一个指定的时间，或线程被伪唤醒。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\388a.tif" src="Image00511.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">lock.owns_lock()</code>
 为真，且该锁为调用线程所拥有。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">原子级解锁所提供的<code class="calibre10">lock</code>
 对象并阻塞，直到该线程被另一个线程通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 而唤醒，或者<code class="calibre10">Clock::now()</code>
 返回了一个等于或晚于<code class="calibre10">absolute_time</code>
 的时间，或是线程自己伪唤醒。在对<code class="calibre10">wait_until()</code>
 的调用返回之前，<code class="calibre10">lock</code>
 对象被再次锁定。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果线程被<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用唤醒或者伪唤醒，返回<code class="calibre10">std::cv_status::no_timeout</code>
 ，否则返回<code class="calibre10">std::cv_status::timeout</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。如果<code class="calibre10">lock</code>
 对象在调用<code class="calibre10">wait()</code>
 之中被解锁，它会在退出时再次被锁定，即便函数经由异常而退出。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 伪唤醒的意思是调用<code class="calibre10">wait()</code>
 的线程可能在没有线程调用过<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的情况下唤醒。因此建议如果可能的话，首选接受断言的<code class="calibre10">wait()</code>
 重载版本。否则，建议在一个测试与条件变量关联的断言的循环中来调用<code class="calibre10">wait_until()</code>
 。没有保证说调用线程会被阻塞多久，只有当函数返回<code class="calibre10">false</code>
 ，且<code class="calibre10">Clock::now()</code>
 返回的时间等于或晚于<code class="calibre10">absolute_time</code>
 的时间点，线程才会解除阻塞。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable_any</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h4 class="sigil_not_in_toc">std::condition_variable::wait_until成员函数之接受断言的重载版本</h4>
<p class="zw">一直等待，直到<code class="calibre10">std::condition_variable</code>
 通过调用<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 且断言为<code class="calibre10">true</code>
 ，或者直到达到一个指定的时间。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\389aa.tif" src="Image00512.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">表达式<code class="calibre10">pred()</code>
 必须有效，且其返回的可转换为<code class="calibre10">bool.lock.owns_lock()</code>
 的值必须为<code class="calibre10">true</code>
 ，且该锁必须被调用<code class="calibre10">wait()</code>
 的线程所拥有。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">类似于</p>
<p class="calibre16"><img alt="..\tu\389B.tif" src="Image00513.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果对<code class="calibre10">pred()</code>
 最近的调用返回<code class="calibre10">true</code>
 ，则返回<code class="calibre10">true</code>
 ，如果由<code class="calibre10">relative_time</code>
 指定的时间间隔逝去且<code class="calibre10">pred()</code>
 返回<code class="calibre10">false</code>
 ，则返回<code class="calibre10">false</code>
 。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 潜在的伪唤醒的意思是无法确定<code class="calibre10">pred</code>
 会被调用多少次。<code class="calibre10">pred</code>
 总是被<code class="calibre10">lock</code>
 锁定的互斥元调用，而且当（且仅当）<code class="calibre10">(bool)pred()</code>
 返回<code class="calibre10">true</code>
 或者<code class="calibre10">Clock::now()</code>
 返回一个等于或晚于<code class="calibre10">absolute_time</code>
 的时间，函数才会返回。没有保证说调用线程会被阻塞多久，只有当函数返回<code class="calibre10">false</code>
 ，且<code class="calibre10">Clock::now()</code>
 返回的时间等于或晚于<code class="calibre10">absolute_time</code>
 的时间点，线程才会解除阻塞。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">因调用<code class="calibre10">pred</code>
 所引发的所有异常，或者如果无法得到结果，引发<code class="calibre10">std::system_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在单一<code class="calibre10">std::condition_variable_any</code>
 实例上对<code class="calibre10">notify_one()</code>
 、<code class="calibre10">notify_all()</code>
 、<code class="calibre10">wait()</code>
 、<code class="calibre10">wait_for()</code>
 和<code class="calibre10">wait_until()</code>
 的调用会被序列化。对<code class="calibre10">notify_one()</code>
 或<code class="calibre10">notify_all()</code>
 的调用，只会唤醒在该调用<strong class="calibre3">之前</strong>
 就开始等待的线程。</p>
<h2 id="nav_point_213" class="calibre11">D.3　&lt;atomic&gt;头文件</h2>
<p class="zw">
<code class="calibre10">&lt;atomic&gt;</code>
 头文件提供了一组基本的原子类型以及对这些类型的操作，还有一个类模板，用来构造满足一些条件的用户定义类型的原子版本。</p>
<p class="zw">
<strong class="calibre3">头文件内容</strong>
</p>
<p class="calibre16"><img alt="..\tu\390.tif" src="Image00514.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\391.tif" src="Image00515.gif" class="calibre15"/>
</p>
<h3 id="nav_point_214" class="calibre14">D.3.1　std::atomic_xxx typedef</h3>
<p class="zw">为了向下兼容C标准，提供了原子整型的typedef。这既是对相应<code class="calibre10">std::atomic&lt;T&gt;</code>
 特化的typedef，也是具有相同接口特化的基类。</p>
<table border="1" width="90%" class="calibre19">
<thead class="calibre20">
<tr class="calibre21">
<th class="calibre22">
<p class="calibre2">std::atomic<em class="calibre9">itype</em>
</p>
</th>
<th class="calibre22">
<p class="calibre2">std::atomic&lt;&gt;特化</p>
</th>
</tr>
</thead>
<tbody class="calibre23">
<tr class="calibre21">
<td class="calibre24">
<p class="calibre2">std::atomic_char<br class="calibre5"/>
std::atomic_schar<br class="calibre5"/>
std::atomic_uchar<br class="calibre5"/>
std::atomic_short<br class="calibre5"/>
std::atomic_ushort<br class="calibre5"/>
std::atomic_int<br class="calibre5"/>
std::atomic_uint<br class="calibre5"/>
std::atomic_long<br class="calibre5"/>
std::atomic_ulong<br class="calibre5"/>
std::atomic_llong<br class="calibre5"/>
std::atomic_ullong<br class="calibre5"/>
std::atomic_wchar_t<br class="calibre5"/>
std::atomic_char16_t<br class="calibre5"/>
std::atomic_char32_t</p>
</td>
<td class="calibre24">
<p class="calibre2">std::atomic&lt;char&gt;<br class="calibre5"/>
std::atomic&lt;signed char&gt;　　<br class="calibre5"/>
std::atomic&lt;unsigned char&gt;　<br class="calibre5"/>
std::atomic&lt;short&gt;　　<br class="calibre5"/>
std::atomic&lt;unsigned short&gt;　　<br class="calibre5"/>
std::atomic&lt;int&gt;　　<br class="calibre5"/>
std::atomic&lt;unsigned int&gt;　　<br class="calibre5"/>
std::atomic&lt;long&gt;　　<br class="calibre5"/>
std::atomic&lt;unsigned long&gt;<br class="calibre5"/>
std::atomic&lt;long long&gt;<br class="calibre5"/>
std::atomic&lt;unsigned long long&gt;<br class="calibre5"/>
std::atomic&lt;wchar_t&gt;　<br class="calibre5"/>
std::atomic&lt;char16_t&gt;<br class="calibre5"/>
std::atomic&lt;char32_t&gt;</p>
</td>
</tr>
</tbody>
</table>
<h3 id="nav_point_215" class="calibre14">D.3.2　ATOMIC_xxx_LOCK_FREE宏</h3>
<p class="zw">这些宏确定了对应特定内置类型的源自类型是不是无锁的。</p>
<p class="zw">
<strong class="calibre3">宏声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\392.tif" src="Image00516.gif" class="calibre15"/>
</p>
<p class="zw">
<code class="calibre10">ATOMIC</code>
 _<code class="calibre10">xxx</code>
 _<code class="calibre10">LOCK</code>
 _<code class="calibre10">FREE</code>
 的值是0、1或2。值0表示该操作对于提名类型对应的有符号和无符号原子类型从来都不是无锁的，值1表示该操作对于那些类型在特定场合下可能是无锁的，而其他场合则不是，值2表示该操作始终是无锁的。例如，如果<code class="calibre10">ATOMIC</code>
 _<code class="calibre10">INT</code>
 _<code class="calibre10">LOCK</code>
 _<code class="calibre10">FREE</code>
 是2，<code class="calibre10">std::atomic&lt;int&gt;</code>
 和<code class="calibre10">std::atomic&lt;unsigned&gt;</code>
 上的操作始终是无锁的。</p>
<p class="zw">
<code class="calibre10">ATOMIC</code>
 _<code class="calibre10">POINTER</code>
 _<code class="calibre10">LOCK</code>
 _<code class="calibre10">FREE</code>
 宏描述了在原子指针特化<code class="calibre10">std::atomic&lt;T*&gt;</code>
 上的操作的无锁属性。</p>
<h3 id="nav_point_216" class="calibre14">D.3.3　ATOMIC_VAR_INIT宏</h3>
<p class="zw">
<code class="calibre10">ATOMIC</code>
 _<code class="calibre10">VAR</code>
 _<code class="calibre10">INIT</code>
 宏提供了将原子变量初始化至特定值的方法。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\393a.tif" src="Image00517.gif" class="calibre15"/>
</p>
<p class="zw">这个宏展开至令牌序列，能够以下面的形式，用来在表达式里使用指定值初始化标准原子类型：</p>
<p class="calibre16"><img alt="..\tu\393B.tif" src="Image00518.gif" class="calibre15"/>
</p>
<p class="zw">指定的值必须与对应于原子类型的非原子类型相兼容，例如：</p>
<p class="calibre16"><img alt="..\tu\393C.tif" src="Image00519.gif" class="calibre15"/>
</p>
<p class="zw">这样的初始化不是原子的，并且任何通过其他线程访问即将初始化的变量时，初始化没有发生于访问之前就会产生数据竞争而且是未定义的行为。</p>
<h3 id="nav_point_217" class="calibre14">D.3.4　std::memory_order枚举</h3>
<p class="zw">
<code class="calibre10">std::memory_order</code>
 枚举用来指定原子操作的排序约束。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\393D.tif" src="Image00520.gif" class="calibre15"/>
</p>
<p class="zw">标记有这些内存顺序值的操作表现如下（参见第5章）。</p>
<h4 class="sigil_not_in_toc">std::memory_order_relaxed</h4>
<p class="zw">此操作不会提供任何额外的排序约束。</p>
<h4 class="sigil_not_in_toc">std::memory_order_release</h4>
<p class="zw">此操作是在指定内存地点的释放操作。它因此在与一个读取存储值相同内存地点的获取操作同步。</p>
<h4 class="sigil_not_in_toc">std::memory_order_acquire</h4>
<p class="zw">此操作是在指定内存地点的获取操作。如果存储的值被一个释放操作所写，则该存储与此操作同步。</p>
<h4 class="sigil_not_in_toc">std::memory_order_acq_rel</h4>
<p class="zw">此操作必须是读-修改-写操作，并且在指定地点同时表现为<code class="calibre10">std::memory_order_acquire</code>
 和<code class="calibre10">std::memory_order_release</code>
 。</p>
<h4 class="sigil_not_in_toc">std::memory_order_seq_cst</h4>
<p class="zw">此操作构成顺序一致操作的一个全局总体排序的一部分。另外，如果这是个存储，它表现为<code class="calibre10">std::memory_order_release</code>
 操作；如果这是个载入，它表现为<code class="calibre10">std::memory_order_acquire</code>
 操作；如果它是读-修改-写操作，它同时表现为<code class="calibre10">std::memory_order_acquire</code>
 和<code class="calibre10">std::memory_order_release</code>
 。这是所有操作的默认值。</p>
<h4 class="sigil_not_in_toc">std::memory_order_consume</h4>
<p class="zw">此操作是在指定的内存位置的消费操作。</p>
<h3 id="nav_point_218" class="calibre14">D.3.5　std::atomic_thread_fence函数</h3>
<p class="zw">
<code class="calibre10">std::atomic_thread_fence()</code>
 在代码中插入一个“内存障碍”或是“屏障”，以便在操作之间强制内存顺序约束。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\394a.tif" src="Image00521.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">插入一个带有所需内存顺序约束的屏障。</p>
<p class="zw">带有<code class="calibre10">std::memory_order_release</code>
 、<code class="calibre10">std::memory_order_acq_rel</code>
 或<code class="calibre10">std::memory_order_seq_cst</code>
 的<code class="calibre10">order</code>
 的屏障，与相同内存地址上的获取操作同步，如果该获取操作读取一个由屏障后面原子操作存储的值在相同的线程上。</p>
<p class="zw">释放操作与带有<code class="calibre10">std::memory_order_acquire</code>
 、<code class="calibre10">std::memory_order_acq_rel</code>
 或<code class="calibre10">std::memory_order_seq_cst的order</code>
 的屏障同步，如果该释放操作存储一个被屏障前的原子操作读取的值。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h3 id="nav_point_219" class="calibre14">D.3.6　std::atomic_signal_fence函数</h3>
<p class="zw">
<code class="calibre10">std::atomic_signal_fence()</code>
 函数在代码中插入一个内存障碍或屏障，以便在线程上的操作和线程上信号句柄中的操作之间强制内存顺序约束</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\394B.tif" src="Image00522.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">插入一个带有所需内存顺序约束的屏障。等效于<code class="calibre10">std::atomic_thread_fence(order)</code>
 ，除了此约束只应用在线程和同一线程上的信号句柄之间。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h3 id="nav_point_220" class="calibre14">D.3.7　std::atomic_flag类</h3>
<p class="zw">
<code class="calibre10">std::atomic_flag</code>
 类提供了原子flag的简单骨架。这是C++11标准唯一<strong class="calibre3">保证</strong>
 为无锁的数据类型（尽管很多原子类型在大多数实现中也是无锁的）。</p>
<p class="zw">
<code class="calibre10">std::atomic_flag</code>
 的实例要么是<strong class="calibre3">set</strong>
 要么是<strong class="calibre3">clear</strong>
 。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\395a.tif" src="Image00523.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_flag默认构造函数</h4>
<p class="zw">默认构造的<code class="calibre10">std::atomic_flag</code>
 实例是clear还是set是未指定的。对于静态存储时限的对象，初始化应该是静态初始化。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\395B.tif" src="Image00524.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造在未指定的状态的新的<code class="calibre10">std::atomic_flag</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::atomic_flag使用atomic_flag_init初始化</h4>
<p class="zw">
<code class="calibre10">std::atomic_flag</code>
 的实例可以使用<code class="calibre10">ATOMIC_FLAG_INIT</code>
 宏来初始化，这种情况下它会初始化为<strong class="calibre3">clear</strong>
 状态。对于静态存储时限的对象，初始化应该是静态初始化。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\395C.tif" src="Image00525.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">用法</strong>
</p>
<p class="calibre16"><img alt="..\tu\396a.tif" src="Image00526.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造在<strong class="calibre3">clear</strong>
 状态的新的<code class="calibre10">std::atomic_flag</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::atomic_flag::test_and_set成员函数</h4>
<p class="zw">原子级设置flag，并检查它是不是已设置。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\396B.tif" src="Image00527.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">设置flag。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果flag在调用处是已设置的，返回<code class="calibre10">true</code>
 ，如果flag是清除的，返回<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 这是一项对于包括<code class="calibre10">*this</code>
 的内存地址的原子的读-修改-写操作。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic_flag_test_and_set非成员函数</h4>
<p class="zw">设置flag，并检查它是不是已设置。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\396C.tif" src="Image00528.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\396D.tif" src="Image00529.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_flag_test_and_set_explicit非成员函数</h4>
<p class="zw">设置flag，并检查它是不是已设置。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\396E.tif" src="Image00530.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\396F.tif" src="Image00531.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_flag::clear成员函数</h4>
<p class="zw">清除flag。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\396G.tif" src="Image00532.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">提供的<code class="calibre10">order</code>
 必须是<code class="calibre10">std::memory_order_relaxed</code>
 、<code class="calibre10">std::memory_order_release</code>
 或<code class="calibre10">std::memory_order_seq_cst</code>
 其中之一。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">清除flag。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 这是对包括<code class="calibre10">*this</code>
 的内存地址的原子存储操作。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic_flag_clear非成员函数</h4>
<p class="zw">清除flag。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\397a.tif" src="Image00533.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\397B.tif" src="Image00534.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_flag_clear_explicit非成员函数</h4>
<p class="zw">清除flag。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\397C.tif" src="Image00535.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\397D.tif" src="Image00536.gif" class="calibre15"/>
</p>
<h3 id="nav_point_221" class="calibre14">D.3.8　std::atomic类模板</h3>
<p class="zw">
<code class="calibre10">std::atomic</code>
 类模板提供了一个带有原子操作的封装器，可以用于任意符合下面需求的类型。</p>
<p class="zw">模板参数<code class="calibre10">BaseType</code>
 必须具备如下特点。</p>
<ul class="calibre13">
<li class="di_1ji_wu_xu_lie_biao">
<span class="calibre18">有平凡的默认构造函数。</span>
</li>
<li class="di_1ji_wu_xu_lie_biao">
<span class="calibre18">有平凡的拷贝赋值运算符。</span>
</li>
<li class="di_1ji_wu_xu_lie_biao">
<span class="calibre18">有平凡的析构函数。</span>
</li>
<li class="di_1ji_wu_xu_lie_biao">
<span class="calibre18">可以进行按位相等比较。</span>
</li>
</ul>
<p class="zw">这基本上意味着<code class="calibre10">std::atomic&lt;some-built-in-type&gt;</code>
 是正确的，正如<code class="calibre10">std::atomic&lt;some-simple-struct&gt;</code>
 ，但像<code class="calibre10">std::atomic&lt;std::string&gt;</code>
 这样的就不行了。</p>
<p class="zw">在主模板之外，还有为内置整型而设的特化，和提供类似<code class="calibre10">x++</code>
 这样额外操作的指针。</p>
<p class="zw">
<code class="calibre10">std::atomic</code>
 的实例不是<code class="calibre10">CopyConstructible</code>
 和<code class="calibre10">CopyAssignable</code>
 的，因为这些操作都不能作为一个单一原子操作来进行。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\398.tif" src="Image00537.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\399.tif" src="Image00538.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\400a.tif" src="Image00539.gif" class="calibre15"/>
</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 尽管这些非成员函数被指定为模板，它们可以作为函数的重载集来提供，且不应该使用模板参数的显式特化。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic默认构造函数</h4>
<p class="zw">使用默认初始化值构造<code class="calibre10">std::atomic</code>
 的实例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\400B.tif" src="Image00540.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">使用默认初始化值构造一个新的<code class="calibre10">std::atomic</code>
 的实例。对于静态存储时限的对象，初始化应该是静态初始化。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 使用默认构造函数初始化的带有非静态存储时限的<code class="calibre10">std::atomic</code>
 实例，不能指望它拥有一个可预见的值。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::atomic_int非成员函数</h4>
<p class="zw">在<code class="calibre10">std::atomic&lt;BaseType&gt;</code>
 的实例中非原子级存储给定的值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\400C.tif" src="Image00541.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">非原子级将<code class="calibre10">v</code>
 的值存储在<code class="calibre10">*p</code>
 中。在一个尚未默认构造的或是在构造后已进行过任何操作的<code class="calibre10">atomic&lt;BaseType&gt;</code>
 实例上调用<code class="calibre10">atomic_init()</code>
 ，都是未定义的行为。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 由于该存储是非原子的，所有来自于另一线程的对<code class="calibre10">p</code>
 所指向的对象的并发访问（即便是原子的）均构成数据竞争。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::atomic转换构造函数</h4>
<p class="zw">用给定的<code class="calibre10">BaseType</code>
 值构造<code class="calibre10">std::atomic</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\401a.tif" src="Image00542.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">用<code class="calibre10">b</code>
 的值构造新的<code class="calibre10">std::atomic</code>
 对象。对于静态存储时限的对象这是静态初始化。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::atomic转换赋值运算符</h4>
<p class="zw">在<code class="calibre10">*this</code>
 中存储一个新的值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\401B.tif" src="Image00543.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\401C.tif" src="Image00544.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic::is_lock_free成员函数</h4>
<p class="zw">确定在<code class="calibre10">*this</code>
 上的操作是无锁的。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\401D.tif" src="Image00545.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果在<code class="calibre10">*this</code>
 上的操作是无锁的，返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::atomic::is_lock_free非成员函数</h4>
<p class="zw">确定在<code class="calibre10">*this</code>
 上的操作是无锁的。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00546.jpg" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00547.jpg" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic::load成员函数</h4>
<p class="zw">原子级载入<code class="calibre10">std::atomic</code>
 实例的当前值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\402B.tif" src="Image00548.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">提供的<code class="calibre10">order</code>
 必须是<code class="calibre10">std::memory_order_relaxed</code>
 、<code class="calibre10">std::memory_order_release</code>
 或<code class="calibre10">std::memory_order_seq_cst</code>
 其中之一。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">原子级载入存储在<code class="calibre10">*this</code>
 中的值。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">在调用时<code class="calibre10">*this</code>
 中存储的值。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 这是对包括<code class="calibre10">*this</code>
 的内存地址的原子载入操作。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic_load非成员函数</h4>
<p class="zw">原子级载入<code class="calibre10">std::atomic</code>
 实例的当前值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\402C.tif" src="Image00549.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\402D.tif" src="Image00550.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_load非成员函数</h4>
<p class="zw">原子级载入<code class="calibre10">std::atomic</code>
 实例的当前值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\新建文件夹\402e.tif" src="Image00551.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\新建文件夹\402f.tif" src="Image00552.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic::operator基类型转换运算符</h4>
<p class="zw">载入存储在<code class="calibre10">*this</code>
 中的值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\403a.tif" src="Image00553.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\403b.tif" src="Image00554.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic::store成员函数</h4>
<p class="zw">在<code class="calibre10">atomic&lt;BaseType&gt;</code>
 实例中存储一个新值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\403c.tif" src="Image00555.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">提供的<code class="calibre10">order</code>
 必须是<code class="calibre10">std::memory_order_relaxed</code>
 、<code class="calibre10">std::memory_order_release</code>
 或<code class="calibre10">std::memory_order_seq_cst</code>
 其中之一。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">在<code class="calibre10">*this</code>
 中存储<code class="calibre10">new_value</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 这是对包括<code class="calibre10">*this</code>
 的内存地址的原子存储操作。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic_store非成员函数</h4>
<p class="zw">在<code class="calibre10">atomic&lt;BaseType&gt;</code>
 实例中存储一个新值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\403d.tif" src="Image00556.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\403e.tif" src="Image00557.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_store_explicit非成员函数</h4>
<p class="zw">在<code class="calibre10">atomic&lt;BaseType&gt;</code>
 实例中存储一个新值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\403f.tif" src="Image00558.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\404a.tif" src="Image00559.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic::exchange成员函数</h4>
<p class="zw">存储一个新值并读取旧值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\404b.tif" src="Image00560.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">在<code class="calibre10">*this</code>
 中存储<code class="calibre10">new_value</code>
 ，并且获取现存的<code class="calibre10">*this</code>
 值。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">在刚刚存储之前的<code class="calibre10">*this</code>
 值。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 这是一项对于包括<code class="calibre10">*this</code>
 的内存地址的原子的读-修改-写操作。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic_exchange非成员函数</h4>
<p class="zw">在<code class="calibre10">atomic&lt;BaseType&gt;</code>
 实例中存储一个新的值并且读取之前的值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\404c.tif" src="Image00561.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\404d.tif" src="Image00562.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_exchange_explicit非成员函数</h4>
<p class="zw">在<code class="calibre10">atomic&lt;BaseType&gt;</code>
 实例中存储一个新的值并且读取之前的值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\404e.tif" src="Image00563.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\404f.tif" src="Image00564.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic::compare_exchange_strong成员函数</h4>
<p class="zw">原子级将值与一个期望值进行比较，并且如果两个值相等，就存储新的值。如果两个值不相等，就用读取到的值更新期望值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\405a.tif" src="Image00565.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">failure_order</code>
 不能是<code class="calibre10">std::memory_order_release</code>
 或<code class="calibre10">std::memory_order_acq_rel</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">将<code class="calibre10">expected</code>
 与<code class="calibre10">*this</code>
 中存储的值进行按位比较，并且当相等时将<code class="calibre10">new_value</code>
 存储在<code class="calibre10">*this</code>
 中，否则，将<code class="calibre10">expected</code>
 更新为读取到的值。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果<code class="calibre10">*this</code>
 中存在的值与<code class="calibre10">expected</code>
 相等，返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 三参数的重载与带有<code class="calibre10">success_order==order</code>
 和<code class="calibre10">failure_order==order</code>
 的四参数重载是等效的，除非<code class="calibre10">order</code>
 是<code class="calibre10">std::memory_order_acq_rel</code>
 而<code class="calibre10">failure_order</code>
 是<code class="calibre10">std::memory_order_acquire</code>
 ，或者<code class="calibre10">order</code>
 是<code class="calibre10">std::memory_order_release</code>
 而<code class="calibre10">failure_order</code>
 是<code class="calibre10">std::memory_order_relaxed</code>
 。</p>
</blockquote>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 如果结果为<code class="calibre10">true</code>
 ，这就是对包括<code class="calibre10">*this</code>
 的内存地址的原子读-修改-写操作，带有内存顺序<code class="calibre10">success_order</code>
 ；否则，它就是对包括<code class="calibre10">*this</code>
 的内存地址的载入操作，带有内存顺序<code class="calibre10">failure_order</code>
 。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic_compare_exchange_strong非成员函数</h4>
<p class="zw">将值与一个期望值进行比较，并且如果两个值相等，就存储新的值。如果两个值不相等，就用读取到的值更新期望值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\405b.tif" src="Image00566.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\406a.tif" src="Image00567.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic::compare_exchange_weak成员函数</h4>
<p class="zw">将值与一个期望值进行比较，并且如果两个值相等且更新可以在原子级完成，就存储新的值。如果两个值不相等或是更新不能在原子级完成，就用读取到的值更新期望值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="C:\Documents and Settings\gong60\桌面\p396.tif" src="Image00568.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">failure_order</code>
 不能是<code class="calibre10">std::memory_order_release</code>
 或<code class="calibre10">std::memory_order_acq_rel</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">将<code class="calibre10">expected</code>
 与<code class="calibre10">*this</code>
 中存储的值进行按位比较，并且当相等时将<code class="calibre10">new_value</code>
 存储在<code class="calibre10">*this</code>
 中。如果两个值不相等或是更新不能原子级进行，就将<code class="calibre10">expected</code>
 更新为读取到的值。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果<code class="calibre10">*this</code>
 中存在的值与<code class="calibre10">expected</code>
 相等且<code class="calibre10">new_value</code>
 成功存储在*this中，返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 三参数的重载与带有<code class="calibre10">success_order==order</code>
 和<code class="calibre10">failure_order==order</code>
 的四参数重载是等效的，除非<code class="calibre10">order</code>
 是<code class="calibre10">std::memory_order_acq_rel</code>
 而<code class="calibre10">failure_order</code>
 是<code class="calibre10">std::memory_order_acquire</code>
 ，或者<code class="calibre10">order</code>
 是<code class="calibre10">std::memory_order_release</code>
 而<code class="calibre10">failure_order</code>
 是<code class="calibre10">std::memory_order_relaxed</code>
 。</p>
</blockquote>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 如果结果为<code class="calibre10">true</code>
 ，这就是对包括<code class="calibre10">*this</code>
 的内存地址的原子读-修改-写操作，带有内存顺序<code class="calibre10">success_order</code>
 ；否则，它就是对包括<code class="calibre10">*this</code>
 的内存地址的载入操作，带有内存顺序<code class="calibre10">failure_order</code>
 。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic_compare_exchange_weak非成员函数</h4>
<p class="zw">将值与一个期望值进行比较，并且如果两个值相等，就存储新的值。如果两个值不相等，就用读取到的值更新期望值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\新建文件夹\407a.tif" src="Image00569.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\新建文件夹\407b.tif" src="Image00570.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_compare_exchange_weak非成员函数</h4>
<p class="zw">将值与一个期望值进行比较，并且如果两个值相等，就存储新的值。如果两个值不相等，就用读取到的值更新期望值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\407c.tif" src="Image00571.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\408a.tif" src="Image00572.gif" class="calibre15"/>
</p>
<h3 id="nav_point_222" class="calibre14">D.3.9　std::atomic模板的特化</h3>
<p class="zw">
<code class="calibre10">std::atomic</code>
 类模板的特化提供给整型和指针类型。对于整型，这些特化在主模板提供的操作之外，又额外提供了原子级的加、减和按位操作。对于指针类型，这一特化在主模板提供的操作之外又额外提供了原子级的指针算数运算。</p>
<p class="zw">为下面的整型提供了特化：</p>
<p class="calibre16"><img alt="..\tu\408b.tif" src="Image00573.gif" class="calibre15"/>
</p>
<p class="zw">以及对所有类型<code class="calibre10">T</code>
 的<code class="calibre10">std::atomic&lt;T*&gt;</code>
 。</p>
<h3 id="nav_point_223" class="calibre14">D.3.10　std::atomic&lt;integral-type&gt;特化</h3>
<p class="zw">
<code class="calibre10">std::atomic</code>
 类模板的<code class="calibre10">std::atomic&lt;integral-type&gt;</code>
 特化为每一个基本的整型提供了原子整型数据类型，同时带有一整套的操作。</p>
<p class="zw">下面的描述应用于这些<code class="calibre10">std::atomic&lt;&gt;</code>
 类模板的特化。</p>
<p class="calibre16"><img alt="..\tu\408c.tif" src="Image00574.gif" class="calibre15"/>
</p>
<p class="zw">这些特化的实例不是<code class="calibre10">CopyConstructible</code>
 和<code class="calibre10">CopyAssignable</code>
 的，因为这些操作都不能作为一个单一原子操作来进行。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\409.tif" src="Image00575.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\410.tif" src="Image00576.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\411.tif" src="Image00577.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\412a.tif" src="Image00578.gif" class="calibre15"/>
</p>
<p class="zw">在主模板中同时提供的那些操作（参见D.3.8）拥有同样的语义。</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;integral-type&gt;::fetch_add成员函数</h4>
<p class="zw">载入一个值，并且将其替换为它的值与提供的<code class="calibre10">i</code>
 的值之和。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\412b.tif" src="Image00579.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">获取<code class="calibre10">*this</code>
 现存值并且将<strong class="calibre3">旧值</strong>
 <code class="calibre10">+i</code>
 存储在<code class="calibre10">*this</code>
 中。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">刚刚在存储之前的<code class="calibre10">*this</code>
 值。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 这是一项对于包括<code class="calibre10">*this</code>
 的内存地址的原子的读-修改-写操作。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic_fetch_add非成员函数</h4>
<p class="zw">从<code class="calibre10">atomic&lt;integral-type&gt;</code>
 实例读取值，并将其替换为该值加上提供的<code class="calibre10">i</code>
 值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\413a.tif" src="Image00580.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\413b.tif" src="Image00581.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_fetch_add_explicit非成员函数</h4>
<p class="zw">从<code class="calibre10">atomic&lt;integral-type&gt;</code>
 实例读取值，并将其替换为该值加上提供的<code class="calibre10">i</code>
 值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\413c.tif" src="Image00582.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\413d.tif" src="Image00583.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;integral-type&gt;::fetch_sub成员函数</h4>
<p class="zw">载入一个值，并且将其替换为它的值减去所提供的<code class="calibre10">i</code>
 的值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\413e.tif" src="Image00584.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">获取<code class="calibre10">*this</code>
 现存值并且将<strong class="calibre3">旧值</strong>
 <code class="calibre10">-i</code>
 存储在<code class="calibre10">*this</code>
 中。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">刚刚在存储之前的<code class="calibre10">*this</code>
 值。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 这是一项对于包括<code class="calibre10">*this</code>
 的内存地址的原子级的读-修改-写操作。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic_fetch_sub非成员函数</h4>
<p class="zw">从<code class="calibre10">atomic&lt;integral-type&gt;</code>
 实例读取值，并将其替换为该值减去提供的<code class="calibre10">i</code>
 值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\414a.tif" src="Image00585.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\414f.tif" src="Image00586.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_fetch_sub_explicit非成员函数</h4>
<p class="zw">从<code class="calibre10">atomic&lt;integral-type&gt;</code>
 实例读取值，并将其替换为该值减去提供的<code class="calibre10">i</code>
 值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\414b.tif" src="Image00587.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\414c.tif" src="Image00588.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;integral-type&gt;::fetch_and成员函数</h4>
<p class="zw">载入一个值，并将其替换为它的值与所提供的<code class="calibre10">i</code>
 值按位与的结果。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\414d.tif" src="Image00589.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">获取<code class="calibre10">*this</code>
 现存的值，并将<strong class="calibre3">旧值</strong>
 <code class="calibre10">&amp;i</code>
 存储在<code class="calibre10">*this</code>
 中。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">刚刚在存储之前的<code class="calibre10">*this</code>
 值。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 这是一项对于包括<code class="calibre10">*this</code>
 的内存地址的原子级的读-修改-写操作。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic_fetch_and非成员函数</h4>
<p class="zw">从<code class="calibre10">atomic&lt;integral-type&gt;</code>
 实例读取值，并将其替换为它的值与所提供的<code class="calibre10">i</code>
 值按位与的结果。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\414e.tif" src="Image00590.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\415a.tif" src="Image00591.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_fetch_and_explicit非成员函数</h4>
<p class="zw">从<code class="calibre10">atomic&lt;integral-type&gt;</code>
 实例读取值，并将其替换为它的值与所提供的<code class="calibre10">i</code>
 值按位与的结果。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\415b.tif" src="Image00592.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\415c.tif" src="Image00593.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;integral-type&gt;::fetch_or成员函数</h4>
<p class="zw">载入一个值，并将其替换为它的值与所提供的<code class="calibre10">i</code>
 值按位或的结果。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\415d.tif" src="Image00594.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">获取<code class="calibre10">*this</code>
 现存的值，并将<strong class="calibre3">旧值</strong>
 <code class="calibre10">|i</code>
 存储在<code class="calibre10">*this</code>
 中。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">刚刚在存储之前的<code class="calibre10">*this</code>
 值。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 这是一项对于包括<code class="calibre10">*this</code>
 的内存地址的原子级的读-修改-写操作。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic_fetch_or非成员函数</h4>
<p class="zw">从<code class="calibre10">atomic&lt;integral-type&gt;</code>
 实例读取值，并将其替换为它的值与所提供的<code class="calibre10">i</code>
 值按位或的结果。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\415e.tif" src="Image00595.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\415f.tif" src="Image00596.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_fetch_or_explicit非成员函数</h4>
<p class="zw">从<code class="calibre10">atomic&lt;integral-type&gt;</code>
 实例读取值，并将其替换为它的值与所提供的<code class="calibre10">i</code>
 值按位或的结果。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\416a.tif" src="Image00597.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\416b.tif" src="Image00598.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;integral-type&gt;::fetch_xor成员函数</h4>
<p class="zw">载入一个值，并将其替换为它的值与所提供的<code class="calibre10">i</code>
 值按位异或的结果。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\416c.tif" src="Image00599.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">获取<code class="calibre10">*this</code>
 现存的值，并将<strong class="calibre3">旧值</strong>
 <code class="calibre10">^i</code>
 存储在<code class="calibre10">*this</code>
 中。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">刚刚在存储之前的<code class="calibre10">*this</code>
 值。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 这是一项对于包括<code class="calibre10">*this</code>
 的内存地址的原子级的读-修改-写操作。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic_fetch_or非成员函数</h4>
<p class="zw">从<code class="calibre10">atomic&lt;integral-type&gt;</code>
 实例读取值，并将其替换为它的值与所提供的<code class="calibre10">i</code>
 值按位异或的结果。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\416d.tif" src="Image00600.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\416e.tif" src="Image00601.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_fetch_or_explicit非成员函数</h4>
<p class="zw">从<code class="calibre10">atomic&lt;integral-type&gt;</code>
 实例读取值，并将其替换为它的值与所提供的<code class="calibre10">i</code>
 值按位异或的结果。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\417a.tif" src="Image00602.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\417b.tif" src="Image00603.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;integral-type&gt;::operator++前置自增运算符</h4>
<p class="zw">递增存储在<code class="calibre10">*this</code>
 中的值并返回新值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\417c.tif" src="Image00604.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\417d.tif" src="Image00605.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;integral-type&gt;::operator++后置自增运算符</h4>
<p class="zw">递增存储在<code class="calibre10">*this</code>
 中的值并返回旧值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\417e.tif" src="Image00606.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\417f.tif" src="Image00607.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;integral-type&gt;::operator--前置自增运算符</h4>
<p class="zw">递增存储在<code class="calibre10">*this</code>
 中的值并返回新值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\417g.tif" src="Image00608.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\417h.tif" src="Image00609.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;integral-type&gt;::operator--后置自增运算符</h4>
<p class="zw">递增存储在<code class="calibre10">*this</code>
 中的值并返回旧值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\417i.tif" src="Image00610.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\417j.tif" src="Image00611.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;integral-type&gt;::operator+=复合赋值运算符</h4>
<p class="zw">将所给的值加到<code class="calibre10">*this</code>
 中存储的值上，并返回新值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\417k.tif" src="Image00612.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\418a.tif" src="Image00613.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;integral-type&gt;::operator-=复合赋值运算符</h4>
<p class="zw">从<code class="calibre10">*this</code>
 中存储的值减去所给的值，并返回新值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\418b.tif" src="Image00614.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\418c.tif" src="Image00615.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;integral-type&gt;::operator&amp;=复合赋值运算符</h4>
<p class="zw">将<code class="calibre10">*this</code>
 中存储的值替换为所给值和存储在<code class="calibre10">*this</code>
 中的值按位与的结果，并返回新值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\418d.tif" src="Image00616.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\418e.tif" src="Image00617.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;integral-type&gt;::operator|=复合赋值运算符</h4>
<p class="zw">将<code class="calibre10">*this</code>
 中存储的值替换为所给值和存储在<code class="calibre10">*this</code>
 中的值按位或的结果，并返回新值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\418f.tif" src="Image00618.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\418g.tif" src="Image00619.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;integral-type&gt;::operator^=复合赋值运算符</h4>
<p class="zw">将<code class="calibre10">*this</code>
 中存储的值替换为所给值和存储在<code class="calibre10">*this</code>
 中的值按位异或的结果，并返回新值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\418h.tif" src="Image00620.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\418i.tif" src="Image00621.gif" class="calibre15"/>
</p>
<h3 id="nav_point_224" class="calibre14">D.3.11　std::atomic&lt;T*&gt;偏特化</h3>
<p class="zw">
<code class="calibre10">std::atomic</code>
 类模板的<code class="calibre10">std::atomic&lt;T*&gt;偏</code>
 特化为每一个指针类型提供了原子数据类型，同时带有一整套的操作。</p>
<p class="zw">这些<code class="calibre10">std::atomic&lt;T*&gt;</code>
 的实例不是<code class="calibre10">CopyConstructible</code>
 和<code class="calibre10">CopyAssignable</code>
 的，因为这些操作都不能作为一个单一原子操作来进行。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\419.tif" src="Image00622.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\420.tif" src="Image00623.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\421a.tif" src="Image00624.gif" class="calibre15"/>
</p>
<p class="zw">在主模板中同时提供的那些操作（见D.3.8）拥有同样的语义。</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;T*&gt;::fetch_add成员函数</h4>
<p class="zw">载入一个值，并且使用标准指针算术规则将其替换为它的值与所给的<code class="calibre10">i</code>
 的值之和，并返回旧值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\421b.tif" src="Image00625.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">获取<code class="calibre10">*this</code>
 现存值并且将<strong class="calibre3">旧值</strong>
 <code class="calibre10">+i</code>
 存储在<code class="calibre10">*this</code>
 中。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">刚刚在存储之前的<code class="calibre10">*this</code>
 值。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 这是一项对于包括<code class="calibre10">*this</code>
 的内存地址的原子级的读-修改-写操作。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic_fetch_add非成员函数</h4>
<p class="zw">从<code class="calibre10">atomic&lt;T*&gt;</code>
 实例读取值，并使用标准指针算术规则，将其替换为该值加上提供的<code class="calibre10">i</code>
 值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\421c.tif" src="Image00626.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\421d.tif" src="Image00627.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_fetch_add_explicit非成员函数</h4>
<p class="zw">从<code class="calibre10">atomic&lt;T*&gt;</code>
 实例读取值，并使用标准指针算术规则，将其替换为该值加上提供的<code class="calibre10">i</code>
 值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\422a.tif" src="Image00628.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\422b.tif" src="Image00629.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;T*&gt;::fetch_sub成员函数</h4>
<p class="zw">载入一个值，并且使用标准指针算术规则将其替换为它的值减去所给的<code class="calibre10">i</code>
 的值，并返回旧值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\422c.tif" src="Image00630.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">获取<code class="calibre10">*this</code>
 现存值并且将<strong class="calibre3">旧值</strong>
 <code class="calibre10">-i</code>
 存储在<code class="calibre10">*this</code>
 中。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">刚刚在存储之前的<code class="calibre10">*this</code>
 值。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 这是一项对于包括<code class="calibre10">*this</code>
 的内存地址的原子级的读-修改-写操作。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::atomic_fetch_sub非成员函数</h4>
<p class="zw">从<code class="calibre10">atomic&lt;T*&gt;</code>
 实例读取值，并且使用标准指针算术规则，将其替换为它的值减去所给的<code class="calibre10">i</code>
 的值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\422d.tif" src="Image00631.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\422e.tif" src="Image00632.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic_fetch_sub_explicit非成员函数</h4>
<p class="zw">从<code class="calibre10">atomic&lt;T*&gt;</code>
 实例读取值，并且使用标准指针算术规则，将其替换为它的值减去所给的<code class="calibre10">i</code>
 的值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\422f.tif" src="Image00633.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\423a.tif" src="Image00634.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\423b.tif" src="Image00635.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;T*&gt;::operator++前置自增运算符</h4>
<p class="zw">使用标准指针算术规则递增存储在<code class="calibre10">*this</code>
 中的值并返回新值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\423c.tif" src="Image00636.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\424a.tif" src="Image00637.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;T*&gt;::operator++后置自增运算符</h4>
<p class="zw">使用标准指针算术规则递增存储在<code class="calibre10">*this</code>
 中的值并返回旧值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\423d.tif" src="Image00638.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\423e.tif" src="Image00639.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;T*&gt;::operator--前置自增运算符</h4>
<p class="zw">使用标准指针算术规则递增存储在<code class="calibre10">*this</code>
 中的值并返回新值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\423f.tif" src="Image00640.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\424a.tif" src="Image00641.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;T*&gt;::operator--后置自增运算符</h4>
<p class="zw">使用标准指针算术规则递增存储在<code class="calibre10">*this</code>
 中的值并返回旧值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\423h.tif" src="Image00642.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\423i.tif" src="Image00643.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;T*&gt;::operator+=复合赋值运算符</h4>
<p class="zw">使用标准指针算术规则将所给的值加到<code class="calibre10">*this</code>
 中存储的值上，并返回新值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\423j.tif" src="Image00644.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\424a.tif" src="Image00645.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::atomic&lt;T*&gt;::operator-=复合赋值运算符</h4>
<p class="zw">使用标准指针算术规则从<code class="calibre10">*this</code>
 中存储的值减去所给的值，并返回新值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\424b.tif" src="Image00646.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\424c.tif" src="Image00647.gif" class="calibre15"/>
</p>
<h2 id="nav_point_225" class="calibre11">D.4　&lt;future&gt;头文件</h2>
<p class="zw">
<code class="calibre10">&lt;future&gt;</code>
 头文件提供了一些工具，用来处理来自于可能执行在另一个线程上的操作的异步结果。</p>
<p class="zw">
<strong class="calibre3">头文件内容</strong>
</p>
<p class="calibre16"><img alt="..\tu\424d.tif" src="Image00648.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00649.jpg" class="calibre15"/>
</p>
<h3 id="nav_point_226" class="calibre14">D.4.1　std::future类模板</h3>
<p class="zw">
<code class="calibre10">std::future</code>
 类模板提供了从另一线程等待异步结果的方法，与<code class="calibre10">std::promise</code>
 、<code class="calibre10">std::packaged_task</code>
 类模板和<code class="calibre10">std::async</code>
 函数模板联合使用，可以用来提供此异步结果。在任意时刻，只有一个<code class="calibre10">std::future</code>
 实例引用所有给定的异步结果。</p>
<p class="zw">
<code class="calibre10">std::future</code>
 的实例是<code class="calibre10">MoveConstructible</code>
 和<code class="calibre10">MoveAssignable</code>
 的，但不是<code class="calibre10">CopyConstructible</code>
 或<code class="calibre10">CopyAssignable</code>
 的。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\425b.tif" src="Image00650.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::future默认构造函数</h4>
<p class="zw">构造与异步结果没有关联的<code class="calibre10">std::future</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\425c.tif" src="Image00651.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造一个新的<code class="calibre10">std::future</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">valid()</code>
 返回<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::future移动构造函数</h4>
<p class="zw">从另一个<code class="calibre10">std::future</code>
 对象中构造<code class="calibre10">std::future</code>
 对象，将与另一<code class="calibre10">std::future</code>
 对象关联的异步结果的所有权转移到新构造的实例中。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\426b.tif" src="Image00652.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">从<code class="calibre10">other</code>
 移动构造一个新的<code class="calibre10">std::future</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">在调用此构造函数之前与<code class="calibre10">other</code>
 关联的异步结果，现在被关联至新构造的<code class="calibre10">std::future</code>
 对象。<code class="calibre10">other</code>
 没有关联异步结果。<code class="calibre10">this-&gt;valid()</code>
 的返回值与在调用这一构造函数之前<code class="calibre10">other.valid()</code>
 会返回的值相同。<code class="calibre10">other.valid()</code>
 返回<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::future移动赋值运算符</h4>
<p class="zw">将于一个<code class="calibre10">std::future</code>
 对象关联的异步结果的所有权转移到另一个对象中。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\426c.tif" src="Image00653.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">在<code class="calibre10">std::future</code>
 实例间转移异步状态的所有权。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">在调用此构造函数之前与<code class="calibre10">other</code>
 关联的异步结果，现在被关联至新构造的<code class="calibre10">std::future</code>
 对象。<code class="calibre10">other</code>
 没有关联异步结果。在调用前关联至<code class="calibre10">*this</code>
 的异步状态（如果有）的所有权被释放，如果这是最后一个引用则状态被销毁。<code class="calibre10">this-&gt;valid()</code>
 的返回值与在调用这一构造函数之前<code class="calibre10">other.valid()</code>
 会返回的值相同。<code class="calibre10">other.valid()</code>
 返回<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::future析构函数</h4>
<p class="zw">销毁<code class="calibre10">std::future</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\426d.tif" src="Image00654.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">销毁<code class="calibre10">*this</code>
 。如果这是对关联至<code class="calibre10">*this</code>
 的异步结果（如果有）的最后一个引用，那么销毁该异步结果。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::future::share成员函数</h4>
<p class="zw">构造新的<code class="calibre10">std::shared_future</code>
 实例，并将关联至<code class="calibre10">*this</code>
 的异步结果的所有权转移至这个新构造的<code class="calibre10">std::shared_future</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\427a.tif" src="Image00655.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如同<code class="calibre10">shared_future&lt;ResultType&gt;(std::move(*this))</code>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">如果有调用<code class="calibre10">share()</code>
 ，那么在调用它之前关联至<code class="calibre10">*this</code>
 的异步结果，现在关联至新构造的<code class="calibre10">std::shared_future</code>
 实例。<code class="calibre10">this-&gt;valid()</code>
 返回<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::future::valid成员函数</h4>
<p class="zw">检查<code class="calibre10">std::future</code>
 实例是否关联至异步结果。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\427d.tif" src="Image00656.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果<code class="calibre10">*this</code>
 已关联至异步结果，返回<code class="calibre10">true</code>
 ，否则返回<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::future::wait成员函数</h4>
<p class="zw">如果关联至<code class="calibre10">*this</code>
 的状态包含延迟函数，调用此延迟函数。否则，一直等待到关联至<code class="calibre10">std::future</code>
 实例的异步结果就绪。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\427c.tif" src="Image00657.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;valid()</code>
 应返回<code class="calibre10">true</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果关联状态包含延迟函数，调用此延迟函数并存储返回值或将引发的异常存储为异步结果。否则，阻塞直到关联至<code class="calibre10">*this</code>
 的异步结果<strong class="calibre3">就绪</strong>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::future::wait_for成员函数</h4>
<p class="zw">一直等到关联至<code class="calibre10">std::future</code>
 实例的异步结果就绪，或者直到指定的时间段逝去。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\428a.tif" src="Image00658.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;valid()</code>
 应返回<code class="calibre10">true</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果关联至<code class="calibre10">*this</code>
 的异步结果包含延迟函数，它是从对<code class="calibre10">std:async</code>
 的调用发起的且尚未开始执行，则立即返回不进行阻塞。否则一直阻塞到关联至<code class="calibre10">*this</code>
 的异步结果<strong class="calibre3">就绪</strong>
 ，或者由<code class="calibre10">relative_time</code>
 指定的时间段逝去。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果关联至<code class="calibre10">*this</code>
 的异步调用包含延迟函数，它是从对<code class="calibre10">std:async</code>
 的调用发起的且尚未开始执行，返回<code class="calibre10">std::future_status::deferred</code>
 ，如果关联至<code class="calibre10">*this</code>
 的异步结果<strong class="calibre3">就绪</strong>
 ，返回<code class="calibre10">std::future_status::ready</code>
 ，如果由<code class="calibre10">relative_time</code>
 指定的时间段逝去则返回<code class="calibre10">std::future_status::timeout</code>
 。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 线程可能会比指定的时间段阻塞得更久。如果可能，逝去时间应由匀速时钟决定。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::future::wait_until成员函数</h4>
<p class="zw">一直等到关联至<code class="calibre10">std::future</code>
 实例的异步结果就绪，或者到达一个指定的 时间。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\428b.tif" src="Image00659.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;valid()</code>
 应返回<code class="calibre10">true</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果关联至<code class="calibre10">*this</code>
 的异步结果包含延迟函数，它是从对<code class="calibre10">std:async</code>
 的调用发起的且尚未开始执行，则立即返回不进行阻塞。否则一直阻塞到关联至<code class="calibre10">*this</code>
 的异步结果<strong class="calibre3">就绪</strong>
 ，或者<code class="calibre10">Clock::now()</code>
 返回一个等于或晚于<code class="calibre10">absolute_time</code>
 的时间。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果关联至<code class="calibre10">*this</code>
 的异步调用包含延迟函数，它是从对<code class="calibre10">std:async</code>
 的调用发起的且尚未开始执行，返回<code class="calibre10">std::future_status::deferred</code>
 ，如果关联至<code class="calibre10">*this</code>
 的异步结果<strong class="calibre3">就绪</strong>
 ，返回<code class="calibre10">std::future_status::ready</code>
 ，如果<code class="calibre10">Clock::now()</code>
 返回一个等于或晚于<code class="calibre10">absolute_time</code>
 的时间则返回<code class="calibre10">std::future_status::timeout</code>
 。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 不能保证调用线程会被阻塞多久，只有当函数返回<code class="calibre10">std::future_status::timeout</code>
 ，且<code class="calibre10">Clock::now()</code>
 返回一个等于或晚于<code class="calibre10">absolute_time</code>
 的时间的时候，线程才会被解锁。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::future::get成员函数</h4>
<p class="zw">如果关联着的状态包含一个来自对<code class="calibre10">std::async</code>
 调用的延迟函数，调用该函数并返回值；否则，一直等待到关联至<code class="calibre10">std::future</code>
 实例的异步结果就绪，接着返回存储的值或引发存储的异常。</p>
<p class="zw">声明</p>
<p class="calibre16"><img alt="..\tu\429a.tif" src="Image00660.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;valid()</code>
 应返回<code class="calibre10">true</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果关联至<code class="calibre10">*this</code>
 的状态包含延迟函数，调用该延迟函数并且返回结果或者传播任何已引发的异常。</p>
<p class="zw">否则，一直阻塞到关联至<code class="calibre10">*this</code>
 的异步结果就绪。如果结果是存储的异常，引发该异常。否则，返回存储的值。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果关联的状态包含延迟函数，返回该函数调用的结果。否则，如果<code class="calibre10">ResultType</code>
 是<code class="calibre10">void</code>
 ，调用正常返回。如果<code class="calibre10">ResultType</code>
 是某些类型<code class="calibre10">R</code>
 的<code class="calibre10">R&amp;</code>
 ，返回存储的引用。否则，返回存储的值。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">由延迟函数引发的异常，或存储在异步结果中的异常，如果有的话。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="calibre16"><img alt="..\tu\429b.tif" src="Image00661.gif" class="calibre15"/>
</p>
<h3 id="nav_point_227" class="calibre14">D.4.2　std::shared_future类模板</h3>
<p class="zw">
<code class="calibre10">std::shared_future</code>
 类模板提供了从另一线程等待异步结果的方法，与<code class="calibre10">std::promise</code>
 、<code class="calibre10">std::packaged_task</code>
 类模板和<code class="calibre10">std::async</code>
 函数模板联合使用，可以用来提供此异步结果。多个<code class="calibre10">std::shared_future</code>
 实例可以引用同一个异步结果。</p>
<p class="zw">
<code class="calibre10">std::shared_future</code>
 的实例是<code class="calibre10">CopyConstructible</code>
 或<code class="calibre10">CopyAssignable</code>
 的。你也可以从具有相同<code class="calibre10">ResultType</code>
 的<code class="calibre10">std::future</code>
 中移动构造一个<code class="calibre10">std::shared_furture</code>
 。</p>
<p class="zw">访问给定的<code class="calibre10">std::shared_future</code>
 实例不是同步的。因此多个线程在没有外部同步的情况下访问同一个<code class="calibre10">std::shared_future</code>
 实例是<strong class="calibre3">不安全</strong>
 的。但是访问关联状态是同步的，所以多个线程在没有外部同步的情况下，各自访问共享相同的关联状态的<code class="calibre10">std::shared_future</code>
 独立的实例<strong class="calibre3">是</strong>
 安全的。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\430a.tif" src="Image00662.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::shared_future默认构造函数</h4>
<p class="zw">构造与异步结果没有关联的<code class="calibre10">std::shared_future</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\430b.tif" src="Image00663.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造一个新的<code class="calibre10">std::shared_future</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">对于新构造的实例，<code class="calibre10">valid()</code>
 返回<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::shared_future移动构造函数</h4>
<p class="zw">从另一个<code class="calibre10">std::shared_future</code>
 对象中构造<code class="calibre10">std::shared_future</code>
 对象，将与另一<code class="calibre10">std::shared_future</code>
 对象关联的异步结果的所有权转移到新构造的实例中。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\431a.tif" src="Image00664.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">从<code class="calibre10">other</code>
 移动构造一个新的<code class="calibre10">std::shared_future</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">在调用此构造函数之前与<code class="calibre10">other</code>
 关联的异步结果，现在被关联至新构造的<code class="calibre10">std::shared</code>
 ——<code class="calibre10">future</code>
 对象。<code class="calibre10">other</code>
 没有关联异步结果。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::shared_future从std::future的移动构造函数</h4>
<p class="zw">从一个<code class="calibre10">std::future</code>
 对象中构造<code class="calibre10">std::shared_future</code>
 对象，将与<code class="calibre10">std::future</code>
 对象关联的异步结果的所有权转移到新构造的实例中。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\431b.tif" src="Image00665.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">从<code class="calibre10">other</code>
 移动构造一个新的<code class="calibre10">std::shared_future</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">在调用此构造函数之前与<code class="calibre10">other</code>
 关联的异步结果，现在被关联至新构造的<code class="calibre10">std::shared_future</code>
 对象。<code class="calibre10">other</code>
 没有关联异步结果。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::shared_future拷贝构造函数</h4>
<p class="zw">从另一个<code class="calibre10">std::shared_future</code>
 对象中构造<code class="calibre10">std::shared_future</code>
 对象，因而源和副本都会指向与源<code class="calibre10">std::shared_future</code>
 对象关联的异步结果，如果有的话。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\431c.tif" src="Image00666.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造一个新的<code class="calibre10">std::shared_future</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">在调用此构造函数之前与<code class="calibre10">other</code>
 关联的异步结果，现在被关联至新构造的<code class="calibre10">std::shared_future</code>
 对象<strong class="calibre3">和</strong>
 <code class="calibre10">other</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::shared_future析构函数</h4>
<p class="zw">销毁<code class="calibre10">std::shared_future</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\432a.tif" src="Image00667.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">销毁<code class="calibre10">*this</code>
 。如果不再有<code class="calibre10">std::promise</code>
 或<code class="calibre10">std::packaged_task</code>
 实例与关联至<code class="calibre10">*this</code>
 的异步结果相关联，并且这是对关联至<code class="calibre10">*this</code>
 的异步结果的最后一个<code class="calibre10">std::shared_future</code>
 ，那么销毁该异步结果。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::shared_future::valid成员函数</h4>
<p class="zw">检查<code class="calibre10">std::shared_future</code>
 实例是否关联至异步结果。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\432b.tif" src="Image00668.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果<code class="calibre10">*this</code>
 已关联至异步结果，返回<code class="calibre10">true</code>
 ，否则返回<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::shared_future::wait成员函数</h4>
<p class="zw">如果关联至<code class="calibre10">*this</code>
 的状态包含延迟函数，调用此延迟函数。否则，一直等待到关联至<code class="calibre10">std::shared_future</code>
 实例的异步结果就绪。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\432c.tif" src="Image00669.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;valid()</code>
 应返回<code class="calibre10">true</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">来自在共享相同关联状态的<code class="calibre10">std::shared_future</code>
 实例上多线程的<code class="calibre10">get()</code>
 和<code class="calibre10">wait()</code>
 调用是序列化的。如果关联状态包含延迟函数，首次调用<code class="calibre10">get()</code>
 或<code class="calibre10">wait()</code>
 会调用此延迟函数并存储返回值或将引发的异常存储为异步结果。</p>
<p class="zw">阻塞直到关联至<code class="calibre10">*this</code>
 的异步结果<strong class="calibre3">就绪</strong>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::shared_future::wait_for成员函数</h4>
<p class="zw">一直等待到关联至<code class="calibre10">std::shared_future</code>
 实例的异步结果就绪，或者直到指定的时间段逝去。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\433a.tif" src="Image00670.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;valid()</code>
 应返回<code class="calibre10">true</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果关联至<code class="calibre10">*this</code>
 的异步结果包含延迟函数，它是从对<code class="calibre10">std:async</code>
 的调用发起的且尚未开始执行，则立即返回不进行阻塞。否则一直阻塞到关联至<code class="calibre10">*this</code>
 的异步结果<strong class="calibre3">就绪</strong>
 ，或者由<code class="calibre10">relative_time</code>
 指定的时间段逝去。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果关联至<code class="calibre10">*this</code>
 的异步调用包含延迟函数，它是从对<code class="calibre10">std:async</code>
 的调用发起的且尚未开始执行，返回<code class="calibre10">std::future_status::deferred</code>
 ，如果关联至<code class="calibre10">*this</code>
 的异步结果<strong class="calibre3">就绪</strong>
 ，返回<code class="calibre10">std::future_status::ready</code>
 ，如果由<code class="calibre10">relative_time</code>
 指定的时间段逝去则返回<code class="calibre10">std::future_status::timeout</code>
 。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 线程可能会比指定的时间段阻塞得更久。如果可能，逝去时间应由匀速时钟决定。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::shared_future::wait_until成员函数</h4>
<p class="zw">一直等待到关联至<code class="calibre10">std::shared_future</code>
 实例的异步结果就绪，或者到达一个指定的时间。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\433b.tif" src="Image00671.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;valid()</code>
 应返回<code class="calibre10">true</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果关联至<code class="calibre10">*this</code>
 的异步结果包含延迟函数，它是从对<code class="calibre10">std:async</code>
 的调用发起的且尚未开始执行，则立即返回不进行阻塞。否则一直阻塞到关联至<code class="calibre10">*this</code>
 的异步结果<strong class="calibre3">就绪</strong>
 ，或者<code class="calibre10">Clock::now()</code>
 返回一个等于或晚于<code class="calibre10">absolute_time</code>
 的时间。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果关联至<code class="calibre10">*this</code>
 的异步调用包含延迟函数，它是从对<code class="calibre10">std:async</code>
 的调用发起的且尚未开始执行，返回<code class="calibre10">std::future_status::deferred</code>
 ，如果关联至<code class="calibre10">*this</code>
 的异步结果<strong class="calibre3">就绪</strong>
 ，返回<code class="calibre10">std::future_status::ready</code>
 ，如果<code class="calibre10">Clock::now()</code>
 返回一个等于或晚于<code class="calibre10">absolute_time</code>
 的时间则返回<code class="calibre10">std::future_status::timeout</code>
 。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 不能保证调用线程会被阻塞多久，只有当函数返回<code class="calibre10">std::future_status::timeout</code>
 ，且<code class="calibre10">Clock::now()</code>
 返回一个等于或晚于<code class="calibre10">absolute_time</code>
 的时间的时候，线程才会被解锁。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::shared_future::get成员函数</h4>
<p class="zw">如果关联着的状态包含一个来自对<code class="calibre10">std::async</code>
 调用的延迟函数，调用该函数并返回值。否则，一直等待到关联至<code class="calibre10">std::shared_future</code>
 实例的异步结果就绪，接着返回存储的值或引发存储的异常。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\434a.tif" src="Image00672.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;valid()</code>
 应返回<code class="calibre10">true</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">来自在共享相同关联状态的<code class="calibre10">std::shared_future</code>
 实例上多线程的<code class="calibre10">get()</code>
 和<code class="calibre10">wait()</code>
 调用是序列化的。如果关联状态包含延迟函数，首次调用<code class="calibre10">get()</code>
 或<code class="calibre10">wait()</code>
 会调用此延迟函数并存储返回值或将引发的异常存储为异步结果。</p>
<p class="zw">一直阻塞到关联至<code class="calibre10">*this</code>
 的异步结果<strong class="calibre3">就绪</strong>
 。如果结果是存储的异常，引发该异常。否则，返回存储的值。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果<code class="calibre10">ResultType</code>
 是<code class="calibre10">void</code>
 ，正常返回。如果<code class="calibre10">ResultType</code>
 是某些类型<code class="calibre10">R</code>
 的<code class="calibre10">R&amp;</code>
 ，返回存储的引用。否则，返回对存储值的<code class="calibre10">const</code>
 引用。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">存储的异常，如果有的话。</p>
<h3 id="nav_point_228" class="calibre14">D.4.3　std::packaged_task类模板</h3>
<p class="zw">
<code class="calibre10">std::packaged_task</code>
 类模板打包了函数或其他可调用对象，以便在函数经过<code class="calibre10">std::packaged_task</code>
 实例调用的时候，结果被存储为异步结果，可以通过<code class="calibre10">std::future</code>
 的实例来取得。</p>
<p class="zw">
<code class="calibre10">std::packaged_task</code>
 的实例是<code class="calibre10">MoveConstructible</code>
 和<code class="calibre10">MoveAssignable</code>
 的，但不是<code class="calibre10">CopyConstructible</code>
 或<code class="calibre10">CopyAssignable</code>
 的。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\434b.tif" src="Image00673.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\435a.tif" src="Image00674.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::packaged_task默认构造函数</h4>
<p class="zw">构造<code class="calibre10">std::packaged_task</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\435b.tif" src="Image00675.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造没有关联任务和异步结果的<code class="calibre10">std::packaged_task</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::packaged_task从可调用对象的构造函数</h4>
<p class="zw">构造有关联任务和异步结果的<code class="calibre10">std::packaged_task</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\435c.tif" src="Image00676.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">表达式<code class="calibre10">func(args...)</code>
 应有效，这里<code class="calibre10">args...</code>
 中的每个元素<code class="calibre10">args-i</code>
 都必须是相应的<code class="calibre10">ArgTypes...</code>
 中<code class="calibre10">ArgType-i</code>
 类型的值。返回值必须能够转换为<code class="calibre10">ResultType</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造<code class="calibre10">std::packaged_task</code>
 实例，带有未<strong class="calibre3">就绪</strong>
 的<code class="calibre10">ResultType</code>
 类型的关联异步结果以及<code class="calibre10">func</code>
 副本的<code class="calibre10">Callable</code>
 类型的关联任务。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果构造函数不能为异步结果分配内存，引发<code class="calibre10">std::bad_alloc</code>
 的异常。<code class="calibre10">Callable</code>
 的拷贝或移动构造函数引发的任何异常。</p>
<h4 class="sigil_not_in_toc">std::packaged_task从带有分配器的可调用对象的构造函数</h4>
<p class="zw">构造有关联任务和异步结果的<code class="calibre10">std::packaged_task</code>
 实例，使用所给的分配器来为关联的异步结果和任务分配内存。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\436a.tif" src="Image00677.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">表达式<code class="calibre10">func(args...)</code>
 应有效，这里<code class="calibre10">args...</code>
 中的每个元素<code class="calibre10">args-i</code>
 都必须是相应的<code class="calibre10">ArgTypes...</code>
 中<code class="calibre10">ArgType-i</code>
 类型的值。返回值必须能够转换为<code class="calibre10">ResultType</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造<code class="calibre10">std::packaged_task</code>
 实例，带有未<strong class="calibre3">就绪</strong>
 的<code class="calibre10">ResultType</code>
 类型的关联异步结果以及<code class="calibre10">func</code>
 副本的<code class="calibre10">Callable</code>
 类型的关联任务。异步结果和任务的内存是通过分配器<code class="calibre10">alloc</code>
 或其副本来分配的。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果构造函数不能为异步结果分配内存，引发<code class="calibre10">std::bad_alloc</code>
 的异常。由<code class="calibre10">Callable</code>
 的拷贝或移动构造函数引发的任何异常。</p>
<h4 class="sigil_not_in_toc">std::packaged_task移动构造函数</h4>
<p class="zw">从另一个<code class="calibre10">std::packaged_task</code>
 对象中构造<code class="calibre10">std::packaged_task</code>
 对象，将与另一<code class="calibre10">std::packaged_task</code>
 对象关联的异步结果的所有权转移到新构造的实例中。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\436b.tif" src="Image00678.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">从<code class="calibre10">other</code>
 移动构造一个新的<code class="calibre10">std::packaged_task</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">在调用此构造函数之前与<code class="calibre10">other</code>
 关联的异步结果，现在被关联至新构造的<code class="calibre10">std::packaged_task</code>
 对象。<code class="calibre10">other</code>
 没有关联异步结果。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::packaged_task移动赋值运算符</h4>
<p class="zw">将于一个<code class="calibre10">std::packaged_task</code>
 对象关联的异步结果的所有权转移到另一个对象中。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\437a.tif" src="Image00679.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">将关联至<code class="calibre10">other</code>
 的异步结果和任务的所有权转移至<code class="calibre10">*this</code>
 ，并且舍弃所有之前的异步结果，如同<code class="calibre10">std::packaged_task(other).swap(*this)</code>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">在调用此构造函数之前与<code class="calibre10">other</code>
 关联的异步结果，现在被关联至新构造的<code class="calibre10">std::future</code>
 对象。<code class="calibre10">other</code>
 没有关联异步结果。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::packaged_task::swap成员函数</h4>
<p class="zw">交换关联至两个<code class="calibre10">std::packaged_task</code>
 对象的异步结果的所有权。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\437c.tif" src="Image00680.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">交换关联至<code class="calibre10">other</code>
 和<code class="calibre10">*this</code>
 的异步结果的所有权。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">在调用<code class="calibre10">swap</code>
 之前关联至<code class="calibre10">other</code>
 的异步结果和任务（如果有）现在关联至<code class="calibre10">*this</code>
 。在调用<code class="calibre10">swap</code>
 之前关联至<code class="calibre10">*this</code>
 的异步结果和任务（如果有）现在关联至<code class="calibre10">other</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::packaged_task析构函数</h4>
<p class="zw">销毁<code class="calibre10">std::packaged_task</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\437d.tif" src="Image00681.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">销毁<code class="calibre10">*this</code>
 。如果<code class="calibre10">*this</code>
 拥有关联的异步结果，且该结果没有存储任务或异常，那么此结果变成<strong class="calibre3">就绪</strong>
 ，带有<code class="calibre10">std::future_errc::broken_promise</code>
 错误码的<code class="calibre10">std::future_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::packaged_task::get_future成员函数</h4>
<p class="zw">为关联至<code class="calibre10">*this</code>
 的异步结果获取<code class="calibre10">std::future</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\438a.tif" src="Image00682.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 拥有关联的异步结果。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">针对关联至<code class="calibre10">*this</code>
 的异步结果的<code class="calibre10">std::future</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果<code class="calibre10">std::future</code>
 已经在之前通过调用<code class="calibre10">get_future()</code>
 获取过了，引发带有<code class="calibre10">std::future_errc::future_already_retrieved</code>
 错误码的<code class="calibre10">std::future_error</code>
 类型的异常。</p>
<h4 class="sigil_not_in_toc">std::packaged_task::reset成员函数</h4>
<p class="zw">为同一个任务关联<code class="calibre10">std::packaged_task</code>
 至新的异步结果。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\438b.tif" src="Image00683.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 拥有关联的异步任务。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如同<code class="calibre10">*this=packaged_task(std::move(f))</code>
 ，这里<code class="calibre10">f</code>
 是已存储的关联至<code class="calibre10">*this</code>
 的任务。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果不能为新的异步结果分配内存，引发<code class="calibre10">std::bad_alloc</code>
 的异常。</p>
<h4 class="sigil_not_in_toc">std::packaged_task::valid成员函数</h4>
<p class="zw">检查<code class="calibre10">*this</code>
 是否拥有相关联的已步结果。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\438c.tif" src="Image00684.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果<code class="calibre10">*this</code>
 已关联至异步结果，返回<code class="calibre10">true</code>
 ，否则返回<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::packaged_task::operator()函数调用运算符</h4>
<p class="zw">调用关联至<code class="calibre10">std::packaged_task</code>
 实例的任务，并且将返回值或异常存储在相关联的异步结果中。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\438d.tif" src="Image00685.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 拥有关联的任务。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">像<code class="calibre10">INVOKE(func,args...)</code>
 那样调用关联的任务<code class="calibre10">func</code>
 。如果调用正常地返回，将返回值存储在关联至<code class="calibre10">*this</code>
 的异步结果中。如果调用带有异常地返回，将异常存储在关联至<code class="calibre10">*this</code>
 的异步结果中。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">关联至<code class="calibre10">*this</code>
 的异步结果<strong class="calibre3">就绪</strong>
 ，带有存储的值或异常。所有等待异步结果的被阻塞线程全部解除阻塞。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果异步结果已经拥有了存储的值或异常，引发带有<code class="calibre10">std::future_errc::promise_already_satisfied</code>
 错误码的<code class="calibre10">std::future_error</code>
 类型的异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">成功的对函数调用运算符进行调用，与对<code class="calibre10">std::future&lt;ResultType&gt;::get()</code>
 或<code class="calibre10">std::shared_future&lt;ResultType&gt;::get()</code>
 的调用同步，它们获取已存储的值或异常。</p>
<h4 class="sigil_not_in_toc">std::packaged_task::make_ready_at_thread_exit成员函数</h4>
<p class="zw">调用关联至<code class="calibre10">std::packaged_task</code>
 实例的任务，并且将返回值或异常存储在相关联的异步结果中，直到线程结束前都不将关联的异步结果变为<strong class="calibre3">就绪</strong>
 。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="zw">void make_ready_at_thread_exit(ArgTypes... args);</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 拥有关联的任务。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">像<code class="calibre10">INVOKE(func,args...)</code>
 那样调用关联的任务<code class="calibre10">func</code>
 。如果调用正常地返回，将返回值存储在关联至<code class="calibre10">*this</code>
 的异步结果中。如果调用带有异常地返回，将异常存储在关联至<code class="calibre10">*this</code>
 的异步结果中。调度关联的异步状态在当前线程退出的时候变为<strong class="calibre3">就绪</strong>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">关联至<code class="calibre10">*this</code>
 的异步结果拥有存储的值或异常，但直到当前线程推出之前都不是<strong class="calibre3">就绪</strong>
 的。所有等待异步结果的被阻塞线程在当前线程退出时全部解除阻塞。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果异步结果已经拥有了存储的值或异常，引发带有<code class="calibre10">std::future_errc::promise_already_satisfied</code>
 错误码的<code class="calibre10">std::future_error</code>
 类型的异常。如果<code class="calibre10">*this</code>
 没有相关联的同步状态，引发带有<code class="calibre10">std::future_errc::no_state</code>
 的<code class="calibre10">std::future_error</code>
 类型的异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">成功的对函数调用运算符进行调用，与对<code class="calibre10">std::future&lt;ResultType&gt;::get()</code>
 或<code class="calibre10">std::shared_future&lt;ResultType&gt;::get()</code>
 的调用同步，它们获取已存储的值或异常。</p>
<h3 id="nav_point_229" class="calibre14">D.4.4　std::promise类模板</h3>
<p class="zw">
<code class="calibre10">std::promise</code>
 类模板提供了从设置异步结果的方法，可以通过<code class="calibre10">std::future</code>
 实例从另一线程获取它。</p>
<p class="zw">
<code class="calibre10">ResultType</code>
 模板参数是可以被存储在异步结果的值的类型。</p>
<p class="zw">关联至特定的<code class="calibre10">std::promise</code>
 实例的异步结果的<code class="calibre10">std::future</code>
 可以通过调用<code class="calibre10">get_future()</code>
 成员函数来获得。异步结果既可以用<code class="calibre10">set_value()</code>
 成员函数设置为<code class="calibre10">ResultType</code>
 类型的值，也可以使用<code class="calibre10">set_exception()</code>
 成员函数设置为一个异常。</p>
<p class="zw">
<code class="calibre10">std::future</code>
 的实例是<code class="calibre10">MoveConstructible</code>
 和<code class="calibre10">MoveAssignable</code>
 的，但不是<code class="calibre10">CopyConstructible</code>
 或<code class="calibre10">CopyAssignable</code>
 的。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\440a.tif" src="Image00686.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::promise默认构造函数</h4>
<p class="zw">构造<code class="calibre10">std::promise</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\440b.tif" src="Image00687.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造<code class="calibre10">std::promise</code>
 实例，与一个没有<strong class="calibre3">就绪</strong>
 的<code class="calibre10">ResultType</code>
 类型的异步结果相关联。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果构造函数不能为异步结果分配内存，引发<code class="calibre10">std::bad_alloc</code>
 异常。</p>
<h4 class="sigil_not_in_toc">std::promise分配器构造函数</h4>
<p class="zw">构造<code class="calibre10">std::promise</code>
 对象，使用所给的分配器为关联的异步结果分配内存。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\441a.tif" src="Image00688.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造<code class="calibre10">std::promise</code>
 实例，与一个没有<strong class="calibre3">就绪</strong>
 的<code class="calibre10">ResultType</code>
 类型的异步结果相关联。通过分配器<code class="calibre10">alloc</code>
 为异步结果分配内存。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">构造器在试图为异步结果分配内存是引发的所有异常。</p>
<h4 class="sigil_not_in_toc">std::promise移动构造函数</h4>
<p class="zw">从另一个<code class="calibre10">std::promise</code>
 对象中构造<code class="calibre10">std::promise</code>
 对象，将与另一<code class="calibre10">std::promise</code>
 对象关联的异步结果的所有权转移到新构造的实例中。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\441b.tif" src="Image00689.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造一个新的<code class="calibre10">std::promise</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">在调用此构造函数之前与<code class="calibre10">other</code>
 关联的异步结果，现在被关联至新构造的<code class="calibre10">std::promise</code>
 对象。<code class="calibre10">other</code>
 没有关联异步结果。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::promise移动赋值运算符</h4>
<p class="zw">将于一个<code class="calibre10">std::promise</code>
 对象关联的异步结果的所有权转移到另一个对象中。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\441c.tif" src="Image00690.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">将关联至<code class="calibre10">other</code>
 的异步结果的所有权转移给<code class="calibre10">*this</code>
 。如果<code class="calibre10">*this</code>
 已经有了相关联的异步结果，该异步结果变为<strong class="calibre3">就绪</strong>
 ，带有<code class="calibre10">std::future_errc::broken_promise</code>
 错误码的<code class="calibre10">std::future_error</code>
 类型的异常。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">在调用此构造函数之前与<code class="calibre10">other</code>
 关联的异步结果，现在被关联至新构造的<code class="calibre10">std::future</code>
 对象。<code class="calibre10">other</code>
 没有关联异步结果。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\442a.tif" src="Image00691.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::promise::swap成员函数</h4>
<p class="zw">交换关联至两个<code class="calibre10">std::promise</code>
 对象的异步结果的所有权。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\442b.tif" src="Image00692.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">交换关联至<code class="calibre10">other</code>
 和<code class="calibre10">*this</code>
 的异步结果的所有权。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">在调用<code class="calibre10">swap</code>
 之前关联至<code class="calibre10">other</code>
 的异步结果和任务（如果有）现在关联至<code class="calibre10">*this</code>
 。在调用<code class="calibre10">swap</code>
 之前关联至<code class="calibre10">*this</code>
 的异步结果和任务（如果有）现在关联至<code class="calibre10">other</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::promise析构函数</h4>
<p class="zw">销毁<code class="calibre10">std::promise</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\442c.tif" src="Image00693.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">销毁<code class="calibre10">*this</code>
 。如果<code class="calibre10">*this</code>
 拥有关联的异步结果，且该结果没有存储任务或异常，那么此结果变成<strong class="calibre3">就绪</strong>
 ，带有<code class="calibre10">std::future_errc::broken_promise</code>
 错误码的<code class="calibre10">std::future_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::promise::get_future成员函数</h4>
<p class="zw">为关联至<code class="calibre10">*this</code>
 的异步结果获取<code class="calibre10">std::future</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\442d.tif" src="Image00694.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 拥有关联的异步结果。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">针对关联至<code class="calibre10">*this</code>
 的异步结果的<code class="calibre10">std::future</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果<code class="calibre10">std::future</code>
 已经在之前通过调用<code class="calibre10">get_future()</code>
 获取过了，引发带有<code class="calibre10">std::future_errc::future_already_retrieved</code>
 错误码的<code class="calibre10">std::future_error</code>
 类型的异常。</p>
<h4 class="sigil_not_in_toc">std::promise::set_value成员函数</h4>
<p class="zw">将一个值存储在与<code class="calibre10">*this</code>
 相关联的异步结果中。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\443a.tif" src="Image00695.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 拥有关联的异步任务。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果<code class="calibre10">ResultType</code>
 不是<code class="calibre10">void</code>
 ，就将<code class="calibre10">r</code>
 存储在与<code class="calibre10">*this</code>
 关联的异步结果中。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">关联至<code class="calibre10">*this</code>
 的异步结果<strong class="calibre3">就绪</strong>
 ，带有存储的值。所有等待异步结果的被阻塞线程全部解除阻塞。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果异步结果已经拥有了存储的值或异常，引发带有<code class="calibre10">std::future_errc::promise_already_satisfied</code>
 错误码的<code class="calibre10">std::future_error</code>
 类型的异常。由<code class="calibre10">r</code>
 的拷贝构造函数或移动构造函数引发的所有异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">多个并发的<code class="calibre10">set_value()</code>
 、<code class="calibre10">set_value_at_thread_exit()</code>
 、<code class="calibre10">set_exception()</code>
 和<code class="calibre10">set_exception_at_thread_exit()</code>
 调用都是序列化的。成功的对<code class="calibre10">set_value()</code>
 进行调用，发生于对<code class="calibre10">std::future&lt;ResultType&gt;::get()</code>
 或<code class="calibre10">std::shared_future&lt;ResultType&gt;::get()</code>
 之前，它们获取已存储的值。</p>
<h4 class="sigil_not_in_toc">std::promise::set_value_at_thread_exit成员函数</h4>
<p class="zw">将值存储在与<code class="calibre10">*this</code>
 相关联的异步结果中，直到线程结束前都不将关联的异步结果变为<strong class="calibre3">就绪</strong>
 。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\443b.tif" src="Image00696.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 拥有关联的异步结果。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果<code class="calibre10">ResultType</code>
 不是<code class="calibre10">void</code>
 ，就将<code class="calibre10">r</code>
 存储在关联至<code class="calibre10">*this</code>
 的异步结果中。将异步结果标记为拥有存储的值。调度关联的异步结果在当前线程退出的时候变为<strong class="calibre3">就绪</strong>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">关联至<code class="calibre10">*this</code>
 的异步结果拥有存储的值，但直到当前线程推出之前都不是<strong class="calibre3">就绪</strong>
 的。所有等待异步结果的被阻塞线程在当前线程退出时全部解除阻塞。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果异步结果已经拥有了存储的值或异常，引发带有<code class="calibre10">std::future_errc::promise_already_satisfied</code>
 错误码的<code class="calibre10">std::future_error</code>
 类型的异常。由<code class="calibre10">r</code>
 的拷贝构造函数或移动构造函数引发的所有异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">多个并发的<code class="calibre10">set_value()</code>
 、<code class="calibre10">set_value_at_thread_exit()</code>
 、<code class="calibre10">set_exception()</code>
 和<code class="calibre10">set_exception_at_thread_exit()</code>
 调用都是序列化的。成功的对<code class="calibre10">set_value_at_thread_exit()</code>
 进行调用，发生于对<code class="calibre10">std::future&lt;ResultType&gt;::get()</code>
 或<code class="calibre10">std::shared_future&lt;ResultType&gt;::get()</code>
 之前，它们获取已存储的值。</p>
<h4 class="sigil_not_in_toc">std::promise::set_exception成员函数</h4>
<p class="zw">将一个异常存储在与<code class="calibre10">*this</code>
 相关联的异步结果中。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\444a.tif" src="Image00697.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 拥有关联的异步任务。<code class="calibre10">(bool)e</code>
 为<code class="calibre10">true</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">将<code class="calibre10">e</code>
 存储在与<code class="calibre10">*this</code>
 关联的异步结果中。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">关联至<code class="calibre10">*this</code>
 的异步结果<strong class="calibre3">就绪</strong>
 ，带有存储的异常。所有等待异步结果的被阻塞线程全部解除阻塞。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果异步结果已经拥有了存储的值或异常，引发带有<code class="calibre10">std::future_errc::promise_already_satisfied</code>
 错误码的<code class="calibre10">std::future_error</code>
 类型的异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">多个并发的<code class="calibre10">set_value()</code>
 、<code class="calibre10">set_value_at_thread_exit()</code>
 、<code class="calibre10">set_exception()</code>
 和<code class="calibre10">set_exception_at_thread_exit()</code>
 调用都是序列化的。成功的对<code class="calibre10">set_value()</code>
 进行调用，发生于对<code class="calibre10">std::future&lt;ResultType&gt;::get()</code>
 或<code class="calibre10">std::shared_future&lt;ResultType&gt;::get()</code>
 之前，它们获取已存储的异常。</p>
<h4 class="sigil_not_in_toc">std::promise::set_exception_at_thread_exit成员函数</h4>
<p class="zw">将异常存储在与<code class="calibre10">*this</code>
 相关联的异步结果中，直到线程结束前都不将关联的异步结果变为<strong class="calibre3">就绪</strong>
 。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\444b.tif" src="Image00698.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 拥有关联的异步结果。<code class="calibre10">(bool)e</code>
 为<code class="calibre10">true</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">将<code class="calibre10">e</code>
 存储在关联至<code class="calibre10">*this</code>
 的异步结果中。调度关联的异步结果在当前线程退出的时候变为<strong class="calibre3">就绪</strong>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">关联至<code class="calibre10">*this</code>
 的异步结果拥有存储的异常，但直到当前线程退出之前都不是<strong class="calibre3">就绪</strong>
 的。所有等待异步结果的被阻塞线程在当前线程退出时全部解除阻塞。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果异步结果已经拥有了存储的值或异常，引发带有<code class="calibre10">std::future_errc::promise_already_satisfied</code>
 错误码的<code class="calibre10">std::future_error</code>
 类型的异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">多个并发的<code class="calibre10">set_value()</code>
 、<code class="calibre10">set_value_at_thread_exit()</code>
 、<code class="calibre10">set_exception()</code>
 和<code class="calibre10">set_exception_at_thread_exit()</code>
 调用都是序列化的。成功的对<code class="calibre10">set_exception_at_thread_exit()</code>
 进行调用，发生于对<code class="calibre10">std::future&lt;ResultType&gt;::get()</code>
 或<code class="calibre10">std::shared_future&lt;ResultType&gt;::get()</code>
 之前，它们获取已存储的异常。</p>
<h3 id="nav_point_230" class="calibre14">D.4.5　std::async函数模板</h3>
<p class="zw">
<code class="calibre10">std::async</code>
 是一种利用现成的硬件并发来运行自包含异步人物的简单途径。对<code class="calibre10">std::async</code>
 的调用返回一个包含任务结果的<code class="calibre10">std::future</code>
 。取决于启动策略，该任务可以异步地运行在它自己的线程上，也可以同步地运行于任何在此future调用<code class="calibre10">wait()</code>
 或<code class="calibre10">get()</code>
 成员函数的线程上。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\445.tif" src="Image00699.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">对于所给的<code class="calibre10">func</code>
 和<code class="calibre10">args</code>
 值，表达式<code class="calibre10">INVOKE(func,args)</code>
 是有效地。<code class="calibre10">Callable</code>
 和<code class="calibre10">Args</code>
 的所有成员都是<code class="calibre10">MoveConstructible</code>
 的。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">在内部存储中构造<code class="calibre10">func</code>
 和<code class="calibre10">args...</code>
 的副本（分别记为<code class="calibre10">fff</code>
 和<code class="calibre10">xyz...</code>
 ）。</p>
<p class="zw">如果<code class="calibre10">policy</code>
 是<code class="calibre10">std::launch::async</code>
 ，在其自己的线程上运行<code class="calibre10">INVOKE(fff,xyz...)</code>
 。所返回的<code class="calibre10">std::future</code>
 会在此线程完成的时候变为<strong class="calibre3">就绪</strong>
 ，并且会持有返回值或有函数调用所引发的异常。最后一个与<code class="calibre10">std::future</code>
 返回的异步状态同步的future对象的析构函数会一直被阻塞到future<strong class="calibre3">就绪</strong>
 。</p>
<p class="zw">如果<code class="calibre10">policy</code>
 是<code class="calibre10">std::launch::deferred</code>
 ，<code class="calibre10">fff</code>
 和<code class="calibre10">xyz...</code>
 会作为延迟函数调用被存储在所返回的<code class="calibre10">std::future</code>
 中。在共享相同关联状态的future上首次对<code class="calibre10">wait()</code>
 或<code class="calibre10">get()</code>
 成员函数的调用，会同步地在调用<code class="calibre10">wait()</code>
 或<code class="calibre10">get()</code>
 的线程上执行<code class="calibre10">INVOKE(fff,xyz...)</code>
 。</p>
<p class="zw">通过执行<code class="calibre10">INVOKE(fff,xyz...)</code>
 所返回的值或引发的异常，会从在该<code class="calibre10">std::future</code>
 上对<code class="calibre10">get()</code>
 的调用中返回。</p>
<p class="zw">如果<code class="calibre10">policy</code>
 是<code class="calibre10">std::launch::async | std::launch::deferred</code>
 或<code class="calibre10">policy</code>
 参数被省略，该行为如同<code class="calibre10">std::launch::async</code>
 或<code class="calibre10">std::launch::deferred</code>
 之一被指定。此实现会基于call-by-call理论选择具体行为，以便利用可用的硬件并发且没有超量的过度订阅。</p>
<p class="zw">在所有情况下，对<code class="calibre10">std::async</code>
 的调用立刻返回。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">函数调用的完成，发生于成功从在引用相同关联状态的<code class="calibre10">std::future</code>
 或<code class="calibre10">std::shared_future</code>
 实例上对<code class="calibre10">wait()</code>
 、<code class="calibre10">get()</code>
 、<code class="calibre10">wait_for()</code>
 或<code class="calibre10">wait_until()</code>
 的调用中返回之前，如<code class="calibre10">std::future</code>
 对象从<code class="calibre10">std::async</code>
 的调用中返回。在<code class="calibre10">std::launch::async</code>
 的<code class="calibre10">policy</code>
 情况下，函数调用所在的线程的完成同样发生于成功从这些调用返回之前。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果无法分配所需的内部存储，引发<code class="calibre10">std::bad_alloc</code>
 异常，否则当无法达成结果或在构造<code class="calibre10">fff</code>
 和<code class="calibre10">xyz...</code>
 时引发了任何的异常，就引发<code class="calibre10">std::future_error</code>
 异常。</p>
<h2 id="nav_point_231" class="calibre11">D.5　&lt;mutex&gt;头文件</h2>
<p class="zw">
<code class="calibre10">&lt;mutex&gt;</code>
 头文件提供了担保互斥的功能：互斥元类型、锁类型和函数，以及确保一项操作恰好被执行一次的机制。</p>
<p class="zw">
<strong class="calibre3">头文件内容</strong>
</p>
<p class="calibre16"><img alt="..\tu\446a.tif" src="Image00700.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\447a.tif" src="Image00701.gif" class="calibre15"/>
</p>
<h3 id="nav_point_232" class="calibre14">D.5.1　std::mutex类</h3>
<p class="zw">
<code class="calibre10">std::mutex</code>
 类为线程提供了基本的互斥与同步机制，可用来保护共享数据。在访问互斥元所保护的数据之前，该互斥元必须通过调用<code class="calibre10">lock()</code>
 或<code class="calibre10">try_lock()</code>
 来<strong class="calibre3">锁定</strong>
 。在同一时刻仅有一个线程可以持有这个锁，如果另一个线程也试图锁定此互斥元，就会失败或被适当地阻塞。一旦线程完成了访问共享数据，它必须接着调用<code class="calibre10">unlock()</code>
 来释放锁，并允许其他线程获得它。</p>
<p class="zw">
<code class="calibre10">std::mutex</code>
 满足<code class="calibre10">Lockable</code>
 的需求。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\447b.tif" src="Image00702.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::mutex默认构造函数</h4>
<p class="zw">构造<code class="calibre10">std::mutex</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\447c.tif" src="Image00703.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造<code class="calibre10">std::mutex</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">新构造的<code class="calibre10">std::mutex</code>
 对象初始是未锁定的。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::mutex析构函数</h4>
<p class="zw">销毁<code class="calibre10">std::mutex</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\448a.tif" src="Image00704.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 不得被锁定。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">销毁<code class="calibre10">*this</code>
 。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::mutex::lock成员函数</h4>
<p class="zw">为当前线程获取在<code class="calibre10">std::mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\448b.tif" src="Image00705.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程不得持有<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">阻塞当前线程，直到能够获得<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 被调用线程锁定。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">如果有错误发生，抛出<code class="calibre10">std::system_error</code>
 类型的异常。</p>
<h4 class="sigil_not_in_toc">std::mutex::try_lock成员函数</h4>
<p class="zw">尝试为当前线程获取<code class="calibre10">std::mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\448c.tif" src="Image00706.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程不得持有<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">尝试为调用线程在非阻塞的情况下获取<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果为调用线程获取到锁，返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">如果函数返回<code class="calibre10">true</code>
 ，则<code class="calibre10">*this</code>
 被调用线程锁定。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注意</strong>
 ：即使没有其他的线程持有<code class="calibre10">*this</code>
 上的锁，函数也可能获取锁失败（并返回<code class="calibre10">false</code>
 ）。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::mutex::unlock成员函数</h4>
<p class="zw">释放当前线程持有的<code class="calibre10">std::mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\449a.tif" src="Image00707.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程必须持有<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">释放当前线程持有的<code class="calibre10">*this</code>
 上的锁。如果有被阻塞的线程正等待获取<code class="calibre10">*this</code>
 上的锁，则对其解除阻塞。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<h3 id="nav_point_233" class="calibre14">D.5.2　std::recursive_mutex类</h3>
<p class="zw">
<code class="calibre10">std::recursive_mutex</code>
 类为线程提供了基本的互斥和同步机制，可用来保护共享数据。在访问互斥元所保护的数据之前，该互斥元必须通过调用<code class="calibre10">lock()</code>
 或<code class="calibre10">try_lock()</code>
 来<strong class="calibre3">锁定</strong>
 。在同一时刻仅有一个线程可以持有这个锁，如果另一个线程也试图锁定此<code class="calibre10">recursive_mutex</code>
 ，就会失败或被适当地阻塞。一旦线程完成了访问共享数据，它必须接着调用<code class="calibre10">unlock()</code>
 来释放锁，并允许其他线程获得它。</p>
<p class="zw">这里的互斥元是<strong class="calibre3">递归的（recursive）</strong>
 ，因此持有在特定<code class="calibre10">std::recursive_mutex</code>
 上锁的线程可以进一步调用<code class="calibre10">lock()</code>
 或<code class="calibre10">try_lock()</code>
 来增加锁定计数值。该互斥元不能被另外的线程锁定，直到获得锁的线程为每个对<code class="calibre10">lock()</code>
 和<code class="calibre10">try_lock()</code>
 的成功调用都调用过一次<code class="calibre10">unlock()</code>
 。</p>
<p class="zw">
<code class="calibre10">std::recursive_mutex</code>
 满足<code class="calibre10">Lockable</code>
 的需求。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\449b.tif" src="Image00708.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\450a.tif" src="Image00709.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::recursive_mutex默认构造函数</h4>
<p class="zw">构造<code class="calibre10">std::recursive_mutex</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\450b.tif" src="Image00710.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造<code class="calibre10">std::recursive_mutex</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">新构造的<code class="calibre10">std::recursive_mutex</code>
 对象初始是未锁定的。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">如果不能创建新的<code class="calibre10">std::recursive_mutex</code>
 实例，则抛出<code class="calibre10">std::system_error</code>
 类型的异常。</p>
<h4 class="sigil_not_in_toc">std::recursive_mutex析构函数</h4>
<p class="zw">销毁<code class="calibre10">std::recursive_mutex</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\450c.tif" src="Image00711.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 不得被锁定。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">销毁<code class="calibre10">*this</code>
 。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::recursive_mutex::lock成员函数</h4>
<p class="zw">为当前线程获取在<code class="calibre10">std::recursive_mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\450d.tif" src="Image00712.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">阻塞当前线程，直到能够获得<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 被调用线程锁定。如果调用线程已经持有<code class="calibre10">*this</code>
 上的锁，则锁计数值增加一。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">如果有错误发生，抛出<code class="calibre10">std::system_error</code>
 类型的异常。</p>
<h4 class="sigil_not_in_toc">std::recursive_mutex::try_lock成员函数</h4>
<p class="zw">尝试为当前线程获取<code class="calibre10">std::recursive_mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\450e.tif" src="Image00713.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">尝试为调用线程在非阻塞的情况下获取<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果为调用线程获取到锁，返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">如果函数返回<code class="calibre10">true</code>
 ，则已经为调用线程获取了新的<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注意</strong>
 ：如果调用线程已经持有了<code class="calibre10">*this</code>
 上的锁，函数返回<code class="calibre10">true</code>
 ，且调用线程持有的<code class="calibre10">*this</code>
 上锁的计数值增加1。如果当前线程并未持有<code class="calibre10">*this</code>
 上的锁，即使没有其他的线程持有<code class="calibre10">*this</code>
 上的锁，函数也可能获取锁失败（并返回<code class="calibre10">false</code>
 ）。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::recursive_mutex::unlock成员函数</h4>
<p class="zw">释放当前线程持有的<code class="calibre10">std::recursive_mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\451a.tif" src="Image00714.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程必须持有<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">释放当前线程持有的<code class="calibre10">*this</code>
 上的锁。如果这是调用线程所持有的最后一个*this上的锁，那么若有被阻塞的线程正等待获取<code class="calibre10">*this</code>
 上的锁，则对其解除阻塞。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">调用线程持有的*this上的锁的计数值减一。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<h3 id="nav_point_234" class="calibre14">D.5.3　std::timed_mutex类</h3>
<p class="zw">
<code class="calibre10">std::mutex</code>
 提供了基本的互斥与同步机制，在此之上，<code class="calibre10">std::timed_mutex</code>
 类为带超时的锁提供了支持。在访问由互斥元保护的数据之前，该互斥元必须通过调用<code class="calibre10">lock()</code>
 、<code class="calibre10">try_lock()</code>
 、<code class="calibre10">try_lock_for()</code>
 或<code class="calibre10">try_lock_until()</code>
 来进行锁定。如果已经有别的进程持有了锁，那么试图获取锁就会有下面几种情况：失败（<code class="calibre10">try_lock()</code>
 ），阻塞直到锁能够被获取（<code class="calibre10">lock()</code>
 ），阻塞直到锁能被获取或者尝试锁定超时（<code class="calibre10">try_lock_for()</code>
 或<code class="calibre10">try_lock_until()</code>
 ）。一旦获得了锁（不管是用哪个函数获取到的），在其他线程可以在互斥元上获得该锁之前，都必须调用<code class="calibre10">unlock()</code>
 来释放它。</p>
<p class="zw">
<code class="calibre10">std::timed_mutex</code>
 满足<code class="calibre10">TimedLockable</code>
 的需求。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\452a.tif" src="Image00715.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::timed_mutex默认构造函数</h4>
<p class="zw">构造<code class="calibre10">std::timed_mutex</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\452b.tif" src="Image00716.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造<code class="calibre10">std::timed_mutex</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">新构造的<code class="calibre10">std::timed_mutex</code>
 对象初始是未锁定的。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">如果不能创建新的<code class="calibre10">timed_mutex</code>
 实例，则抛出<code class="calibre10">std::system_error</code>
 类型的异常。</p>
<h4 class="sigil_not_in_toc">std::timed_mutex析构函数</h4>
<p class="zw">销毁<code class="calibre10">std::timed_mutex</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\452c.tif" src="Image00717.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 不得被锁定。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">销毁<code class="calibre10">*this</code>
 。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::timed_mutex::lock成员函数</h4>
<p class="zw">为当前线程获取在<code class="calibre10">std::timed_mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\452d.tif" src="Image00718.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程不得持有<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">阻塞当前线程，直到能够获得<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 被调用线程锁定。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">如果有错误发生，抛出<code class="calibre10">std::system_error</code>
 类型的异常。</p>
<h4 class="sigil_not_in_toc">std::timed_mutex::try_lock成员函数</h4>
<p class="zw">尝试为当前线程获取<code class="calibre10">std::mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\453a.tif" src="Image00719.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程不得持有<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">尝试为调用线程在非阻塞的情况下获取<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果为调用线程获取到锁，返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">如果函数返回<code class="calibre10">true</code>
 ，则<code class="calibre10">*this</code>
 被调用线程锁定。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注意</strong>
 ：即使没有其他的线程持有<code class="calibre10">*this</code>
 上的锁，函数也可能获取锁失败（并返回<code class="calibre10">false</code>
 ）。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::timed_mutex::try_lock_for成员函数</h4>
<p class="zw">尝试为当前线程获取<code class="calibre10">std::timed_mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\453b.tif" src="Image00720.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程不得持有<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">在<code class="calibre10">relative_time</code>
 指定的时间内，尝试为调用线程获取<code class="calibre10">*this</code>
 上的锁。如果<code class="calibre10">relative_time.count()</code>
 为零或负数，此调用会立即返回，如同调用了<code class="calibre10">try_lock()</code>
 一样。否则，该调用会一直阻塞，直到获取了锁或者经过了<code class="calibre10">relative_time</code>
 所指定的时间段。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果为调用线程获得了锁，返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">如果函数返回<code class="calibre10">true</code>
 ，则<code class="calibre10">*this</code>
 被调用线程锁定。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注意</strong>
 ：即使没有其他的线程持有<code class="calibre10">*this</code>
 上的锁，函数也可能获取锁失败（并返回<code class="calibre10">false</code>
 ）。线程可能会比指定的时间段阻塞更长的时间。如果可能的话，所经过的时间是有可靠时钟来决定的。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::timed_mutex::try_lock_until成员函数</h4>
<p class="zw">尝试为当前线程获取<code class="calibre10">std::timed_mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\454a.tif" src="Image00721.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程不得持有<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">在<code class="calibre10">absolute_time</code>
 指定的时间之前，尝试为调用线程获取<code class="calibre10">*this</code>
 上的锁。如果入口处的<code class="calibre10">absolute_time&lt;=Clock::now()</code>
 ，此调用会立即返回，如同调用了<code class="calibre10">try_lock()</code>
 一样。否则，该调用会一直阻塞，直到获取了锁或者<code class="calibre10">Clock::now()</code>
 返回等于或晚于<code class="calibre10">absolute_time</code>
 的时间。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果为调用线程获得了锁，返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">如果函数返回<code class="calibre10">true</code>
 ，则<code class="calibre10">*this</code>
 被调用线程锁定。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注意</strong>
 ：即使没有其他的线程持有<code class="calibre10">*this</code>
 上的锁，函数也可能获取锁失败（并返回<code class="calibre10">false</code>
 ）。调用线程将会被阻塞多长时间是没有保证的，除非函数返回<code class="calibre10">false</code>
 然后<code class="calibre10">Clock::now()</code>
 返回等于或晚于<code class="calibre10">absolute_time</code>
 的时间，在这时线程才能解除阻塞。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::timed_mutex::unlock成员函数</h4>
<p class="zw">释放当前线程持有的<code class="calibre10">std::timed_mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\454b.tif" src="Image00722.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程必须持有<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">释放当前线程持有的<code class="calibre10">*this</code>
 上的锁。如果有被阻塞的线程正等待获取<code class="calibre10">*this</code>
 上的锁，则对其解除阻塞。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 不再被调用线程锁定。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<h3 id="nav_point_235" class="calibre14">D.5.4　std::recursive_timed_mutex类</h3>
<p class="zw">
<code class="calibre10">std::recursive_mutex</code>
 提供了基本的互斥与同步机制，在此之上，<code class="calibre10">std::recursive_timed_mutex</code>
 类为带超时的锁提供了支持。在访问由互斥元保护的数据之前，该互斥元必须通过调用<code class="calibre10">lock()</code>
 、<code class="calibre10">try_lock()</code>
 、<code class="calibre10">try_lock_for()</code>
 或<code class="calibre10">try_lock_until()</code>
 来进行锁定。如果已经有别的进程持有了锁，那么试图获取锁就会有下面几种情况：失败（<code class="calibre10">try_lock()</code>
 ），阻塞直到锁能够被获取（<code class="calibre10">lock()</code>
 ），阻塞直到锁能被获取或者尝试锁定超时（<code class="calibre10">try_lock_for()</code>
 或<code class="calibre10">try_lock_until()</code>
 ）。一旦获得了锁（不管是用哪个函数获取到的），在其他线程可以在互斥元上获得该锁之前，都必须调用<code class="calibre10">unlock()</code>
 来释放它。</p>
<p class="zw">这里的互斥元是<strong class="calibre3">递归的</strong>
 ，因此持有在特定<code class="calibre10">std::recursive_timed_mutex</code>
 上锁的线程可以通过任意的锁函数来叠加地锁定该实例。在其他线程能够获取该实例的锁之前，所有现存的锁都必须通过调用相应的<code class="calibre10">unlock()</code>
 进行释放。</p>
<p class="zw">
<code class="calibre10">std::recursive_timed_mutex</code>
 满足<code class="calibre10">TimedLockable</code>
 的需求。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\455.tif" src="Image00723.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::recursive_timed_mutex默认构造函数</h4>
<p class="zw">构造<code class="calibre10">std::recursive_timed_mutex</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\456a.tif" src="Image00724.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造<code class="calibre10">std::recursive_timed_mutex</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">新构造的<code class="calibre10">std::recursive_timed_mutex</code>
 对象初始是未锁定的。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">如果不能创建新的<code class="calibre10">recursive_timed_mutex</code>
 实例，则抛出<code class="calibre10">std::system_error</code>
 类型的异常。</p>
<h4 class="sigil_not_in_toc">std::recursive_timed_mutex析构函数</h4>
<p class="zw">销毁<code class="calibre10">std::recursive_timed_mutex</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\456b.tif" src="Image00725.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 不得被锁定。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">销毁<code class="calibre10">*this</code>
 。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::recursive_timed_mutex::lock成员函数</h4>
<p class="zw">为当前线程获取在<code class="calibre10">std::recursive_timed_mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\456d.tif" src="Image00726.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程不得持有<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">阻塞当前线程，直到能够获得<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 被调用线程锁定。如果调用线程已经持有<code class="calibre10">*this</code>
 上的锁，则锁计数值增加一。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">如果有错误发生，抛出<code class="calibre10">std::system_error</code>
 类型的异常。</p>
<h4 class="sigil_not_in_toc">std::recursive_timed_mutex::try_lock成员函数</h4>
<p class="zw">尝试为当前线程获取<code class="calibre10">std::mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\456c.tif" src="Image00727.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程不得持有<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">尝试为调用线程在非阻塞的情况下获取<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果为调用线程获取到锁，返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">如果函数返回<code class="calibre10">true</code>
 ，则<code class="calibre10">*this</code>
 被调用线程锁定。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注意</strong>
 ：如果调用线程已经持有了<code class="calibre10">*this</code>
 上的锁，函数返回<code class="calibre10">true</code>
 ，且调用线程持有的<code class="calibre10">*this</code>
 上锁的计数值增加一。如果当前线程并未持有<code class="calibre10">*this</code>
 上的锁，即使没有其他的线程持有<code class="calibre10">*this</code>
 上的锁，函数也可能获取锁失败（并返回<code class="calibre10">false</code>
 ）。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::recursive_timed_mutex::try_lock_for成员函数</h4>
<p class="zw">尝试为当前线程获取<code class="calibre10">std::timed_mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\457a.tif" src="Image00728.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程不得持有<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">在<code class="calibre10">relative_time</code>
 指定的时间内，尝试为调用线程获取<code class="calibre10">*this</code>
 上的锁。如果<code class="calibre10">relative_time.count()</code>
 为零或负数，此调用会立即返回，如同调用了<code class="calibre10">try_lock()</code>
 一样。否则，该调用会一直阻塞，直到获取了锁或者经过了<code class="calibre10">relative_time</code>
 所指定的时间段。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果为调用线程获得了锁，返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">如果函数返回<code class="calibre10">true</code>
 ，则<code class="calibre10">*this</code>
 被调用线程锁定。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注意</strong>
 ：即使没有其他的线程持有<code class="calibre10">*this</code>
 上的锁，函数也可能获取锁失败（并返回<code class="calibre10">false</code>
 ）。线程可能会比指定的时间段阻塞更长的时间。如果可能的话，所经过的时间是有可靠时钟来决定的。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::recursive_timed_mutex::try_lock_until成员函数</h4>
<p class="zw">尝试为当前线程获取<code class="calibre10">std::timed_mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\458a.tif" src="Image00729.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程不得持有<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">在<code class="calibre10">absolute_time</code>
 指定的时间之前，尝试为调用线程获取<code class="calibre10">*this</code>
 上的锁。如果入口处的<code class="calibre10">absolute_time&lt;=Clock::now()</code>
 ，此调用会立即返回，如同调用了<code class="calibre10">try_lock()</code>
 一样。否则，该调用会一直阻塞，直到获取了锁或者<code class="calibre10">Clock::now()</code>
 返回等于或晚于<code class="calibre10">absolute_time</code>
 的时间。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果为调用线程获得了锁，返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">如果函数返回<code class="calibre10">true</code>
 ，则<code class="calibre10">*this</code>
 被调用线程锁定。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注意</strong>
 ：即使没有其他的线程持有<code class="calibre10">*this</code>
 上的锁，函数也可能获取锁失败（并返回<code class="calibre10">false</code>
 ）。调用线程将会被阻塞多长时间是没有保证的，除非函数返回<code class="calibre10">false</code>
 然后<code class="calibre10">Clock::now()</code>
 返回等于或晚于<code class="calibre10">absolute_time</code>
 的时间，在这时线程才能解除阻塞。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::recursive_timed_mutex::unlock成员函数</h4>
<p class="zw">释放当前线程持有的<code class="calibre10">std::timed_mutex</code>
 对象上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\458b.tif" src="Image00730.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程必须持有<code class="calibre10">*this</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">释放当前线程持有的<code class="calibre10">*this</code>
 上的锁。如果有被阻塞的线程正等待获取<code class="calibre10">*this</code>
 上的锁，则对其解除阻塞。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 不再被调用线程锁定。</p>
<p class="zw">
<strong class="calibre3">抛出</strong>
</p>
<p class="zw">无。</p>
<h3 id="nav_point_236" class="calibre14">D.5.5　std::lock_guard类模板</h3>
<p class="zw">
<code class="calibre10">std::lock_guard</code>
 类模板提供了基本的锁所有权包装。将要被锁定的互斥元类型由模板参数<code class="calibre10">Mutex</code>
 指定，且必须满足<code class="calibre10">Lockable</code>
 需求。指定的互斥元被锁定于构造函数中，并被解锁于析构函数中。这就提供了一个简单的为一段代码块锁定一个互斥元的方法，并且确保当离开代码块的时候互斥元被解锁，无论是一次性执行到底，还是使用诸如<code class="calibre10">break</code>
 或<code class="calibre10">return</code>
 这样的控制流语句，或是引发异常来达成的情况。</p>
<p class="zw">
<code class="calibre10">std::lock_guard</code>
 的实例不是<code class="calibre10">MoveConstructible</code>
 、<code class="calibre10">CopyConsstructible</code>
 或<code class="calibre10">CopyAssignable</code>
 的。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\459a.tif" src="Image00731.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::lock_guard锁定构造函数</h4>
<p class="zw">构造锁定所给互斥元的<code class="calibre10">std::lock_guard</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\459b.tif" src="Image00732.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造引用所给互斥元的<code class="calibre10">std::lock_guard</code>
 实例。调用<code class="calibre10">m.lock()</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">由<code class="calibre10">m.lock()</code>
 引发的任何异常。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 拥有在<code class="calibre10">m</code>
 上的锁。</p>
<h4 class="sigil_not_in_toc">std::lock_guard采纳锁定构造函数</h4>
<p class="zw">构造拥有所给互斥元上锁的<code class="calibre10">std::lock_guard</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\459d.tif" src="Image00733.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程必须拥有在<code class="calibre10">m</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造引用所给互斥元的<code class="calibre10">std::lock_guard</code>
 实例，并获取调用线程所持有的<code class="calibre10">m</code>
 上的锁的所有权。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">*this</code>
 拥有调用线程持有的在<code class="calibre10">m</code>
 上的锁。</p>
<h4 class="sigil_not_in_toc">std::lock_guard析构函数</h4>
<p class="zw">销毁<code class="calibre10">std::lock_guard</code>
 实例并解锁相应的互斥元。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\460a.tif" src="Image00734.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">为<code class="calibre10">*this</code>
 构造时所提供的互斥元实例<code class="calibre10">m</code>
 调用<code class="calibre10">m.unlock()</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h3 id="nav_point_237" class="calibre14">D.5.6　std::unique_lock类模板</h3>
<p class="zw">
<code class="calibre10">std::unique_lock</code>
 类模板提供了比<code class="calibre10">std::lock_guard</code>
 更通用的锁所有权包装。将要被锁定的互斥元类型由模板参数<code class="calibre10">Mutex</code>
 指定，且必须满足<code class="calibre10">BasicLockable</code>
 需求。一般来说，指定的互斥元在构造函数中被锁定并在析构函数中被解锁，尽管可以提供额外的构造函数和成员函数来允许其他的可能性。这就提供了一个简单的为一段代码块锁定一个互斥元的方法，并且确保当离开代码块的时候互斥元被解锁，无论是运行到底，还是使用诸如<code class="calibre10">break</code>
 或<code class="calibre10">return</code>
 这样的控制流语句，或是引发异常来达成的。<code class="calibre10">std::condition_variable</code>
 的等待函数要求一个<code class="calibre10">std::unique_lock&lt;std::mutex&gt;</code>
 的实例，并且<code class="calibre10">std::unique_lock</code>
 的所有实例化都适合与<code class="calibre10">std::condition_variable_any</code>
 等待函数的<code class="calibre10">Lockable</code>
 参数一起使用。</p>
<p class="zw">如果所给的<code class="calibre10">Mutex</code>
 类型满足<code class="calibre10">Lockable</code>
 需求，那么<code class="calibre10">std::unique_lock&lt;Mutex&gt;</code>
 也满足<code class="calibre10">Lockable</code>
 需求。如果在此之外，所给的<code class="calibre10">Mutex</code>
 类型满足<code class="calibre10">TimedLockable</code>
 需求，那么<code class="calibre10">std::unique_lock&lt;Mutex&gt;</code>
 也满足<code class="calibre10">TimedLockable</code>
 需求。</p>
<p class="zw">
<code class="calibre10">std::unique_lock</code>
 的实例是<code class="calibre10">MoveConstructible</code>
 和<code class="calibre10">MoveAssignable</code>
 的，但不是<code class="calibre10">CopyConsstructible</code>
 或<code class="calibre10">CopyAssignable</code>
 的。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\460b.tif" src="Image00735.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\461a.tif" src="Image00736.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::unique_lock默认构造函数</h4>
<p class="zw">构造没有相关联互斥元的<code class="calibre10">std::unique_lock</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\461b.tif" src="Image00737.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造没有相关联互斥元的<code class="calibre10">std::unique_lock</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="calibre16"><img alt="..\tu\461c.tif" src="Image00738.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::unique_lock锁定构造函数</h4>
<p class="zw">构造锁定所给互斥元的<code class="calibre10">std::unique_lock</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\461d.tif" src="Image00739.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造引用所给互斥元的<code class="calibre10">std::unique_lock</code>
 实例。调用<code class="calibre10">m.lock()</code>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="calibre16"><img alt="..\tu\462a.tif" src="Image00740.gif" class="calibre15"/>
</p>
<p class="calibre2">
<strong class="calibre3">std::unique_lock采纳锁定构造函数</strong>
</p>
<p class="zw">构造拥有所给互斥元上锁的<code class="calibre10">std::unique_lock实</code>
 例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\462B.tif" src="Image00741.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">调用线程必须拥有在<code class="calibre10">m</code>
 上的锁。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造引用所给互斥元的<code class="calibre10">std::unique_lock</code>
 实例，并获取调用线程所持有的<code class="calibre10">m</code>
 上的锁的所有权。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="calibre16"><img alt="..\tu\462C.tif" src="Image00742.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::unique_lock延迟锁定构造函数</h4>
<p class="zw">构造不拥有所给互斥元上锁的<code class="calibre10">std::unique_lock实</code>
 例。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\462D.tif" src="Image00743.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造引用所给互斥元的<code class="calibre10">std::unique_lock</code>
 实例。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="calibre16"><img alt="..\tu\462E.tif" src="Image00744.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::unique_lock尝试锁定构造函数</h4>
<p class="zw">构造与所给互斥元相关联的<code class="calibre10">std::unique_lock</code>
 实例，并尝试获取该互斥元上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\462F.tif" src="Image00745.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">用来实例化<code class="calibre10">std::unique_lock</code>
 的<code class="calibre10">Mutex</code>
 类型必须满足<code class="calibre10">Lockable</code>
 需求。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造引用所给互斥元的<code class="calibre10">std::unique_lock</code>
 实例。调用<code class="calibre10">m.try_lock()</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;owns_lock()</code>
 返回调用<code class="calibre10">m.try_lock()</code>
 的结果，<code class="calibre10">this-&gt;mutex()==&amp;m</code>
 。</p>
<h4 class="sigil_not_in_toc">std::unique_lock带有超时时间段的尝试锁定构造函数</h4>
<p class="zw">构造与所给互斥元相关联的<code class="calibre10">std::unique_lock</code>
 实例，并尝试获取该互斥元上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\463a.tif" src="Image00746.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">用来实例化<code class="calibre10">std::unique_lock</code>
 的<code class="calibre10">Mutex</code>
 类型必须满足<code class="calibre10">TimedLockable</code>
 需求。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造引用所给互斥元的<code class="calibre10">std::unique_lock</code>
 实例。调用<code class="calibre10">m.try_lock_for(relative_time)</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;owns_lock()</code>
 返回调用<code class="calibre10">m.try_lock_for()</code>
 的结果，<code class="calibre10">this-&gt;mutex()==&amp;m</code>
 。</p>
<h4 class="sigil_not_in_toc">std::unique_lock带有超时时间点的尝试锁定构造函数</h4>
<p class="zw">构造与所给互斥元相关联的<code class="calibre10">std::unique_lock</code>
 实例，并尝试获取该互斥元上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\463B.tif" src="Image00747.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">用来实例化<code class="calibre10">std::unique_lock</code>
 的<code class="calibre10">Mutex</code>
 类型必须满足<code class="calibre10">TimedLockable</code>
 需求。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造引用所给互斥元的<code class="calibre10">std::unique_lock</code>
 实例。调用<code class="calibre10">m.try_lock_until(absolute_time)</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;owns_lock()</code>
 返回调用<code class="calibre10">m.try_lock_until()</code>
 的结果，<code class="calibre10">this-&gt;mutex()==&amp;m</code>
 。</p>
<h4 class="sigil_not_in_toc">std::unique_lock移动构造函数</h4>
<p class="zw">将锁的所有权从一个<code class="calibre10">std::unique_lock</code>
 对象转移到新创建的<code class="calibre10">std::unique_lock</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\464a.tif" src="Image00748.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造<code class="calibre10">std::unique_lock</code>
 实例。如果<code class="calibre10">other</code>
 在调用构造函数前拥有互斥元上的锁，该锁现在由新建立的<code class="calibre10">std::unique_lock</code>
 对象所有。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">对于新构造的<code class="calibre10">std::unique_lock</code>
 对象<code class="calibre10">x</code>
 ，<code class="calibre10">x.mutex()</code>
 等于调用该构造函数前的<code class="calibre10">other.mutex()</code>
 值，且<code class="calibre10">x.owns_lock()</code>
 等于调用该构造函数前<code class="calibre10">other.owns_lock()</code>
 的值。<code class="calibre10">other.mutex()==NULL</code>
 ，<code class="calibre10">other.owns_lock()==false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 <code class="calibre10">std::unique_lock</code>
 对象<strong class="calibre3">不是</strong>
 <code class="calibre10">CopyConstructible</code>
 的，所有没有拷贝构造函数，只有这个移动构造函数。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::unique_lock移动赋值运算符</h4>
<p class="zw">将锁的所有权从一个<code class="calibre10">std::unique_lock</code>
 对象转移到另一个<code class="calibre10">std::unique_lock</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\464B.tif" src="Image00749.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果<code class="calibre10">this-&gt;owns_lock()</code>
 在此调用前返回<code class="calibre10">true</code>
 ，调用<code class="calibre10">this-&gt;unlock</code>
 。如果<code class="calibre10">other</code>
 在此赋值之前拥有在互斥元上的锁，该锁现在由<code class="calibre10">*this</code>
 所有。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;mutex()</code>
 等于调用此赋值前的<code class="calibre10">other.mutex()</code>
 值，且<code class="calibre10">this-&gt;owns_lock()</code>
 等于调用此赋值前<code class="calibre10">other.owns_lock()</code>
 的值。<code class="calibre10">other.mutex()==NULL</code>
 ，<code class="calibre10">other.owns_lock()==false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 <code class="calibre10">std::unique_lock</code>
 对象<strong class="calibre3">不是</strong>
 <code class="calibre10">CopyConstructible</code>
 的，所有没有拷贝赋值运算符，只有这个移动赋值运算符。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::unique_lock析构函数</h4>
<p class="zw">销毁<code class="calibre10">std::unique_lock</code>
 实例并解锁相应的互斥元，如果它由被销毁的实例所持有。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\465a.tif" src="Image00750.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果<code class="calibre10">this-&gt;owns_lock()</code>
 返回<code class="calibre10">true</code>
 ，调用<code class="calibre10">this-&gt;mutex()-&gt;unlock()</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::unique_lock::swap成员函数</h4>
<p class="zw">在两个<code class="calibre10">std::unique_lock</code>
 对象之间交换它们相关联的<code class="calibre10">unique_lock</code>
 的所有权。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\465B.tif" src="Image00751.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果<code class="calibre10">other</code>
 在调用之前拥有互斥元上的锁，该锁现在由<code class="calibre10">*this</code>
 所有。</p>
<p class="zw">如果<code class="calibre10">*this</code>
 在调用之前拥有互斥元上的锁，该锁现在由<code class="calibre10">other</code>
 所有。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;mutex()</code>
 与调用前<code class="calibre10">other.mutex()</code>
 的值相等。<code class="calibre10">other.mutex()</code>
 与调用前<code class="calibre10">this-&gt;mutex()</code>
 的值相等。<code class="calibre10">this-&gt;owns_lock()</code>
 与调用前<code class="calibre10">other.owns_lock()</code>
 的值相等。<code class="calibre10">other.owns_lock()</code>
 与调用前<code class="calibre10">this-&gt;owns_lock()</code>
 的值相等。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">swap非成员函数</h4>
<p class="zw">在两个<code class="calibre10">std::unique_lock</code>
 对象之间交换它们相关联的<code class="calibre10">unique_lock</code>
 的所有权。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\465C.tif" src="Image00752.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\465D.tif" src="Image00753.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::unique_lock::lock成员函数</h4>
<p class="zw">获取与<code class="calibre10">*this</code>
 相关联的互斥元上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\465E.tif" src="Image00754.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;mutex()!=NULL</code>
 ，<code class="calibre10">this-&gt;owns_lock()==false</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">调用<code class="calibre10">this-&gt;mutex()-&gt;lock()</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">任何由<code class="calibre10">this-&gt;mutex()-&gt;lock()</code>
 引发的异常。如果<code class="calibre10">this-&gt;mutex()==NULL</code>
 ，引发带有<code class="calibre10">std::errc::operation_not_permitted</code>
 错误码的<code class="calibre10">std::system_error</code>
 异常。如果在条目上<code class="calibre10">this-&gt;owns_lock()==true</code>
 ，引发带有<code class="calibre10">std::errc::resource_deadlock_would_occur</code>
 错误码的<code class="calibre10">std::system_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;owns_lock()==true</code>
 。</p>
<h4 class="sigil_not_in_toc">std::unique_lock::try_lock成员函数</h4>
<p class="zw">试图获取与<code class="calibre10">*this</code>
 相关联的互斥元上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\466B.tif" src="Image00755.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">用来实例化<code class="calibre10">std::unique_lock</code>
 的<code class="calibre10">Mutex</code>
 类型必须满足<code class="calibre10">Lockable</code>
 需求。<code class="calibre10">this-&gt;mutex()!=NULL</code>
 ，<code class="calibre10">this-&gt;owns_lock()==false</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">调用<code class="calibre10">this-&gt;mutex()-&gt;try_lock()</code>
 。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果对<code class="calibre10">this_mutex()-&gt;try_lock()</code>
 的调用返回<code class="calibre10">true</code>
 ，则返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">任何由<code class="calibre10">this-&gt;mutex()-&gt;try_lock()</code>
 引发的异常。如果<code class="calibre10">this-&gt;mutex()==NULL</code>
 ，引发带有<code class="calibre10">std::errc::operation_not_permitted</code>
 错误码的<code class="calibre10">std::system_error</code>
 异常。如果在条目上<code class="calibre10">this-&gt;owns_lock()==true</code>
 ，引发带有<code class="calibre10">std::errc::resource_deadlock_would_occur</code>
 错误码的<code class="calibre10">std::system_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">如果函数返回<code class="calibre10">true</code>
 ，<code class="calibre10">this-&gt;owns_lock()==true</code>
 ，否则<code class="calibre10">this-&gt;owns_lock()==false</code>
 。</p>
<h4 class="sigil_not_in_toc">std::unique_lock::unlock成员函数</h4>
<p class="zw">释放与<code class="calibre10">*this</code>
 相关联的互斥元上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\466C.tif" src="Image00756.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;mutex()!=NULL</code>
 ，<code class="calibre10">this-&gt;owns_lock()==true</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">调用<code class="calibre10">this-&gt;mutex()-&gt;unlock()</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">任何由<code class="calibre10">this-&gt;mutex()-&gt;unlock()</code>
 引发的异常。如果在条目上<code class="calibre10">this-&gt;owns_lock()==false</code>
 ，引发带有<code class="calibre10">std::errc::operation_not_permitted</code>
 错误码的<code class="calibre10">std::system_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;owns_lock()==false</code>
 。</p>
<h4 class="sigil_not_in_toc">std::unique_lock::try_lock_for成员函数</h4>
<p class="zw">在指定时间内试图获取与<code class="calibre10">*this</code>
 相关联的互斥元上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\467B.tif" src="Image00757.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">用来实例化<code class="calibre10">std::unique_lock</code>
 的<code class="calibre10">Mutex</code>
 类型必须满足<code class="calibre10">Lockable</code>
 需求。<code class="calibre10">this-&gt;mutex()!=NULL</code>
 ，<code class="calibre10">this-&gt;owns_lock()==false</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">调用<code class="calibre10">this-&gt;mutex()-&gt;try_lock_for(relative_time)</code>
 。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果对<code class="calibre10">this_mutex()-&gt;try_lock_for()</code>
 的调用返回<code class="calibre10">true</code>
 ，则返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">任何由<code class="calibre10">this-&gt;mutex()-&gt;try_lock_for()</code>
 引发的异常。如果<code class="calibre10">this-&gt;mutex()==NULL</code>
 ，引发带有<code class="calibre10">std::errc::operation_not_permitted</code>
 错误码的<code class="calibre10">std::system_error</code>
 异常。如果在条目上<code class="calibre10">this-&gt;owns_lock()==true</code>
 ，引发带有<code class="calibre10">std::errc::resource_deadlock_would_occur</code>
 错误码的<code class="calibre10">std::system_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">如果函数返回<code class="calibre10">true</code>
 ，<code class="calibre10">this-&gt;owns_lock()==true</code>
 ，否则<code class="calibre10">this-&gt;owns_lock()==false</code>
 。</p>
<h4 class="sigil_not_in_toc">std::unique_lock::try_lock_until成员函数</h4>
<p class="zw">在指定时间内试图获取与<code class="calibre10">*this</code>
 相关联的互斥元上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\467C.tif" src="Image00758.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">用来实例化<code class="calibre10">std::unique_lock</code>
 的<code class="calibre10">Mutex</code>
 类型必须满足<code class="calibre10">Lockable</code>
 需求。<code class="calibre10">this-&gt;mutex()!=NULL</code>
 ，<code class="calibre10">this-&gt;owns_lock()==false</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">调用<code class="calibre10">this-&gt;mutex()-&gt;try_lock_until(absolute_time)</code>
 。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果对<code class="calibre10">this_mutex()-&gt;try_lock_until()</code>
 的调用返回<code class="calibre10">true</code>
 ，则返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">任何由<code class="calibre10">this-&gt;mutex()-&gt;try_lock_until()</code>
 引发的异常。如果<code class="calibre10">this-&gt;mutex()==NULL</code>
 ，引发带有<code class="calibre10">std::errc::operation_not_permitted</code>
 错误码的<code class="calibre10">std::system_error</code>
 异常。如果在条目上<code class="calibre10">this-&gt;owns_lock()==true</code>
 ，引发带有<code class="calibre10">std::errc::resource_deadlock_would_occur</code>
 错误码的<code class="calibre10">std::system_error</code>
 异常。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">如果函数返回<code class="calibre10">true</code>
 ，<code class="calibre10">this-&gt;owns_lock()==true</code>
 ，否则<code class="calibre10">this-&gt;owns_lock()==false</code>
 。</p>
<h4 class="sigil_not_in_toc">std::unique_lock::operator bool成员函数</h4>
<p class="zw">检查<code class="calibre10">*this</code>
 是否拥有互斥元上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\468a.tif" src="Image00759.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;owns_lock()</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 这是运算符的<code class="calibre10">explicit</code>
 版本，因此它仅仅在结果被用作布尔量且不会被视为整型值<code class="calibre10">0</code>
 或<code class="calibre10">1</code>
 的上下文中才会被隐式地调用。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::unique_lock::owns_lock成员函数</h4>
<p class="zw">检查<code class="calibre10">*this</code>
 是否拥有互斥元上的锁。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\468C.tif" src="Image00760.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果<code class="calibre10">*this</code>
 拥有互斥元上的锁，返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::unique_lock::mutex成员函数</h4>
<p class="zw">返回与<code class="calibre10">*this</code>
 相关联的互斥元，如果有的话。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\468E.tif" src="Image00761.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果<code class="calibre10">*this</code>
 有相关联的互斥元，返回指向它的指针，否则返回<code class="calibre10">NULL</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::unique_lock::release成员函数</h4>
<p class="zw">返回与<code class="calibre10">*this</code>
 相关联的互斥元，如果有的话，并且释放该关联。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\468f.tif" src="Image00762.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">断开互斥元与<code class="calibre10">*this</code>
 的关联，并不解锁持有的任何锁。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果<code class="calibre10">*this</code>
 有相关联的互斥元，返回指向它的指针，否则返回<code class="calibre10">NULL</code>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;mutex()==NULL</code>
 ，<code class="calibre10">this-&gt;owns_lock()==false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 如果<code class="calibre10">this-&gt;owns_lock()</code>
 在调用前返回<code class="calibre10">true</code>
 ，调用者现在对解锁该互斥元负责。</p>
</blockquote>
<h3 id="sigil_toc_id_1" class="calibre14">D.5.7　std::lock函数模板</h3>
<p class="zw">
<code class="calibre10">std::lock</code>
 函数模板提供了同时锁定多于一个互斥元的方法，避免了在不一致的锁顺序下的死锁结果风险。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\469B.tif" src="Image00763.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">所给的可锁定对象<code class="calibre10">LockableType1</code>
 、<code class="calibre10">LockableType2</code>
 等类型必须满足<code class="calibre10">Lockable</code>
 需求。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">在每个所给的可锁定对象<code class="calibre10">m1</code>
 、<code class="calibre10">m2</code>
 等上获取锁，通过未指定的顺序来调用那些类型的<code class="calibre10">lock()</code>
 、<code class="calibre10">try_lock()</code>
 和<code class="calibre10">unlock()</code>
 来避免死锁。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">当前线程拥有每个所给顶的可锁定对象上的锁。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">调用<code class="calibre10">lock()</code>
 、<code class="calibre10">try_lock()</code>
 和<code class="calibre10">unlock()</code>
 时引发的任何异常。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 如果异常从<code class="calibre10">std::lock</code>
 的调用中传播出来，那么在本函数中所有已经通过调用<code class="calibre10">lock()</code>
 或<code class="calibre10">try_lock()</code>
 获取锁的对象<code class="calibre10">m1</code>
 、<code class="calibre10">m2</code>
 等，都必须为其调用<code class="calibre10">unlock()</code>
 。</p>
</blockquote>
<h3 id="sigil_toc_id_2" class="calibre14">D.5.8　std::try_lock函数模板</h3>
<p class="zw">
<code class="calibre10">std::try_lock</code>
 函数模板允许你尝试着一次性锁定一系列的可锁定对象，因此它们可能全都被锁定也可能都没有被锁定。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\469C.tif" src="Image00764.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">所给的可锁定对象<code class="calibre10">LockableType1</code>
 、<code class="calibre10">LockableType2</code>
 等类型必须满足<code class="calibre10">Lockable</code>
 需求。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">尝试在每个所给的可锁定对象<code class="calibre10">m1</code>
 、<code class="calibre10">m2</code>
 等上获取锁，通过逐个轮流调用<code class="calibre10">try_lock()</code>
 。如果一个对<code class="calibre10">try_lock()</code>
 的调用返回<code class="calibre10">false</code>
 或引发异常，已经获取的锁通过在对应的可锁定对象上调用<code class="calibre10">unlock()</code>
 来释放。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果所有的锁都获取到（每次调用<code class="calibre10">try_lock()</code>
 都返回<code class="calibre10">true</code>
 ），返回<code class="calibre10">-1</code>
 ，否则返回调用<code class="calibre10">try_lock()</code>
 返回<code class="calibre10">false</code>
 的对象的基于零的索引。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">如果函数返回<code class="calibre10">-1</code>
 ，当前线程拥有每个所提供的可锁定对象上的锁。否则，该调用所有已获取的锁都已被释放。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">调用<code class="calibre10">try_lock()</code>
 时引发的任何异常。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 如果异常从<code class="calibre10">std::try_lock</code>
 的调用中传播出来，那么在本函数中所有已经通过调用<code class="calibre10">try_lock()</code>
 获取锁的对象<code class="calibre10">m1</code>
 、<code class="calibre10">m2</code>
 等，都必须为其调用<code class="calibre10">unlock()</code>
 。</p>
</blockquote>
<h3 id="sigil_toc_id_3" class="calibre14">D.5.9　std::once_flag类</h3>
<p class="zw">
<code class="calibre10">std::once_fla</code>
 g的实例与<code class="calibre10">std::call_once</code>
 一起使用，以确保特定的函数被严格地调用一次，即便有多个线程同时执行调用。</p>
<p class="zw">
<code class="calibre10">std::once_flag</code>
 的实例不是<code class="calibre10">CopyConstructible</code>
 、<code class="calibre10">CopyAssignable</code>
 、<code class="calibre10">MoveConstructible</code>
 和<code class="calibre10">MoveAssignable</code>
 的。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\470a.tif" src="Image00765.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::once_flag默认构造函数</h4>
<p class="zw">
<code class="calibre10">std::once_flag</code>
 默认构造函数构造新的<code class="calibre10">std::once_flag</code>
 实例，其状态指示了所关联的函数尚未被调用。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\470B.tif" src="Image00766.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造新的<code class="calibre10">std::once_flag</code>
 实例，其状态指示了所关联的函数尚未被调用。因为这是一个<code class="calibre10">constexpr</code>
 构造函数，带有静态存储时间段的实例作为静态初始化阶段的一部分被构造，这避免了竞争条件和初始化顺序问题。</p>
<h3 id="sigil_toc_id_4" class="calibre14">D.5.10　std::call_once函数模板</h3>
<p class="zw">
<code class="calibre10">std::call_once</code>
 与<code class="calibre10">std::once_flag</code>
 一起使用，以确保特定的函数被严格地调用一次，即便有多个线程同时执行调用。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\471a.tif" src="Image00767.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">对给定的<code class="calibre10">func</code>
 和<code class="calibre10">args</code>
 值，表达式<code class="calibre10">INVOKE(func,args)</code>
 有效。<code class="calibre10">Callable</code>
 和<code class="calibre10">Args</code>
 的每个成员都是<code class="calibre10">MoveConstructible</code>
 的。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">在同一个<code class="calibre10">std::once_flag</code>
 对象上的<code class="calibre10">std::call_once</code>
 调用被序列化。如果在同一个<code class="calibre10">std::once_flag</code>
 对象上之前没有过有效的<code class="calibre10">std::call_once</code>
 调用，参数<code class="calibre10">func</code>
 （或其副本）如同通过<code class="calibre10">INVOKE(func,args)</code>
 那样被调用，并且<code class="calibre10">std::call_once</code>
 的调用有效当且仅当<code class="calibre10">func</code>
 的调用返回而无异常。如果在同一个<code class="calibre10">std::once_flag</code>
 对象上之前有过有效的<code class="calibre10">std::call_once</code>
 ，对<code class="calibre10">std::call_once</code>
 的调用会返回而不执行<code class="calibre10">func</code>
 。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在<code class="calibre10">std::once_flag</code>
 对象上有效的<code class="calibre10">std::call_once</code>
 调用的完成，发生于在同一个<code class="calibre10">std::once_flag</code>
 对象上所有接下来的<code class="calibre10">std::call_once</code>
 调用之前。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">当结果无法达到或从<code class="calibre10">func</code>
 的调用中传播出任何异常时，引发<code class="calibre10">std::system_error</code>
 。</p>
<h2 id="sigil_toc_id_5" class="calibre11">D.6　&lt;ratio&gt;头文件</h2>
<p class="zw">
<code class="calibre10">&lt;ratio&gt;</code>
 头文件提供了对编译时有理数数学运算的支持。</p>
<p class="zw">
<strong class="calibre3">头文件内容</strong>
</p>
<p class="calibre16"><img alt="..\tu\471B.tif" src="Image00768.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\472a.tif" src="Image00769.gif" class="calibre15"/>
</p>
<h3 id="sigil_toc_id_6" class="calibre14">D.6.1　std::ratio类模板</h3>
<p class="zw">
<code class="calibre10">std::ratio</code>
 类模板为编译时算法提供了一套机制，包括诸如二分之一（<code class="calibre10">std::ratio&lt;1,2&gt;</code>
 ）、三分之二（<code class="calibre10">std::ratio&lt;2,3&gt;</code>
 ）或四十三分之十五（<code class="calibre10">std::ratio&lt;15,43&gt;</code>
 ）这样的有理数值。在C++标准库中它被用来在实例化<code class="calibre10">std::chrono::duration</code>
 类模板时指定时间间隔。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\472B.tif" src="Image00770.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">需求</strong>
</p>
<p class="zw">
<code class="calibre10">D</code>
 不能为零。</p>
<p class="zw">
<strong class="calibre3">描述</strong>
</p>
<p class="zw">
<code class="calibre10">num</code>
 和<code class="calibre10">den</code>
 是分数<code class="calibre10">N</code>
 /<code class="calibre10">D</code>
 约分到最简的分子和分母。<code class="calibre10">den</code>
 永远为正数。如果<code class="calibre10">N</code>
 和<code class="calibre10">D</code>
 符号相同，<code class="calibre10">num</code>
 是正的；否则<code class="calibre10">num</code>
 是负的。</p>
<p class="zw">
<strong class="calibre3">示例</strong>
</p>
<p class="calibre16"><img alt="..\tu\473a.tif" src="Image00771.gif" class="calibre15"/>
</p>
<h3 id="sigil_toc_id_7" class="calibre14">D.6.2　std::ratio_add模板别名</h3>
<p class="zw">
<code class="calibre10">std::ratio_add</code>
 模板别名提供了在编译时将两个<code class="calibre10">std::ratio</code>
 值相加的机制，使用有理数算法。</p>
<p class="zw">
<strong class="calibre3">定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\473B.tif" src="Image00772.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">R1</code>
 和<code class="calibre10">R2</code>
 必须是<code class="calibre10">std::ratio</code>
 类模板的实例化。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">
<code class="calibre10">ratio_add&lt;R1,R2&gt;</code>
 被定义为<code class="calibre10">std::ratio</code>
 实例的一个别名，它表示了由<code class="calibre10">R1</code>
 和<code class="calibre10">R2</code>
 所代表的分数之和，如果它们的和可以没有溢出地计算出来。如果结果计算溢出，程序就是病态的。在没有算法溢出的情况下，<code class="calibre10">std::ratio_add&lt;R1,R2&gt;</code>
 应当拥有和<code class="calibre10">std::ratio&lt;R1::num*R2::den+R2::num*R1::den,R1::den*R2::den&gt;</code>
 相同的<code class="calibre10">num</code>
 和<code class="calibre10">den</code>
 值。</p>
<p class="zw">
<strong class="calibre3">示例</strong>
</p>
<p class="calibre16"><img alt="..\tu\473C.tif" src="Image00773.gif" class="calibre15"/>
</p>
<h3 id="sigil_toc_id_8" class="calibre14">D.6.3　std::ratio_subtract模板别名</h3>
<p class="zw">
<code class="calibre10">std::ratio_add</code>
 模板别名提供了在编译时将两个<code class="calibre10">std::ratio</code>
 值相减的机制，使用有理数算法。</p>
<p class="zw">
<strong class="calibre3">定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\473D.tif" src="Image00774.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">R1</code>
 和<code class="calibre10">R2</code>
 必须是<code class="calibre10">std::ratio</code>
 类模板的实例化。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">
<code class="calibre10">ratio_subtract&lt;R1,R2&gt;</code>
 被定义为<code class="calibre10">std::ratio</code>
 实例的一个别名，它表示了由<code class="calibre10">R1</code>
 和<code class="calibre10">R2</code>
 所代表的分数之差，如果它们的差可以没有溢出地计算出来。如果结果计算溢出，程序就是病态的。在没有算法溢出的情况下，<code class="calibre10">std::ratio_subtract&lt;R1,R2&gt;</code>
 应当拥有和<code class="calibre10">std::ratio&lt;R1::num*R2::den-R2::num*R1::den,R1::den*R2::den&gt;</code>
 相同的<code class="calibre10">num</code>
 和<code class="calibre10">den</code>
 值。</p>
<p class="zw">
<strong class="calibre3">示例</strong>
</p>
<p class="calibre16"><img alt="..\tu\474a.tif" src="Image00775.gif" class="calibre15"/>
</p>
<h3 id="sigil_toc_id_9" class="calibre14">D.6.4　std::ratio_multiply模板别名</h3>
<p class="zw">
<code class="calibre10">std::ratio_multiply</code>
 模板别名提供了在编译时将两个<code class="calibre10">std::ratio</code>
 值相乘的机制，使用有理数算法。</p>
<p class="zw">
<strong class="calibre3">定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\474B.tif" src="Image00776.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">R1</code>
 和<code class="calibre10">R2</code>
 必须是<code class="calibre10">std::ratio</code>
 类模板的实例化。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">
<code class="calibre10">ratio_multiply&lt;R1,R2&gt;</code>
 被定义为<code class="calibre10">std::ratio</code>
 实例的一个别名，它表示了由<code class="calibre10">R1</code>
 和<code class="calibre10">R2</code>
 所代表的分数之积，如果它们的积可以没有溢出地计算出来。如果结果计算溢出，程序就是病态的。在没有算法溢出的情况下，<code class="calibre10">std::ratio_multiply&lt;R1,R2&gt;</code>
 应当拥有和<code class="calibre10">std::ratio&lt;R1::num*R2::num,R1::den*R2::den&gt;</code>
 相同的<code class="calibre10">num</code>
 和<code class="calibre10">den</code>
 值。</p>
<p class="zw">
<strong class="calibre3">示例</strong>
</p>
<p class="calibre16"><img alt="..\tu\474C.tif" src="Image00777.gif" class="calibre15"/>
</p>
<h3 id="sigil_toc_id_10" class="calibre14">D.6.5　std::ratio_divide模板别名</h3>
<p class="zw">
<code class="calibre10">std::ratio_divide</code>
 模板别名提供了在编译时将两个<code class="calibre10">std::ratio</code>
 值相除的机制，使用有理数算法。</p>
<p class="zw">
<strong class="calibre3">定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\474D.tif" src="Image00778.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">R1</code>
 和<code class="calibre10">R2</code>
 必须是<code class="calibre10">std::ratio</code>
 类模板的实例化。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">
<code class="calibre10">ratio_multiply&lt;R1,R2&gt;</code>
 被定义为<code class="calibre10">std::ratio</code>
 实例的一个别名，它表示了由<code class="calibre10">R1</code>
 和<code class="calibre10">R2</code>
 所代表的分数相除的结果，如果此结果可以没有溢出地计算出来。如果结果计算溢出，程序就是病态的。在没有算法溢出的情况下，<code class="calibre10">std::ratio_divide&lt;R1,R2&gt;</code>
 应当拥有和<code class="calibre10">std::ratio&lt;R1::num*R2::den,R1::den*R2::num&gt;</code>
 相同的<code class="calibre10">num</code>
 和<code class="calibre10">den</code>
 值。</p>
<p class="zw">
<strong class="calibre3">示例</strong>
</p>
<p class="calibre16"><img alt="..\tu\475a.tif" src="Image00779.gif" class="calibre15"/>
</p>
<h3 id="sigil_toc_id_11" class="calibre14">D.6.6　std::ratio_equal类模板</h3>
<p class="zw">
<code class="calibre10">std::ratio_equal</code>
 类模板提供了在编译时比较两个<code class="calibre10">std::ratio</code>
 值是否相等的机制，使用有理数算法。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\475B.tif" src="Image00780.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">R1</code>
 和<code class="calibre10">R2</code>
 必须是<code class="calibre10">std::ratio</code>
 类模板的实例化。</p>
<p class="zw">
<strong class="calibre3">示例</strong>
</p>
<p class="calibre16"><img alt="..\tu\475C.tif" src="Image00781.gif" class="calibre15"/>
</p>
<h3 id="sigil_toc_id_12" class="calibre14">D.6.7　std::ratio_not_equal类模板</h3>
<p class="zw">
<code class="calibre10">std::ratio_equal</code>
 类模板提供了在编译时比较两个<code class="calibre10">std::ratio</code>
 值是否不相等的机制，使用有理数算法。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\475D.tif" src="Image00782.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">R1</code>
 和<code class="calibre10">R2</code>
 必须是<code class="calibre10">std::ratio</code>
 类模板的实例化。</p>
<p class="zw">
<strong class="calibre3">示例</strong>
</p>
<p class="calibre16"><img alt="..\tu\475E.tif" src="Image00783.gif" class="calibre15"/>
</p>
<h3 id="sigil_toc_id_13" class="calibre14">D.6.8　std::ratio_less类模板</h3>
<p class="zw">
<code class="calibre10">std::ratio_less</code>
 模板提供了在编译时比较两个<code class="calibre10">std::ratio</code>
 值，使用有理数算法。</p>
<p class="zw">
<strong class="calibre3">定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\476a.tif" src="Image00784.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">R1</code>
 和<code class="calibre10">R2</code>
 必须是<code class="calibre10">std::ratio</code>
 类模板的实例化。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">
<code class="calibre10">std::ratio_less&lt;R1,R2&gt;</code>
 派生自<code class="calibre10">std::integral_constant&lt;bool,value&gt;</code>
 ，这里<code class="calibre10">value</code>
 是<code class="calibre10">(R1::num*R2::den)&lt;(R2::num*R1::den)</code>
 。如果可能的话，其实现应使用避免溢出的方法来计算结果。如果发生了溢出，则程序就是病态的。</p>
<p class="zw">
<strong class="calibre3">示例</strong>
</p>
<p class="calibre16"><img alt="..\tu\476B.tif" src="Image00785.gif" class="calibre15"/>
</p>
<h3 id="sigil_toc_id_14" class="calibre14">D.6.9　std::ratio_greater类模板</h3>
<p class="zw">
<code class="calibre10">std::ratio_greater</code>
 模板提供了在编译时比较两个<code class="calibre10">std::ratio</code>
 值，使用有理数算法。</p>
<p class="zw">
<strong class="calibre3">定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\476C.tif" src="Image00786.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">R1</code>
 和<code class="calibre10">R2</code>
 必须是<code class="calibre10">std::ratio</code>
 类模板的实例化。</p>
<h3 id="sigil_toc_id_15" class="calibre14">D.6.10　std::ratio_less_equal类模板</h3>
<p class="zw">
<code class="calibre10">std::ratio_less_equal</code>
 模板提供了在编译时比较两个<code class="calibre10">std::ratio</code>
 值，使用有理数算法。</p>
<p class="zw">
<strong class="calibre3">定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\476D.tif" src="Image00787.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">R1</code>
 和<code class="calibre10">R2</code>
 必须是<code class="calibre10">std::ratio</code>
 类模板的实例化。</p>
<h3 id="sigil_toc_id_16" class="calibre14">D.6.11　std::ratio_greater_equal类模板</h3>
<p class="zw">
<code class="calibre10">std::ratio_greater_equal</code>
 模板提供了在编译时比较两个<code class="calibre10">std::ratio</code>
 值，使用有理数算法。</p>
<p class="zw">
<strong class="calibre3">定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\477a.tif" src="Image00788.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">R1</code>
 和<code class="calibre10">R2</code>
 必须是<code class="calibre10">std::ratio</code>
 类模板的实例化。</p>
<h2 id="sigil_toc_id_17" class="calibre11">D.7　&lt;thread&gt;头文件</h2>
<p class="zw">
<code class="calibre10">&lt;thread&gt;</code>
 头文件提供了用来管理和鉴别线程的服务，以及让当前线程挂起的函数。</p>
<p class="zw">
<strong class="calibre3">头文件内容</strong>
</p>
<p class="calibre16"><img alt="..\tu\477B.tif" src="Image00789.gif" class="calibre15"/>
</p>
<h3 id="sigil_toc_id_18" class="calibre14">D.7.1　std::thread类</h3>
<p class="zw">
<code class="calibre10">std::thread</code>
 类用来管理线程的执行。它提供了开始新线程运行和等待线程执行完毕的方法，以及标识线程的方法和其他管理线程执行的函数。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\477C.tif" src="Image00790.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\478a.tif" src="Image00791.gif" class="calibre15"/>
</p>
<h4 class="sigil_not_in_toc">std::thread::id类</h4>
<p class="zw">
<code class="calibre10">std::thread::id</code>
 的实例标识一个特定的线程的执行。</p>
<p class="zw">
<strong class="calibre3">类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\478B.tif" src="Image00792.gif" class="calibre15"/>
</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注意</strong>
 ：标识一个特定的线程执行的<code class="calibre10">std::thread::id</code>
 值，应该与默认构造的<code class="calibre10">std::thread::id</code>
 实例的值和所有代表其他线程执行的值都不相同。</p>
</blockquote>
<p class="zw">对特定的线程，<code class="calibre10">std::thread::id</code>
 值不可预测，并且可能在同一个程序的每次执行中都不一样。</p>
<p class="zw">
<code class="calibre10">std::thread::id</code>
 是<code class="calibre10">CopyConstructible</code>
 和<code class="calibre10">CopyAssignable</code>
 的，因此<code class="calibre10">std::thread::id</code>
 的实例可以自由地复制和赋值。</p>
<h4 class="sigil_not_in_toc">std::thread::id默认构造函数</h4>
<p class="zw">构造一个<code class="calibre10">std::thread::id</code>
 对象并不表示任何线程的执行。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\479a.tif" src="Image00793.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造一个<code class="calibre10">std::thread::id</code>
 实例，包括特别的<strong class="calibre3">非任何线程（not any thread）</strong>
 的值。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注意</strong>
 ：所有默认构造的<code class="calibre10">std::thread::id</code>
 实例存储相同的值。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::thread::id相等比较运算符</h4>
<p class="zw">比较两个<code class="calibre10">std::thread::id</code>
 的实例，看它们是否代表了相同的线程的执行。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\479B.tif" src="Image00794.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果<code class="calibre10">lhs</code>
 和<code class="calibre10">rhs</code>
 都表示相同的线程的执行或者都有特别的<strong class="calibre3">非任何线程</strong>
 值，返回<code class="calibre10">true</code>
 。如果<code class="calibre10">lhs</code>
 和<code class="calibre10">rhs</code>
 代表不同的线程的执行，或者其中一个表示线程的执行，另一个具有特别的<strong class="calibre3">非任何线程</strong>
 值，返回<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::thread::id不等比较运算符</h4>
<p class="zw">比较两个<code class="calibre10">std::thread::id</code>
 的实例，看它们是否代表了不同的线程的执行。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\479C.tif" src="Image00795.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\479D.tif" src="Image00796.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::thread::id小于比较运算符</h4>
<p class="zw">比较两个<code class="calibre10">std::thread::id</code>
 的实例，看其中一个是否在线程ID值总排序中排在另一个之前。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\479E.tif" src="Image00797.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果<code class="calibre10">lhs</code>
 的值在线程ID值总排序中出现在<code class="calibre10">rhs</code>
 的值之前，返回<code class="calibre10">true</code>
 。如果<code class="calibre10">lhs!=rhs</code>
 ，<code class="calibre10">lhs&lt;rhs</code>
 和<code class="calibre10">rhs&lt;lhs</code>
 中必然有一个返回<code class="calibre10">true</code>
 ，另一个返回<code class="calibre10">false</code>
 。如果<code class="calibre10">lhs==rhs</code>
 ，那么<code class="calibre10">lhs&lt;rhs</code>
 和<code class="calibre10">rhs&lt;lhs</code>
 都返回<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注意</strong>
 ：默认构造的<code class="calibre10">std::thread::id</code>
 实例所具有的特别的<strong class="calibre3">非任何线程</strong>
 值，它小于任何代表了线程的执行的<code class="calibre10">std::thread::id</code>
 实例。如果两个<code class="calibre10">std::thread::id</code>
 实例相等，那么谁都不小于谁。任意一组不同的<code class="calibre10">std::thread::id</code>
 值都可以构成一个总排序，它在程序的执行过程中是一致的。这个排序在同一个程序的每次执行之间可能会变化。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::thread::id小于或等于比较运算符</h4>
<p class="zw">比较两个<code class="calibre10">std::thread::id</code>
 的实例，看其中一个是否在线程ID值总排序中排在另一个之前或与之相等。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\480a.tif" src="Image00798.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\480B.tif" src="Image00799.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::thread::id大于比较运算符</h4>
<p class="zw">比较两个<code class="calibre10">std::thread::id</code>
 的实例，看其中一个是否在线程ID值总排序中排在另一个之后。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\480C.tif" src="Image00800.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\480D.tif" src="Image00801.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::thread::id大于或等于运算符</h4>
<p class="zw">比较两个<code class="calibre10">std::thread::id</code>
 的实例，看其中一个是否在线程ID值总排序中排在另一个之后或与之相等。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\480E.tif" src="Image00802.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="calibre16"><img alt="..\tu\480F.tif" src="Image00803.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::thread::id流插入运算符</h4>
<p class="zw">将表示<code class="calibre10">std::thread::id</code>
 值的字符串写到指定的流中。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\481a.tif" src="Image00804.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">将表示<code class="calibre10">std::thread::id</code>
 值的字符串插入到指定的流中。</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">out</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注意</strong>
 ：字符串表示的格式并未指定。相等的<code class="calibre10">std::thread::id</code>
 实例具有相同的表示，不等的实例具有不同的表示。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::thread::native_handle_typetypedef</h4>
<p class="zw">
<code class="calibre10">native_handle_type</code>
 是一个到可用于特定平台API类型的typedef。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\481B.tif" src="Image00805.gif" class="calibre15"/>
</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 该typedef是<strong class="calibre3">可选的</strong>
 。若存在，则其实现应当提供一个适用于本地特定平台API的类型。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::thread::native_handle成员函数</h4>
<p class="zw">返回<code class="calibre10">native_handle_type</code>
 类型的值，它代表着与<code class="calibre10">*this</code>
 关联的执行线程。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\481C.tif" src="Image00806.gif" class="calibre15"/>
</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 该函数是<strong class="calibre3">可选的</strong>
 。若存在，则返回值应该适用于本地特定平台API。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::thread默认构造函数</h4>
<p class="zw">构造不与执行线程相关联的<code class="calibre10">std::thread</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\481D.tif" src="Image00807.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造<code class="calibre10">std::thread</code>
 实例，它没有关联的执行线程。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">对新构造的<code class="calibre10">std::thread</code>
 对象<code class="calibre10">x</code>
 ，<code class="calibre10">x.get_id()==id()</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::thread构造函数</h4>
<p class="zw">构造与新的执行线程相关联的<code class="calibre10">std::thread</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\482a.tif" src="Image00808.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">func</code>
 和<code class="calibre10">args</code>
 的每个元素必须是<code class="calibre10">MoveConstructible</code>
 的。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造<code class="calibre10">std::thread</code>
 实例并将它关联至新创建的执行线程。复制或移动<code class="calibre10">func</code>
 和<code class="calibre10">args</code>
 的每个元素到内部存储中，并持续在新的执行线程的整个生命周期。在新的执行线程上执行<code class="calibre10">INVOKE(copy-of-func,copy-of-args)</code>
 。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">对新构造的<code class="calibre10">std::thread</code>
 对象<code class="calibre10">x</code>
 ，<code class="calibre10">x.get_id()!=id()</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果不能启动新线程，引发<code class="calibre10">std::system_error</code>
 类型的异常。将<code class="calibre10">func</code>
 或<code class="calibre10">args</code>
 复制进内部存储时引发的任何异常。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">对构造函数的调用，发生于在新创建的执行线程上执行给定函数之前。</p>
<h4 class="sigil_not_in_toc">std::thread移动构造函数</h4>
<p class="zw">将执行线程的所有权从一个<code class="calibre10">std::thread</code>
 对象转移到新创建的<code class="calibre10">std::thread</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\482B.tif" src="Image00809.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">构造<code class="calibre10">std::thread</code>
 实例。如果<code class="calibre10">other</code>
 在调用构造函数之前拥有一个相关联的执行线程，该执行线程现在关联至新创建的<code class="calibre10">std::thread</code>
 对象。否则，新创建的<code class="calibre10">std::thread</code>
 对象没有相关联的执行线程。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">对新构造的<code class="calibre10">std::thread</code>
 对象<code class="calibre10">x</code>
 ，<code class="calibre10">x.get_id()</code>
 的与调用构造函数前<code class="calibre10">other.get_id()</code>
 的值相等。<code class="calibre10">other.get_id()==id()</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 <code class="calibre10">std::thread</code>
 对象<strong class="calibre3">不是</strong>
 <code class="calibre10">Copyconstructible</code>
 的，所以没有拷贝构造函数，只有这个移动构造函数。</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::thread析构函数</h4>
<p class="zw">销毁<code class="calibre10">std::thread</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\482C.tif" src="Image00810.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">销毁<code class="calibre10">*this</code>
 。如果<code class="calibre10">*this</code>
 拥有相关联的执行线程（<code class="calibre10">this-&gt;joinable()</code>
 会返回<code class="calibre10">true</code>
 ），调用<code class="calibre10">std::terminate()</code>
 来结束程序。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::thread移动赋值运算符</h4>
<p class="zw">将执行线程的所有权从一个<code class="calibre10">std::thread</code>
 对象转移到另一个<code class="calibre10">std::thread</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\483a.tif" src="Image00811.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果在调用之前<code class="calibre10">this-&gt;joinable()</code>
 返回<code class="calibre10">true</code>
 ，调用<code class="calibre10">std::terminate()</code>
 来结束程序。如果<code class="calibre10">other</code>
 在赋值之前拥有一个相关联的执行线程，该执行线程现在关联至<code class="calibre10">*this</code>
 。否则，<code class="calibre10">*this</code>
 没有相关联的执行线程。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;get_id()</code>
 与调用前<code class="calibre10">other.get_id()</code>
 的值相等。<code class="calibre10">other.get_id()==id()</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 <code class="calibre10">std::thread</code>
 对象<strong class="calibre3">不是</strong>
 <code class="calibre10">Copyconstructible</code>
 的，所以没有拷贝赋值运算符，只有这个移动赋值运算符</p>
</blockquote>
<h4 class="sigil_not_in_toc">std::thread::swap成员函数</h4>
<p class="zw">在两个<code class="calibre10">std::thread</code>
 对象之间交换它们相关的执行线程的所有权。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\483B.tif" src="Image00812.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">如果<code class="calibre10">other</code>
 在调用之前拥有一个相关联的执行线程，该执行线程现在关联至<code class="calibre10">*this</code>
 。否则<code class="calibre10">*this</code>
 没有相关联的执行线程。如果<code class="calibre10">*this</code>
 在调用之前拥有一个相关联的执行线程，该执行线程现在关联至<code class="calibre10">other</code>
 。否则<code class="calibre10">other</code>
 没有相关联的执行线程。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;get_id()</code>
 与调用前<code class="calibre10">other.get_id()</code>
 的值相等。<code class="calibre10">other.get_id()</code>
 与调用前<code class="calibre10">this-&gt;get_id()</code>
 的值相等。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">swap非成员函数</h4>
<p class="zw">在两个<code class="calibre10">std::thread</code>
 对象之间交换它们相关的执行线程的所有权。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\484a.tif" src="Image00813.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="calibre16"><img alt="..\tu\484B.tif" src="Image00814.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::thread::joinable成员函数</h4>
<p class="zw">查询<code class="calibre10">*this</code>
 是否拥有关联的执行线程。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\484C.tif" src="Image00815.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果<code class="calibre10">*this</code>
 拥有相关联的执行线程，返回<code class="calibre10">true</code>
 ，否则<code class="calibre10">false</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::thread::join成员函数</h4>
<p class="zw">等待与<code class="calibre10">*this</code>
 相关联的执行线程结束。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\484D.tif" src="Image00816.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;joinable()</code>
 应返回<code class="calibre10">true</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">阻塞当前线程，直到与<code class="calibre10">*this</code>
 关联的执行线程结束。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;get_id()==id()</code>
 。在调用之前与<code class="calibre10">*this</code>
 关联的执行线程已结束。</p>
<p class="zw">
<strong class="calibre3">同步</strong>
</p>
<p class="zw">在调用前与<code class="calibre10">*this</code>
 相关联的执行线程执行完毕，发生于对<code class="calibre10">join()</code>
 的调用返回之前。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果无法得到结果，或者<code class="calibre10">this-&gt;joinable()</code>
 返回<code class="calibre10">false</code>
 ，引发<code class="calibre10">std::system_error</code>
 异常。</p>
<h4 class="sigil_not_in_toc">std::thread::detach成员函数</h4>
<p class="zw">分离与<code class="calibre10">*this</code>
 相关联的执行线程以结束。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\484E.tif" src="Image00817.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">前置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;joinable()</code>
 应返回<code class="calibre10">true</code>
 。</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">分离与<code class="calibre10">*this</code>
 相关联的执行线程。</p>
<p class="zw">
<strong class="calibre3">后置条件</strong>
</p>
<p class="zw">
<code class="calibre10">this-&gt;get_id()==id()</code>
 ，<code class="calibre10">this-&gt;joinable==false</code>
 。</p>
<p class="zw">在调用前与<code class="calibre10">*this</code>
 相关联的线程被分离，并且不再拥有相关联的<code class="calibre10">std::thread</code>
 对象。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">如果无法得到结果，或者在调用时<code class="calibre10">this-&gt;joinable()</code>
 返回<code class="calibre10">false</code>
 ，引发<code class="calibre10">std::system_error</code>
 异常。</p>
<h4 class="sigil_not_in_toc">std::thread::get_id成员函数</h4>
<p class="zw">返回标识着与<code class="calibre10">*this</code>
 关联的执行线程的值。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\485B.tif" src="Image00818.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">如果<code class="calibre10">*this</code>
 拥有相关联的执行线程，返回标识着该线程的<code class="calibre10">std::thread::id</code>
 实例。否则返回一个默认构造的<code class="calibre10">std::thread::id</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::thread::hardware_concurrency静态成员函数</h4>
<p class="zw">返回在当前硬件上能够并发运行的线程数目的提示。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\485C.tif" src="Image00819.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">在当前硬件上能够并发运行的线程数目。例如，可能是系统中处理器的数量。当此信息不可用或者没有妥善定义，函数返回<code class="calibre10">0</code>
 。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h3 id="sigil_toc_id_19" class="calibre14">D.7.2　this_thread命名空间</h3>
<p class="zw">
<code class="calibre10">std::this_thread</code>
 命名空间中的函数在调用线程上运行。</p>
<h4 class="sigil_not_in_toc">std::this_thread::get_id非成员函数</h4>
<p class="zw">返回一个<code class="calibre10">std::thread::id</code>
 类型的值，标识当前的执行线程。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\485D.tif" src="Image00820.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">返回</strong>
</p>
<p class="zw">标识当前线程的一个<code class="calibre10">std::thread::id</code>
 的实例。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::this_thread::yield非成员函数</h4>
<p class="zw">用来告知类库，调用该函数的线程不需要在调用处运行。通常用在密集的循环中，以避免消耗过多的CPU时间。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\486a.tif" src="Image00821.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">为类库提供一个机会，可以调度其他的事情来替代当前线程。</p>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::this_thread::sleep_for非成员函数</h4>
<p class="zw">将当前线程的执行挂起一段指定的时间。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\486B.tif" src="Image00822.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">阻塞当前线程，直到指定的<code class="calibre10">relative_time</code>
 逝去。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 线程可能会比指定的时间段阻塞更久。如果可能的话，逝去时间应由匀速时钟来决定。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<h4 class="sigil_not_in_toc">std::this_thread::sleep_until非成员函数</h4>
<p class="zw">挂起将当前线程的执行，直到达到指定的时间点。</p>
<p class="zw">
<strong class="calibre3">声明</strong>
</p>
<p class="calibre16"><img alt="..\tu\486C.tif" src="Image00823.gif" class="calibre15"/>
</p>
<p class="zw">
<strong class="calibre3">结果</strong>
</p>
<p class="zw">阻塞当前线程，直到指定的<code class="calibre10">Clock</code>
 达到了指定的<code class="calibre10">absolute_time</code>
 。</p>
<blockquote class="yin_yong">
<p class="zw">
<strong class="calibre3">注　</strong>
 没有保证调用线程会被阻塞多久，除非<code class="calibre10">Clock::now()</code>
 返回的时间等于或者晚于<code class="calibre10">absolute_time</code>
 的时候线程才会解除阻塞。</p>
</blockquote>
<p class="zw">
<strong class="calibre3">引发</strong>
</p>
<p class="zw">无。</p>
<p class="zw"><br class="calibre7"/>
</p>
<div class="calibre5"></div>



  </div>

  
  <div class="calibreToc">
    <h2><a href="../../1w54d-4vylw.html">Table of contents
</a></h2>
    <div>
  <ul>
    <li>
      <a href="text00002.html">版权信息</a>
    </li>
    <li>
      <a href="text00003.html#nav_point_0">版权声明</a>
    </li>
    <li>
      <a href="text00004.html#nav_point_1">内容提要</a>
    </li>
    <li>
      <a href="text00005.html#nav_point_2">序</a>
    </li>
    <li>
      <a href="text00006.html#nav_point_3">译者简介</a>
    </li>
    <li>
      <a href="text00008.html#nav_point_4">致谢</a>
    </li>
    <li>
      <a href="text00009.html#nav_point_5">前言</a>
      <ul>
        <li>
          <a href="text00009.html#nav_point_6">路线图</a>
        </li>
        <li>
          <a href="text00009.html#nav_point_7">谁应该阅读本书</a>
        </li>
        <li>
          <a href="text00009.html#nav_point_8">如何使用本书</a>
        </li>
        <li>
          <a href="text00009.html#nav_point_9">代码约定和下载</a>
        </li>
        <li>
          <a href="text00009.html#nav_point_10">软件需求</a>
        </li>
        <li>
          <a href="text00009.html#nav_point_11">作者在线</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00010.html#nav_point_12">资源</a>
      <ul>
        <li>
          <a href="text00010.html#nav_point_13">印刷资源</a>
        </li>
        <li>
          <a href="text00010.html#nav_point_14">在线资源</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00011.html#nav_point_15">简要目录</a>
    </li>
    <li>
      <a href="text00012.html#nav_point_16">第1章 你好，C++并发世界</a>
      <ul>
        <li>
          <a href="text00012.html#nav_point_17">1.1 什么是并发</a>
          <ul>
            <li>
              <a href="text00012.html#nav_point_18">1.1.1 计算机系统中的并发</a>
            </li>
            <li>
              <a href="text00012.html#nav_point_19">1.1.2 并发的途径</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00012.html#nav_point_20">1.2 为什么使用并发</a>
          <ul>
            <li>
              <a href="text00012.html#nav_point_21">1.2.1 为了划分关注点而使用并发</a>
            </li>
            <li>
              <a href="text00012.html#nav_point_22">1.2.2 为了性能而使用并发</a>
            </li>
            <li>
              <a href="text00012.html#nav_point_23">1.2.3 什么时候不使用并发</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00012.html#nav_point_24">1.3 在C++中使用并发和多线程</a>
          <ul>
            <li>
              <a href="text00012.html#nav_point_25">1.3.1 C++多线程历程</a>
            </li>
            <li>
              <a href="text00012.html#nav_point_26">1.3.2 新标准中的并发支持</a>
            </li>
            <li>
              <a href="text00012.html#nav_point_27">1.3.3 C++线程库的效率</a>
            </li>
            <li>
              <a href="text00012.html#nav_point_28">1.3.4 平台相关的工具</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00012.html#nav_point_29">1.4 开始入门</a>
          <ul>
            <li>
              <a href="text00012.html#nav_point_30">你好，并发世界</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00012.html#nav_point_31">1.5 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00013.html#nav_point_32">第2章 管理线程</a>
      <ul>
        <li>
          <a href="text00013.html#nav_point_33">2.1 基本线程管理</a>
          <ul>
            <li>
              <a href="text00013.html#nav_point_34">2.1.1 启动线程</a>
            </li>
            <li>
              <a href="text00013.html#nav_point_35">2.1.2 等待线程完成</a>
            </li>
            <li>
              <a href="text00013.html#nav_point_36">2.1.3 在异常环境下的等待</a>
            </li>
            <li>
              <a href="text00013.html#nav_point_37">2.1.4 在后台运行线程</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00013.html#nav_point_38">2.2 传递参数给线程函数</a>
        </li>
        <li>
          <a href="text00013.html#nav_point_39">2.3 转移线程的所有权</a>
        </li>
        <li>
          <a href="text00013.html#nav_point_40">2.4 在运行时选择线程数量</a>
        </li>
        <li>
          <a href="text00013.html#nav_point_41">2.5 标识线程</a>
        </li>
        <li>
          <a href="text00013.html#nav_point_42">2.6 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00014.html#nav_point_43">第3章 在线程间共享数据</a>
      <ul>
        <li>
          <a href="text00014.html#nav_point_44">3.1 线程之间共享数据的问题</a>
          <ul>
            <li>
              <a href="text00014.html#nav_point_45">3.1.1 竞争条件</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_46">3.1.2 避免有问题的竞争条件</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00014.html#nav_point_47">3.2 用互斥元保护共享数据</a>
          <ul>
            <li>
              <a href="text00014.html#nav_point_48">3.2.1 使用C++中的互斥元</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_49">3.2.2 为保护共享数据精心组织代码</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_50">3.2.3 发现接口中固有的竞争条件</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_51">3.2.4 死锁：问题和解决方案</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_52">3.2.5 避免死锁的进一步指南</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_53">3.2.6 用std::unique_lock灵活锁定</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_54">3.2.7 在作用域之间转移锁的所有权</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_55">3.2.8 锁定在恰当的粒度</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00014.html#nav_point_56">3.3 用于共享数据保护的替代工具</a>
          <ul>
            <li>
              <a href="text00014.html#nav_point_57">3.3.1 在初始化时保护共享数据</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_58">3.3.2 保护很少更新的数据结构</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_59">3.3.3 递归锁</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00014.html#nav_point_60">3.4 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00015.html#nav_point_61">第4章 同步并发操作</a>
      <ul>
        <li>
          <a href="text00015.html#nav_point_62">4.1 等待事件或其他条件</a>
          <ul>
            <li>
              <a href="text00015.html#nav_point_63">4.1.1 用条件变量等待条件</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_64">4.1.2 使用条件变量建立一个线程安全队列</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00015.html#nav_point_65">4.2 使用future等待一次性事件</a>
          <ul>
            <li>
              <a href="text00015.html#nav_point_66">4.2.1 从后台任务中返回值</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_67">4.2.2 将任务与future相关联</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_68">4.2.3 生成(std::)promise</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_69">4.2.4 为future保存异常</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_70">4.2.5 等待自多个线程</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00015.html#nav_point_71">4.3 有时间限制的等待</a>
          <ul>
            <li>
              <a href="text00015.html#nav_point_72">4.3.1 时钟</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_73">4.3.2 时间段</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_74">4.3.3 时间点</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_75">4.3.4 接受超时的函数</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00015.html#nav_point_76">4.4 使用操作同步来简化代码</a>
          <ul>
            <li>
              <a href="text00015.html#nav_point_77">4.4.1 带有future的函数式编程</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_78">4.4.2 具有消息传递的同步操作</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00015.html#nav_point_79">4.5 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00016.html#nav_point_80">第5章 C++内存模型和原子类型上操作</a>
      <ul>
        <li>
          <a href="text00016.html#nav_point_81">5.1 内存模型基础</a>
          <ul>
            <li>
              <a href="text00016.html#nav_point_82">5.1.1 对象和内存位置</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_83">5.1.2 对象、内存位置以及并发</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_84">5.1.3 修改顺序</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00016.html#nav_point_85">5.2 C++中的原子操作及类型</a>
          <ul>
            <li>
              <a href="text00016.html#nav_point_86">5.2.1 标准原子类型</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_87">5.2.2 std::atomic_flag上的操作</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_88">5.2.3 基于std::atomic&lt;bool&gt;的操作</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_89">5.2.4 std::atomic&lt;T*&gt;上的操作：指针算术运算</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_90">5.2.5 标准原子整型的操作</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_91">5.2.6 std::atomic&lt;&gt;初级类模板</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_92">5.2.7 原子操作的自由函数</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00016.html#nav_point_93">5.3 同步操作和强制顺序</a>
          <ul>
            <li>
              <a href="text00016.html#nav_point_94">5.3.1 synchronizes-with关系</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_95">5.3.2 happens-before关系</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_96">5.3.3 原子操作的内存顺序</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_97">5.3.4 释放序列和synchronizes-with</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_98">5.3.5 屏障</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_99">5.3.6 用原子操作排序非原子操作</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00016.html#nav_point_100">5.4 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00017.html#nav_point_101">第6章 设计基于锁的并发数据结构</a>
      <ul>
        <li>
          <a href="text00017.html#nav_point_102">6.1 为并发设计的含义是什么</a>
          <ul>
            <li>
              <a href="text00017.html#nav_point_103">为并发设计数据结构的准则</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00017.html#nav_point_104">6.2 基于锁的并发数据结构</a>
          <ul>
            <li>
              <a href="text00017.html#nav_point_105">6.2.1 使用锁的线程安全栈</a>
            </li>
            <li>
              <a href="text00017.html#nav_point_106">6.2.2 使用锁和条件变量的线程安全队列</a>
            </li>
            <li>
              <a href="text00017.html#nav_point_107">6.2.3 使用细粒度锁和条件变量的线程安全队列</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00017.html#nav_point_108">6.3 设计更复杂的基于锁的数据结构</a>
          <ul>
            <li>
              <a href="text00017.html#nav_point_109">6.3.1 编写一个使用锁的线程安全查找表</a>
            </li>
            <li>
              <a href="text00017.html#nav_point_110">6.3.2 编写一个使用锁的线程安全链表</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00017.html#nav_point_111">6.4 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00018.html#nav_point_112">第7章 设计无锁的并发数据结构</a>
      <ul>
        <li>
          <a href="text00018.html#nav_point_113">7.1 定义和结果</a>
          <ul>
            <li>
              <a href="text00018.html#nav_point_114">7.1.1 非阻塞数据结构的类型</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_115">7.1.2 无锁数据结构</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_116">7.1.3 无等待的数据结构</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_117">7.1.4 无锁数据结构的优点与缺点</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00018.html#nav_point_118">7.2 无锁数据结构的例子</a>
          <ul>
            <li>
              <a href="text00018.html#nav_point_119">7.2.1 编写不用锁的线程安全栈</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_120">7.2.2 停止恼人的泄漏：在无锁数据结构中管理内存</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_121">7.2.3 用风险指针检测不能被回收的结点</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_122">7.2.4 使用引用计数检测结点</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_123">7.2.5 将内存模型应用至无锁栈</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_124">7.2.6 编写不用锁的线程安全队列</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00018.html#nav_point_125">7.3 编写无锁数据结构的准则</a>
          <ul>
            <li>
              <a href="text00018.html#nav_point_126">7.3.1 准则：使用std::memory_order_seq_cst作为原型</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_127">7.3.2 准则：使用无锁内存回收模式</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_128">7.3.3 准则：当心ABA问题</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_129">7.3.4 准则：识别忙于等待的循环以及辅助其他线程</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00018.html#nav_point_130">7.4 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00019.html#nav_point_131">第8章 设计并发代码</a>
      <ul>
        <li>
          <a href="text00019.html#nav_point_132">8.1 在线程间划分工作的技术</a>
          <ul>
            <li>
              <a href="text00019.html#nav_point_133">8.1.1 处理开始前在线程间划分数据</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_134">8.1.2 递归地划分数据</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_135">8.1.3 以任务类型划分工作</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00019.html#nav_point_136">8.2 影响并发代码性能的因素</a>
          <ul>
            <li>
              <a href="text00019.html#nav_point_137">8.2.1 有多少个处理器？</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_138">8.2.2 数据竞争和乒乓缓存</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_139">8.2.3 假共享</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_140">8.2.4 数据应该多紧密</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_141">8.2.5 过度订阅和过多的任务切换</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00019.html#nav_point_142">8.3 为多线程性能设计数据结构</a>
          <ul>
            <li>
              <a href="text00019.html#nav_point_143">8.3.1 为复杂操作划分数组元素</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_144">8.3.2 其他数据结构中的数据访问方式</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00019.html#nav_point_145">8.4 为并发设计时的额外考虑</a>
          <ul>
            <li>
              <a href="text00019.html#nav_point_146">8.4.1 并行算法中的异常安全</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_147">8.4.2 可扩展性和阿姆达尔定律</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_148">8.4.3 用多线程隐藏延迟</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_149">8.4.4 用并发提高响应性</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00019.html#nav_point_150">8.5 在实践中设计并发代码</a>
          <ul>
            <li>
              <a href="text00019.html#nav_point_151">8.5.1 std::for_each的并行实现</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_152">8.5.2 std::find的并行实现</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_153">8.5.3 std::partial_sum的并行实现</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00019.html#nav_point_154">8.6 总结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00020.html#nav_point_155">第9章 高级线程管理</a>
      <ul>
        <li>
          <a href="text00020.html#nav_point_156">9.1 线程池</a>
          <ul>
            <li>
              <a href="text00020.html#nav_point_157">9.1.1 最简单的线程池</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_158">9.1.2 等待提交给线程池的任务</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_159">9.1.3 等待其他任务的任务</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_160">9.1.4 避免工作队列上的竞争</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_161">9.1.5 工作窃取</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00020.html#nav_point_162">9.2 中断线程</a>
          <ul>
            <li>
              <a href="text00020.html#nav_point_163">9.2.1 启动和中断另一个线程</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_164">9.2.2 检测一个线程是否被中断</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_165">9.2.3 中断等待条件变量</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_166">9.2.4 中断在std::condition_variable_any上的等待</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_167">9.2.5 中断其他阻塞调用</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_168">9.2.6 处理中断</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_169">9.2.7 在应用退出时中断后台任务</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00020.html#nav_point_170">9.3 总结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00021.html#nav_point_171">第10章 多线程应用的测试与调试</a>
      <ul>
        <li>
          <a href="text00021.html#nav_point_172">10.1 并发相关错误的类型</a>
          <ul>
            <li>
              <a href="text00021.html#nav_point_173">10.1.1 不必要的阻塞</a>
            </li>
            <li>
              <a href="text00021.html#nav_point_174">10.1.2 竞争条件</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00021.html#nav_point_175">10.2 定位并发相关的错误的技巧</a>
          <ul>
            <li>
              <a href="text00021.html#nav_point_176">10.2.1 审阅代码以定位潜在的错误</a>
            </li>
            <li>
              <a href="text00021.html#nav_point_177">10.2.2 通过测试定位并发相关的错误</a>
            </li>
            <li>
              <a href="text00021.html#nav_point_178">10.2.3 可测试性设计</a>
            </li>
            <li>
              <a href="text00021.html#nav_point_179">10.2.4 多线程测试技术</a>
            </li>
            <li>
              <a href="text00021.html#nav_point_180">10.2.5 构建多线程的测试代码</a>
            </li>
            <li>
              <a href="text00021.html#nav_point_181">10.2.6 测试多线程代码的性能</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00021.html#nav_point_182">10.3 总结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00022.html#nav_point_183">附录A C++11部分语言特性简明参考</a>
      <ul>
        <li>
          <a href="text00022.html#nav_point_184">A.1 右值引用</a>
          <ul>
            <li>
              <a href="text00022.html#nav_point_185">A.1.1 移动语义</a>
            </li>
            <li>
              <a href="text00022.html#nav_point_186">A.1.2 右值引用与函数模板</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00022.html#nav_point_187">A.2 deleted函数</a>
        </li>
        <li>
          <a href="text00022.html#nav_point_188">A.3 defaulted函数</a>
        </li>
        <li>
          <a href="text00022.html#nav_point_189">A.4 constexpr函数</a>
          <ul>
            <li>
              <a href="text00022.html#nav_point_190">A.4.1 constexpr与用户定义类型</a>
            </li>
            <li>
              <a href="text00022.html#nav_point_191">A.4.2 constexpr对象</a>
            </li>
            <li>
              <a href="text00022.html#nav_point_192">A.4.3 constexpr函数要求</a>
            </li>
            <li>
              <a href="text00022.html#nav_point_193">A.4.4 constexpr与模板</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00022.html#nav_point_194">A.5 lambda函数</a>
          <ul>
            <li>
              <a href="text00022.html#nav_point_195">引用局部变量的lambda函数</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00022.html#nav_point_196">A.6 变参模板</a>
          <ul>
            <li>
              <a href="text00022.html#nav_point_197">展开参数包</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00022.html#nav_point_198">A.7 自动推断变量的类型</a>
        </li>
        <li>
          <a href="text00022.html#nav_point_199">A.8 线程局部变量</a>
        </li>
        <li>
          <a href="text00022.html#nav_point_200">A.9 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00023.html#nav_point_201">附录B 并发类库简要对比</a>
    </li>
    <li>
      <a href="text00024.html#nav_point_202">附录C 消息传递框架与完整的ATM示例</a>
    </li>
    <li>
      <a href="text00025.html#nav_point_203">附录D C++线程类库参考</a>
      <ul>
        <li>
          <a href="text00025.html#nav_point_204">D.1 &lt;chrono&gt;头文件</a>
          <ul>
            <li>
              <a href="text00025.html#nav_point_205">D.1.1 std::chrono::duration类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_206">D.1.2 std::chrono::time_point类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_207">D.1.3 std::chrono::system_clock类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_208">D.1.4 std::chrono::steady_clock类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_209">D.1.5 std::chrono::high_resolution_clock typedef</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00025.html#nav_point_210">D.2 &lt;condition_variable&gt;头文件</a>
          <ul>
            <li>
              <a href="text00025.html#nav_point_211">D.2.1 std::condition_variable类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_212">D.2.2 std::condition_variable_any类</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00025.html#nav_point_213">D.3 &lt;atomic&gt;头文件</a>
          <ul>
            <li>
              <a href="text00025.html#nav_point_214">D.3.1 std::atomic_xxx typedef</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_215">D.3.2 ATOMIC_xxx_LOCK_FREE宏</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_216">D.3.3 ATOMIC_VAR_INIT宏</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_217">D.3.4 std::memory_order枚举</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_218">D.3.5 std::atomic_thread_fence函数</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_219">D.3.6 std::atomic_signal_fence函数</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_220">D.3.7 std::atomic_flag类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_221">D.3.8 std::atomic类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_222">D.3.9 std::atomic模板的特化</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_223">D.3.10 std::atomic&lt;integral-type&gt;特化</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_224">D.3.11 std::atomic&lt;T*&gt;偏特化</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00025.html#nav_point_225">D.4 &lt;future&gt;头文件</a>
          <ul>
            <li>
              <a href="text00025.html#nav_point_226">D.4.1 std::future类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_227">D.4.2 std::shared_future类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_228">D.4.3 std::packaged_task类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_229">D.4.4 std::promise类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_230">D.4.5 std::async函数模板</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00025.html#nav_point_231">D.5 &lt;mutex&gt;头文件</a>
          <ul>
            <li>
              <a href="text00025.html#nav_point_232">D.5.1 std::mutex类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_233">D.5.2 std::recursive_mutex类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_234">D.5.3 std::timed_mutex类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_235">D.5.4 std::recursive_timed_mutex类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_236">D.5.5 std::lock_guard类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_237">D.5.6 std::unique_lock类模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_1">D.5.7 std::lock函数模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_2">D.5.8 std::try_lock函数模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_3">D.5.9 std::once_flag类</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_4">D.5.10 std::call_once函数模板</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00025.html#sigil_toc_id_5">D.6 &lt;ratio&gt;头文件</a>
          <ul>
            <li>
              <a href="text00025.html#sigil_toc_id_6">D.6.1 std::ratio类模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_7">D.6.2 std::ratio_add模板别名</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_8">D.6.3 std::ratio_subtract模板别名</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_9">D.6.4 std::ratio_multiply模板别名</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_10">D.6.5 std::ratio_divide模板别名</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_11">D.6.6 std::ratio_equal类模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_12">D.6.7 std::ratio_not_equal类模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_13">D.6.8 std::ratio_less类模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_14">D.6.9 std::ratio_greater类模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_15">D.6.10 std::ratio_less_equal类模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_16">D.6.11 std::ratio_greater_equal类模板</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00025.html#sigil_toc_id_17">D.7 &lt;thread&gt;头文件</a>
          <ul>
            <li>
              <a href="text00025.html#sigil_toc_id_18">D.7.1 std::thread类</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_19">D.7.2 this_thread命名空间</a>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00026.html#nav_point_238">欢迎来到异步社区！</a>
      <ul>
        <li>
          <a href="text00026.html#nav_point_239">异步社区的来历</a>
        </li>
        <li>
          <a href="text00026.html#nav_point_240">社区里都有什么？</a>
          <ul>
            <li>
              <a href="text00026.html#nav_point_241">购买图书</a>
            </li>
            <li>
              <a href="text00026.html#nav_point_242">下载资源</a>
            </li>
            <li>
              <a href="text00026.html#nav_point_243">与作译者互动</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00026.html#nav_point_244">灵活优惠的购书</a>
          <ul>
            <li>
              <a href="text00026.html#nav_point_245">纸电图书组合购买</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00026.html#nav_point_246">社区里还可以做什么？</a>
          <ul>
            <li>
              <a href="text00026.html#nav_point_247">提交勘误</a>
            </li>
            <li>
              <a href="text00026.html#nav_point_248">写作</a>
            </li>
            <li>
              <a href="text00026.html#nav_point_249">会议活动早知道</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00026.html#nav_point_250">加入异步</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00027.html#sigil_toc_id_20">看完了</a>
    </li>
  </ul>
</div>


  </div>
  

  <div class="calibreEbNav">
    
      <a href="text00024.html" class="calibreAPrev">previous page
</a>
    

    <a href="../../1w54d-4vylw.html" class="calibreAHome">start
</a>

    
      <a href="text00026.html" class="calibreANext">next page
</a>
    
  </div>

</div>

</body>
</html>
