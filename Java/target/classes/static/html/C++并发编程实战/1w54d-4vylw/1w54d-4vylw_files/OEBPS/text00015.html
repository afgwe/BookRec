<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>

    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>

  


<link href="../calibreHtmlOutBasicCss.css" type="text/css" rel="stylesheet" />

</head>
<body>

<div class="calibreMeta">
  <div class="calibreMetaTitle">
  
  
    
    <h1>
      <a href="../../1w54d-4vylw.html">C++并发编程实战
</a>
    </h1>
    
    
  
  </div>
  <div class="calibreMetaAuthor">
    威廉姆斯(Anthony Williams)

  </div>
</div>

<div class="calibreMain">

  <div class="calibreEbookContent">
    
      <div class="calibreEbNavTop">
        
          <a href="text00014.html" class="calibreAPrev">previous page
</a>
        

        
          <a href="text00016.html" class="calibreANext">next page
</a>
        
      </div>
    

    
<h1 id="nav_point_61" class="not-in-toc">第4章　同步并发操作</h1>
<p class="zw">
<strong class="calibre3">本章主要内容</strong>
</p>
<ul class="calibre13">
<li class="di_1ji_wu_xu_lie_biao">
<strong class="calibre3">等待事件</strong>
</li>
<li class="di_1ji_wu_xu_lie_biao">
<strong class="calibre3">使用future来等待一次性事件</strong>
</li>
<li class="di_1ji_wu_xu_lie_biao">
<strong class="calibre3">有时间限制的等待</strong>
</li>
<li class="di_1ji_wu_xu_lie_biao">
<strong class="calibre3">使用操作的同步来简化代码</strong>
</li>
</ul>
<p class="zw">在上一章中，我们看到了各种方法去保护在线程间共享的数据。但是有时候你不只是需要保护数据，还需要在独立的线程上进行同步操作。例如，一个线程在能够完成其任务之前可能需要等待另一个线程完成任务。一般来说，希望一个线程等待特定事件的发生或是一个条件变为<code class="calibre10">true</code>
 是常见的事情。虽然通过定期检查“任务完成”的标识或是在共享数据中存储类似的东西也能够做到这一点，但却不甚理想。对于像这样的线程间同步操作的需求是如此常见，以至于C++标准库提供了以<strong class="calibre3">条件变量（conditionvariables）</strong>
 和<strong class="calibre3">期值（future）</strong>
 为形式的工具来处理它。</p>
<p class="zw">在本章中，我将讨论如何使用条件变量和期值来等待事件，以及如何使用它们来简化操作的同步。</p>
<h2 id="nav_point_62" class="calibre11">4.1　等待事件或其他条件</h2>
<p class="zw">假设你正乘坐通宵列车旅行。一个可以确保你在正确的车站下车的方法就是整夜保持清醒并注意火车停靠的地方。你不会误站，但你到那儿时就会觉得很累。或者，你可以查一下时间表，了解火车会在何时到达，将闹钟定的稍微提前一点，然后去睡觉。这是可以的；你不会错过站，但是如果火车晚点了，你就会醒得太早。也有可能闹钟的电池没电了，你就会睡过头以至于错过站。理想的状况是，你只管去睡觉，让某个人或某个东西在火车到站时叫醒你，无论何时。</p>
<p class="zw">这如何与线程相关呢？那么，如果一个线程正等待着第二个线程完成一项任务，它有几个选择。首先，它可以一直检查共享数据（由互斥元保护）中的标识，并且让第二个线程在完成任务时设置该标识。这有两项浪费，线程占用了宝贵的处理时间去反复检查该标识，以及当互斥元被等待的线程锁定后，就不能被任何其他线程锁定。两者都反对线程进行等待，因为它们限制了等待中的线程的可用资源，甚至阻止它在完成任务时设置标识。这类似于整夜保持清醒地与火车司机交谈，他不得不把火车开得更慢，因为你一直在干扰他，所以需要更长的时间才能到达。同样的，等待中的线程消耗了本可以被系统中其他线程使用的资源，并且最终等待的时间可能会比所需的更长。</p>
<p class="zw">第二个选择是使用<code class="calibre10">std::this_thread::sleep_for()</code>
 函数（参见4.3节），让等待中的线程在检查之间休眠一会儿。</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00060.jpg" class="calibre15"/>
</p>
<p class="zw">在这个循环里，函数在休眠之前❷解锁该互斥元❶，并在之后再次锁定之❸，所以另一个线程有机会获取它并设置标识。</p>
<p class="zw">这是一个进步，因为线程在休眠时并不浪费处理时间，但得到正确的休眠时间是很难的。检查之间休眠得过短，线程仍然会浪费处理时间进行检查；休眠得过长，即使线程正在等待的任务已经完成，它还会继续休眠，导致延迟。这种过度休眠很少直接影响程序的操作，但它可能意味着在快节奏的游戏中丢帧，或者在实时应用程序中过度运行一个时间片。</p>
<p class="zw">第三个选择，同时也是首选选择，是使用C++标准库提供的工具来等待事件本身。等待由另一个线程触发一个事件的最基本机制（例如前面提到的管道中存在的额外操作）是<strong class="calibre3">条件变量（conditionvariable）</strong>
 。从概念上说，条件变量与某些事件或其他<strong class="calibre3">条件</strong>
 相关，并且一个或多个线程可以<strong class="calibre3">等待</strong>
 该条件被满足。当某个线程已经确定条件得到满足，它就可以<strong class="calibre3">通知</strong>
 一个或多个正在条件变量上进行等待的线程，以便唤醒它们并让它们继续处理。</p>
<h3 id="nav_point_63" class="calibre14">4.1.1　用条件变量等待条件</h3>
<p class="zw">标准C++库提供了<strong class="calibre3">两个</strong>
 条件变量的实现：<code class="calibre10">std::condition_variable</code>
 和<code class="calibre10">std::condition_variable_any</code>
 。这两个实现都在<code class="calibre10">&lt;condition_variable&gt;</code>
 库的头文件中声明。两者都需要和互斥元一起工作，以便提供恰当的同步；前者仅限于和<code class="calibre10">std::mutex</code>
 一起工作，而后者则可以与符合成为类似互斥元的最低标准的任何东西一起工作，因此以<code class="calibre10">any</code>
 为后缀。因为<code class="calibre10">std::condition_variable_any</code>
 更加普遍，所以会有大小、性能或者操作系统资源方面的形式的额外代价的可能，因此应该首选<code class="calibre10">std::condition_variable</code>
 ，除非需要额外的灵活性。</p>
<p class="zw">那么，如何使用<code class="calibre10">std::condition_variable</code>
 去处理引言中的例子——怎么让正在等待工作的线程休眠，直到有数据要处理？清单4.1展示了一种方法，你可以用条件变量来实现这一点。</p>
<p class="calibre17">
<strong class="calibre3">清单4.1　使用std::condition_variable等待数据</strong>
</p>
<p class="calibre16"><img alt="..\tu\69.tif" src="Image00061.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\70.tif" src="Image00062.gif" class="calibre15"/>
</p>
<p class="zw">首先，你拥有一个用来在两个线程之间传递数据的队列❶。当数据就绪时，准备数据的线程使用<code class="calibre10">std::lock_guard</code>
 去锁定保护队列的互斥元，并且将数据压入队列中❷。然后，它在<code class="calibre10">std::condition_variable</code>
 的实例上调用<code class="calibre10">notify_one()</code>
 成员函数，以通知等待中的线程（如果有的话）❸。</p>
<p class="zw">在另外一侧，你还有处理线程。该线程首先锁定互斥元，但是这次使用的是<code class="calibre10">std::unique_lock</code>
 而不是<code class="calibre10">std::lock_guard</code>
 ❹——你很快就会明白为什么。该线程接下来在<code class="calibre10">std::condition_variable</code>
 上调用<code class="calibre10">wait()</code>
 ，传入锁对象以及表示正在等待的条件的lambda函数❺。lambda函数是C++中的一个新功能，它允许你编写一个匿名函数作为另一个表达式的一部分，它们非常适合于为类似于<code class="calibre10">wait()</code>
 这样的标准库函数指定断言。在这个例子中，简单的lambda函数<code class="calibre10">[]{return !data_queue.empty();}</code>
 检查<code class="calibre10">data_queue</code>
 是否不为<code class="calibre10">empty()</code>
 ，即队列中已有数据准备处理。附录A，A.5节更加详细地描述了lambda函数。</p>
<p class="zw">
<code class="calibre10">wait()</code>
 的实现接下来检查条件（通过调用所提供的lambda函数），并在满足时返回（lambda函数返回<code class="calibre10">true</code>
 ）。如果条件不满足（lambda函数返回<code class="calibre10">false</code>
 ），<code class="calibre10">wait()</code>
 解锁互斥元，并将该线程置于阻塞或等待状态。当来自数据准备线程中对<code class="calibre10">notify_one()</code>
 的调用通知条件变量时，线程从睡眠状态中苏醒（解除其阻塞），重新获得互斥元上的锁，并再次检查条件，如果条件已经满足，就从<code class="calibre10">wait()</code>
 返回值，互斥元仍被锁定。如果条件不满足，该线程解锁互斥元，并恢复等待。这就是为什么需要<code class="calibre10">std::unique_lock</code>
 而不是<code class="calibre10">std：：lock_guard</code>
 ——等待中的线程在等待期间必须解锁互斥元，并在这之后重新将其锁定，而<code class="calibre10">std::lock_guard</code>
 没有提供这样的灵活性。如果互斥元在线程休眠期间始终被锁定，数据准备线程将无法锁定该互斥元，以便将项目添加至队列，并且等待中的线程将永远无法看到其条件得到满足。</p>
<p class="zw">清单4.1为等待使用了一个简单的lambda函数❺，该函数检查队列是否为非空的，但是任何函数或可调用对象都可以传入。如果你已经有一个函数来检查条件（也许因为它比这样一个简单的试验更加复杂），那么这个函数就可以直接传入，没有必要将其封装在lambda中。在对<code class="calibre10">wait()</code>
 的调用中，条件变量可能会对所提供的条件检查任意多次。然而，它总是在互斥元被锁定的情况下这样做，并且当（且仅当）用来测试条件的函数返回<code class="calibre10">true</code>
 ，它就会立即返回。当等待线程重新获取互斥元并检查条件时，如果它并非直接响应另一个线程的通知，这就是所谓的<strong class="calibre3">伪唤醒（spurious wake）</strong>
 。由于所有的这种伪唤醒的次数和频率根据定义是不确定的，所以使用对于条件检查具有副作用的函数是不可取的。如果你这样做，就必须做好多次产生副作用的准备。</p>
<p class="zw">解锁<code class="calibre10">std::unique_lock</code>
 的灵活性不仅适用于对<code class="calibre10">wait()</code>
 的调用；它还可用于你有待处理但仍未处理的数据❻。处理数据可能是一个耗时的操作，并且如你在第3章中看到的，在互斥元上持有锁超过所需的时间就是个不好的情况。</p>
<p class="zw">清单4.1所示的使用队列在线程之间传输数据，是很常见的场景。做得好的话，同步可以被限制在队列本身，大大减少了同步问题和竞争条件大概的数量。鉴于此，现在让我们从清单4.1中提取一个泛型的线程安全队列。</p>
<h3 id="nav_point_64" class="calibre14">4.1.2　使用条件变量建立一个线程安全队列</h3>
<p class="zw">如果你要设计一个泛型队列，花几分钟考虑一下可能需要的操作是值得的，就像你在3.2.3节对线程安全堆栈所做的那样。让我们看一看C++标准库来寻找灵感，以清单4.2所示的<code class="calibre10">std::queue&lt;&gt;</code>
 的容器适配器的形式。</p>
<p class="calibre17">
<strong class="calibre3">清单4.2　std::queue接口</strong>
</p>
<p class="calibre16"><img alt="..\tu\71.tif" src="Image00063.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\72a.tif" src="Image00064.gif" class="calibre15"/>
</p>
<p class="zw">如果忽略构造函数、赋值和交换操作，那么还剩下3组操作：查询整个队列的状态（<code class="calibre10">empty()</code>
 和<code class="calibre10">size()</code>
 ）、查询队列的元素（<code class="calibre10">front()</code>
 和<code class="calibre10">back()</code>
 ）以及修改队列（<code class="calibre10">push()</code>
 、<code class="calibre10">pop()</code>
 和<code class="calibre10">emplace()</code>
 ）。这些操作与你之前在3.2.3节中对堆栈的操作是相同的，因此你也遇到相同的有关接口中固有的竞争条件的问题。所以，你需要将<code class="calibre10">front()</code>
 和<code class="calibre10">pop()</code>
 组合到单个函数调用中，就像你为了堆栈而组合<code class="calibre10">top()</code>
 和<code class="calibre10">pop()</code>
 那样。清单4.1中的代码增加了新的细微差别，但是，当使用队列在线程间传递数据时，接收线程往往需要等待数据。我们为<code class="calibre10">pop()</code>
 提供了两个变体：<code class="calibre10">try_pop()</code>
 ，它试图从队列中弹出值，但总是立即返回（带有失败指示符），即使没有能获取到值。以及<code class="calibre10">wait_and_pop()</code>
 ，它会一直等待，直到有值要获取。如果将栈示例中的特征带到此处，则接口看起来如清单4.3所示。</p>
<p class="calibre17">
<strong class="calibre3">清单4.3　threadsafe_queue的接口</strong>
</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00065.jpg" class="calibre15"/>
</p>
<p class="zw">就像你为堆栈做的那样，减少构造函数并消除赋值以简化代码。如以前一样，还提供了<code class="calibre10">try_pop()</code>
 和<code class="calibre10">wait_and_pop()</code>
 的两个版本。<code class="calibre10">try_pop()</code>
 的第一个重载❶将获取到的值存储在引用变量中，所以它可以将返回值用作状态；如果它获取到值就返回<code class="calibre10">true</code>
 ，否则返回<code class="calibre10">false</code>
 （参见A.2节）。第二个重载❷不能这么做，因为它直接返回获取到的值。但是如果没有值可被获取，则返回的指针可以设置为<code class="calibre10">NULL</code>
 。</p>
<p class="zw">那么，所有这一切如何与清单4.1关联起来呢？嗯，你可以从那里提取<code class="calibre10">push()</code>
 以及<code class="calibre10">wait_and_pop()</code>
 的代码，如清单4.4所示。</p>
<p class="calibre17">
<strong class="calibre3">清单4.4　从清单4.1中提取push()和wait_and_pop()</strong>
</p>
<p class="calibre16"><img alt="..\tu\73.tif" src="Image00066.gif" class="calibre15"/>
</p>
<p class="zw">互斥元和条件变量现在包含在<code class="calibre10">threadsafe_queue</code>
 的实例中，所以不再需要单独的变量❶，并且调用<code class="calibre10">push()</code>
 不再需要外部的同步❷。此外，<code class="calibre10">wait_and_pop()</code>
 负责条件变量等待❸。</p>
<p class="zw">
<code class="calibre10">wait_and_pop()</code>
 的另一个重载现在很容易编写，其余的函数几乎可以一字不差地从清单3.5中的栈示例中复制过来。清单4.5展示了最终的队列实现。</p>
<p class="calibre17">
<strong class="calibre3">清单4.5　使用条件变量的线程安全队列的完整类定义</strong>
</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00067.jpg" class="calibre15"/>
</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00068.jpg" class="calibre15"/>
</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00069.jpg" class="calibre15"/>
</p>
<p class="zw">虽然<code class="calibre10">empty()</code>
 是一个<code class="calibre10">const</code>
 成员函数，并且拷贝构造函数的<code class="calibre10">other</code>
 参数是一个<code class="calibre10">const</code>
 引用，但是其他线程可能会有到该对象的非<code class="calibre10">const</code>
 引用，并调用可变的成员函数，所以我们仍然需要锁定互斥元。由于锁定互斥元是一种可变的操作，故互斥元对象必须标记为<code class="calibre10">mutable</code>
 ❶，以便其可以被锁定在<code class="calibre10">empty()</code>
 和拷贝构造函数中。</p>
<p class="zw">条件变量在多个线程等待同一个事件的场合也是很有用的。如果线程被用于划分工作负载，那么应该只有一个线程去响应通知，可以使用与清单4.1中所示完全相同的结构，只要运行多个数据处理线程的实例。当新的数据准备就绪，<code class="calibre10">notify_one()</code>
 的调用将触发其中一个正在执行<code class="calibre10">wait()</code>
 的线程去检查其条件，然后从<code class="calibre10">wait()</code>
 返回（因为你刚向<code class="calibre10">data_queue</code>
 中增加了一项）。谁也不能保证哪个线程会被通知到，即使是某个线程正在等待通知；所有的处理线程可能仍在处理数据。</p>
<p class="zw">另一种可能性是，多个线程正等待着同一个事件，并且它们都需要作出响应。这可能发生在共享数据正在初始化的场合下，处理线程都可以使用同一个数据，但需要等待其初始化完成（虽然有比这更好的机制，参见第3章中的3.3.1节），或者是线程需要等待共享数据更新的地方，比如周期性的重新初始化。在这些案例中，准备数据的线程可以在条件变量上调用<code class="calibre10">notify_all()</code>
 成员函数而不是<code class="calibre10">notify_one()</code>
 。顾名思义，这将导致<strong class="calibre3">所有</strong>
 当前执行着<code class="calibre10">wait()</code>
 的线程检查其等待中的条件。</p>
<p class="zw">如果等待线程只打算等待一次，那么当条件为<code class="calibre10">true</code>
 时它就不会再等待这个条件变量了，条件变量未必是同步机制的最佳选择。如果所等待的条件是一个特定数据块的可用性时，这尤其正确。在这个场景中，使用<strong class="calibre3">期值（future）</strong>
 可能会更合适。</p>
<h2 id="nav_point_65" class="calibre11">4.2　使用future等待一次性事件</h2>
<p class="zw">假设你要乘飞机去国外度假。在到达机场并且完成了各种值机手续后，你仍然需要等待航班准备登机的通知，也许要几个小时。当然，你可以找到一些方法来消磨时间，比如看书、上网或者在昂贵的机场咖啡厅吃东西，但是从根本上来说，你只是在等待一件事情：登机时间到了的信号。不仅如此，一个给定的航班只进行一次；你下次去度假的时候，就会等待不同的航班。</p>
<p class="zw">C++标准库使用<strong class="calibre3">future</strong>
 为这类一次性事件建模。如果一个线程需要等待特定的一次性事件，那么它就会获取一个future来代表这一事件。然后，该线程可以周期性地在这个future上等待一小段时间以检查事件是否发生（检查出发告示板），而在检查间隙执行其他的任务（在高价咖啡厅吃东西）。另外，它还可以去做另外一个任务，直到其所需的事件已发生才继续进行，随后就等待future变为<strong class="calibre3">就绪（ready）</strong>
 。future可能会有与之相关的数据（比如你的航班在哪个登机口登机），或可能没有。一旦事件已经发生（即future已变为<strong class="calibre3">就绪</strong>
 ），future就无法复位。</p>
<p class="zw">C++标准库中有两类future，是由<code class="calibre10">&lt;future&gt;</code>
 库的头文件中声明的两个类模板实现的：<strong class="calibre3">唯一future（unique futures，</strong>
 <code class="calibre10">std::future&lt;&gt;</code>
 <strong class="calibre3">）</strong>
 和<strong class="calibre3">共享future（shared futures，</strong>
 <code class="calibre10">std::shared_future&lt;&gt;</code>
 ）。这两个类模板是参照<code class="calibre10">std::unique_ptr</code>
 和<code class="calibre10">std::shared_ptr</code>
 建立的。<code class="calibre10">std::future</code>
 的实例是仅有的一个指向其关联事件的实例，而多个<code class="calibre10">std::shared_future</code>
 的实例则可以指向同一个事件。对后者而言，所有实例将同时变为<strong class="calibre3">就绪</strong>
 ，并且它们都可以访问所有与该事件相关联的数据。这些关联的数据，就是这两种future成为模板的原因；像<code class="calibre10">std::unique_ptr</code>
 和<code class="calibre10">std::shared_ptr</code>
 一样，模板参数就是关联数据的类型。<code class="calibre10">std:future&lt;void&gt;</code>
 、<code class="calibre10">std::shared_future&lt;void&gt;</code>
 模板特化应该用于无关联数据的场合。虽然future被用于线程间通信，但是future对象本身却并不提供同步访问。如果多个线程需要访问同一个future对象，它们必须通过互斥元或其他同步机制来保护访问，如第3章中所述。然而，正如你将在4.2.5节中看到的，多个线程可以分别访问自己的<code class="calibre10">std::shared_future&lt;&gt;</code>
 副本而无需进一步的同步，即使它们都指向同一个异步结果。</p>
<p class="zw">最基本的一次性事件是在后台运行着的计算结果。早在第2章中你就看到过<code class="calibre10">std::thread</code>
 并没有提供一种简单的从这一任务中返回值的方法，我保证这将在第4章中通过使用future加以解决——现在是时候去看看如何做了。</p>
<h3 id="nav_point_66" class="calibre14">4.2.1　从后台任务中返回值</h3>
<p class="zw">假设你有一个长期运行的计算，预期最终将得到一个有用的结果，但是现在，你还不需要这个值。也许你已经找到一种方法来确定生命、宇宙及万物的答案，这是从Douglas Adams<a id="ac41" href="text00015.html#anchor41" class="calibre6">
<sup class="calibre12">[1]</sup>
</a>
 那里偷来的一个例子。你可以启动一个新的线程来执行该计算，但这也意味着你必须注意将结果传回来，因为<code class="calibre10">std::thread</code>
 并没有提供直接的机制来这样做。这就是<code class="calibre10">std::async</code>
 函数模板（同样声明于<code class="calibre10">&lt;future&gt;</code>
 头文件中）的由来。</p>
<p class="zw">在不需要立刻得到结果的时候，你可以使用<code class="calibre10">std::async</code>
 来启动一个<strong class="calibre3">异步任务（asynchronoustask）</strong>
 。<code class="calibre10">std::async</code>
 返回一个<code class="calibre10">std::future</code>
 对象，而不是给你一个<code class="calibre10">std::thread</code>
 对象让你在上面等待，<code class="calibre10">std::future</code>
 对象最终将持有函数的返回值。当你需要这个值时，只要在future上调用<code class="calibre10">get()</code>
 ，线程就会阻塞直到future<strong class="calibre3">就绪</strong>
 ，然后返回该值。清单4.6展示了一个简单的例子。</p>
<p class="calibre17">
<strong class="calibre3">清单4.6　使用std::future获取异步任务的返回值</strong>
</p>
<p class="calibre16"><img alt="..\tu\77a.tif" src="Image00070.gif" class="calibre15"/>
</p>
<p class="zw">
<code class="calibre10">std::async</code>
 允许你通过将额外的参数添加到调用中，来将附加参数传递给函数，这与<code class="calibre10">std::thread</code>
 是同样的方式。如果第一个参数是指向成员函数的指针，第二个参数则提供了用来应用该成员函数的对象（直接地，或通过指针，或封装在<code class="calibre10">std::ref</code>
 中），其余的参数则作为参数传递给该成员函数。否则，第二个及后续的参数将作为参数，传递给第一个参数所指定的函数或可调用对象。和<code class="calibre10">std::thread</code>
 一样，如果参数是右值，则通过<strong class="calibre3">移动</strong>
 原来的参数来创建副本。这就允许使用只可移动的类型同时作为函数对象和参数。请看清单4.7。</p>
<p class="calibre17">
<strong class="calibre3">清单4.7　使用std::async来将参数传递给函数</strong>
</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00071.jpg" class="calibre15"/>
</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00072.jpg" class="calibre15"/>
</p>
<p class="zw">默认情况下，<code class="calibre10">std::async</code>
 是否启动一个新线程，或者在等待future时任务是否同步运行都取决于具体实现方式。在大多数情况下这就是你所想要的，但你可以在函数调用之前使用一个额外的参数来指定究竟使用何种方式。这个参数为<code class="calibre10">std::launch</code>
 类型，可以是<code class="calibre10">std::launch::deferred</code>
 ，以表明该函数调用将会延迟，直到在future上调用<code class="calibre10">wait()</code>
 或<code class="calibre10">get()</code>
 为止，或者是<code class="calibre10">std::launch::async</code>
 ，以表明该函数必须运行在它自己的线程上，又或者是<code class="calibre10">std::launch::deferred | std::launch::async</code>
 ，以表明可以由具体实现来选择。最后一个选项是默认的。如果函数调用被延迟，它有可能永远都不会实际运行。例如，</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00073.jpg" class="calibre15"/>
</p>
<p class="zw">正如你稍后将在本章看到，并将在第8章中再次看到的那样，使用<code class="calibre10">std::async</code>
 能够轻易地将算法转化成可以并行运行的任务。然而，这并不是将<code class="calibre10">std::future</code>
 与任务相关联的唯一方式；你还可以通过将任务封装在<code class="calibre10">std::packaged_task&lt;&gt;</code>
 类模板的一个实例中，或者通过编写代码，用<code class="calibre10">std::promise&lt;&gt;</code>
 类模板显式设置值等方式来实现。<code class="calibre10">std::packaged_task</code>
 是比<code class="calibre10">std::promise</code>
 更高层次的抽象，所以我将从它开始。</p>
<h3 id="nav_point_67" class="calibre14">4.2.2　将任务与future相关联</h3>
<p class="zw">
<code class="calibre10">std::packaged_task&lt;&gt;</code>
 将一个future绑定到一个函数或可调用对象上。当<code class="calibre10">std::packaged_task&lt;&gt;</code>
 对象被调用时，它就调用相关联的函数或可调用对象，并且让future<strong class="calibre3">就绪</strong>
 ，将返回值作为关联数据储存。这可以被用作线程池的构件（参见第9章），或者其他任务管理模式，例如在每个任务自己的线程上运行，或在一个特定的后台线程上按顺序运行所有任务。如果一个大型操作可以分成许多自包含的子任务，其中每一个都可以被封装在一个<code class="calibre10">std::packaged_task&lt;&gt;</code>
 实例中，然后将该实例传给任务调度器或线程池。这样就抽象出了任务的详细信息，调度程序仅需处理<code class="calibre10">std::packaged_task&lt;&gt;</code>
 实例，而非各个函数。</p>
<p class="zw">
<code class="calibre10">std::packaged_task&lt;&gt;</code>
 类模板的模板参数为函数签名，比如<code class="calibre10">void()</code>
 表示无参数无返回值的函数，或是像<code class="calibre10">int(std::string &amp;,double*)</code>
 表示接受对<code class="calibre10">std::string</code>
 的非<code class="calibre10">const</code>
 引用和指向<code class="calibre10">double</code>
 的指针，并返回<code class="calibre10">int</code>
 的函数。当你构造<code class="calibre10">std::packaged_task</code>
 实例的时候，你必须传入一个函数或可调用对象，它可以接受指定的参数并且返回指定的返回类型。类型无需严格匹配，你可以用一个接受<code class="calibre10">int</code>
 并返回<code class="calibre10">float</code>
 的函数构造<code class="calibre10">std::packaged_task&lt;double(double)&gt;</code>
 ，因为这些类型是可以隐式转换的。</p>
<p class="zw">指定的函数签名的返回类型确定了从<code class="calibre10">get_future()</code>
 成员函数返回的<code class="calibre10">std：：future&lt;&gt;</code>
 的类型，而函数签名的参数列表用来指定封装任务的函数调用运算符的签名。例如，<code class="calibre10">std::packaged_task&lt;std::string(std::vector&lt;char&gt;*,int)&gt;</code>
 的部分类定义如清单4.8所示。</p>
<p class="calibre17">
<strong class="calibre3">清单4.8　std::packaged_task&lt;&gt;特化的部分类定义</strong>
</p>
<p class="calibre16"><img alt="..\tu\79.tif" src="Image00074.gif" class="calibre15"/>
</p>
<p class="zw">该<code class="calibre10">std::packaged_task</code>
 对象是一个可调用对象，它可以被封装入一个<code class="calibre10">std::function</code>
 对象，作为线程函数传给<code class="calibre10">std::thread</code>
 ，或传给需要可调用对象的另一个函数，或者干脆直接调用。当<code class="calibre10">std::packaged_task</code>
 作为函数对象被调用时，提供给函数调用运算符的参数被传给所包含的函数，并且将返回值作为异步结果，存储在由<code class="calibre10">get_future()</code>
 获取的<code class="calibre10">std::future</code>
 中。因此，你可以将任务封装在<code class="calibre10">std::packaged_task</code>
 中，并且在把<code class="calibre10">std::packaged_task</code>
 对象传到别的地方进行适当调用之前获取future。当你需要结果时，你可以等待future变为就绪，清单4.9的例子实际展示了这一点。</p>
<h4 class="sigil_not_in_toc">在线程之间传递任务</h4>
<p class="zw">许多GUI框架要求从特定的线程来完成GUI的更新，所以，如果另一个线程需要更新GUI，它必须向正确的线程发送消息来实现这一点。<code class="calibre10">std::packaged_task</code>
 提供了一种更新GUI的方法，该方法无需为每个与GUI相关的活动获取自定义的消息。</p>
<p class="calibre17">
<strong class="calibre3">清单4.9　使用std::packaged_task在GUI线程上运行代码</strong>
</p>
<p class="calibre16"><img alt="..\tu\80.tif" src="Image00075.gif" class="calibre15"/>
</p>
<p class="zw">此代码非常简单：GUI线程❶循环直到收到通知GUI停止的消息❷，反复轮询待处理的GUI消息❸，比如用户点击，以及任务队列中的任务。如果队列中没有任务❹，则再次循环；否则，从任务队列中提取任务❺，解除队列中的锁，并运行任务❻。当任务完成时，与该任务相关联的future被设为就绪。</p>
<p class="zw">在队列上发布任务也同样简单：利用所提供的函数创建一个新的任务包❼，通过调用<code class="calibre10">get_future()</code>
 成员函数从任务中获取future❽，同时在返回future到调用处之前❾将任务置于列表之上❿。发出消息给GUI线程的代码如果需要知道任务已完成，则可以等待该future；若无需知道，则可以丢弃该future。</p>
<p class="zw">本示例中的任务使用<code class="calibre10">std:packaged_task&lt;void()&gt;</code>
 ，它封装了一个接受零参数且返回<code class="calibre10">void</code>
 的函数或可调用对象（如果它返回了别的东西，则返回值被丢弃）。这是最简单的任务，但如你在前面所看到的，<code class="calibre10">std:packaged_task</code>
 也可以用于更复杂的情况——通过指定一个不同的函数签名作为模板参数，你可以改变返回类型（以及在future的关联状态中存储的数据类型）和函数调用运算符的参数类型。这个示例可以进行简单的扩展，让那些在GUI线程上运行的任务接受参数，并且返回<code class="calibre10">std::future</code>
 中的值，而不是仅一个完成指示符。</p>
<p class="zw">那些无法用一个简单函数调用表达的任务和那些结果可能来自不止一个地方的任务又当如何？这些情况都可以通过第三种创建future的方式来处理：使用<code class="calibre10">std::promise</code>
 来显式地设置值。</p>
<h3 id="nav_point_68" class="calibre14">4.2.3　生成(std::)promise</h3>
<p class="zw">当有一个需要处理大量网络连接的应用程序时，通常倾向于在独立的线程上分别处理每个连接，因为这能使得网络通信更易于理解也更易于编程。这对于较低的连接数（因而线程数也较低）效果很好。然而，随着连接数的增加，这就变得不那么适合了；大量的线程就会消耗大量操作系统资源，并可能导致大量的上下文切换（当线程数超过了可用的硬件并发），进而影响性能。在极端情况下，操作系统可能会在其网络连接能力用尽之前，就为运行新的线程而耗尽资源。在具有超大量网络连接的应用程序中，通常用少量线程（可能仅有一个）来处理连接，每个线程一次处理多个连接。</p>
<p class="zw">考虑其中一个处理这种连接的线程。数据包将以基本上随机的顺序来自于待处理的各个连接，同样地，数据包将以随机顺序进行排队发送。在多数情况下，应用程序的其他部分将通过特定的网络连接，等待着数据被成功地发送或是新一批数据被成功地接收。</p>
<p class="zw">
<code class="calibre10">std::promise&lt;T&gt;</code>
 提供一种设置值（类型<code class="calibre10">T</code>
 ）方式，它可以在这之后通过相关联的<code class="calibre10">std::future&lt;T&gt;</code>
 对象进行读取。一对<code class="calibre10">std::promise</code>
 /<code class="calibre10">std::future</code>
 为这一设施提供了一个可能的机制；等待中的线程可以阻塞future，同时提供数据的线程可以使用配对中的promise项，来设置相关的值并使future<strong class="calibre3">就绪</strong>
 。</p>
<p class="zw">你可以通过调用<code class="calibre10">get_future()</code>
 成员函数来获取与给定的<code class="calibre10">std::promise</code>
 相关的<code class="calibre10">std::future</code>
 对象，比如<code class="calibre10">std::packaged_task</code>
 。当设置完promise的值（使用<code class="calibre10">set_value()</code>
 成员函数），future会变为<strong class="calibre3">就绪</strong>
 ，并且可以用来获取所存储的数值。如果销毁<code class="calibre10">std::promise</code>
 时未设置值，则将存入一个异常。4.2.4节描述了异常是如何跨线程转移的。</p>
<p class="zw">清单4.10展示了处理如前文所述的连接的示例代码。在这个例子中，使用一对<code class="calibre10">std::promise&lt;bool&gt;</code>
 /<code class="calibre10">std::future&lt;bool&gt;</code>
 对来标识一块传出数据的成功传输；与future关联的值就是一个简单的成功/失败标志。对于传入的数据包，与future关联的数据为数据包的负载。</p>
<p class="calibre17">
<strong class="calibre3">清单4.10　使用promise在单个线程中处理多个连接</strong>
</p>
<p class="calibre16"><img alt="..\tu\82.tif" src="Image00076.gif" class="calibre15"/>
</p>
<p class="zw">函数<code class="calibre10">process_connections()</code>
 一直循环到<code class="calibre10">done()</code>
 返回<code class="calibre10">true</code>
 ❶。每次循环中，轮流检查每个连接❷，在有传入数据时获取之❸或是发送队列中的传出数据❺。此处假定一个输入数据包具有ID和包含实际数据在内的负载。此ID被映射至<code class="calibre10">std::promise</code>
 （可能是通过在关联容器中进行查找）❹，并且该值被设为数据包的负载。对于传出的数据包，数据包取自传出队列，并实际上通过此连接发送。一旦发送完毕，与传出数据关联的promise被设为<code class="calibre10">true</code>
 以表示传输成功❻。此映射对于实际网络协议是否完好，取决于协议本身；这种promise/future风格的结构可能并不适用于某特定情况，尽管它确实与某些操作系统支持的异步I/O具有相似的结构。</p>
<p class="zw">迄今为止的所有代码完全忽略了异常。虽然想象一个万物都始终运转良好的世界是美好的，但却不切实际。有时候磁盘装满了，有时候你要找的东西恰好不在那里，有时候网络故障，有时数据库损坏。如果你正在需要结果的线程中执行操作，代码可能只是用异常报告了一个错误，因此仅仅因为你想用<code class="calibre10">std::packaged_task</code>
 或<code class="calibre10">std::promise</code>
 ，就限制性地要求所有事情都正常工作是不必要的。因此C++标准库提供一个简便的方式，来处理这种场景下的异常，并允许他们作为相关结果的一部分而保存。</p>
<h3 id="nav_point_69" class="calibre14">4.2.4　为future保存异常</h3>
<p class="zw">考率下面简短的代码片段。如果将 <code class="calibre10">-1</code>
 传入<code class="calibre10">square_root()</code>
 函数，会引发一个异常，同时将被调用者所看到。</p>
<p class="calibre16"><img alt="..\tu\83a.tif" src="Image00077.gif" class="calibre15"/>
</p>
<p class="zw">现在假设不是仅从当前线程调用<code class="calibre10">square_root()：</code>
</p>
<p class="calibre16"><img alt="..\tu\83b.tif" src="Image00078.gif" class="calibre15"/>
</p>
<p class="zw">而是以异步调用的形式运行调用：</p>
<p class="calibre16"><img alt="..\tu\83c.tif" src="Image00079.gif" class="calibre15"/>
</p>
<p class="zw">两者行为完全一致自然是最理想的；与<code class="calibre10">y</code>
 得到函数调用的任意一种结果一样，如果调用<code class="calibre10">f.get()</code>
 的线程能像在单线程情况下一样，能够看到里面的异常，那是极好的。</p>
<p class="zw">实际情况则是，如果作为<code class="calibre10">std::async</code>
 一部分的函数调用引发了异常，该异常会被储存在future中，代替所存储的值，future变为<strong class="calibre3">就绪</strong>
 ，并且对<code class="calibre10">get()</code>
 的调用会重新引发所存储的异常（注：重新引发的是原始异常对象抑或其副本，C++标准并没有指定，不同的编译器和库在此问题上作出了不同的选择）。这同样发生在将函数封装入<code class="calibre10">std::packaged_task</code>
 的时候——当任务被调用时，如果封装的函数引发异常，该异常代替结果存入future，准备在调用<code class="calibre10">get()</code>
 时引发。</p>
<p class="zw">顺理成章，<code class="calibre10">std::promise</code>
 在显式地函数调用下提供相同的功能。如果期望存储一个异常而不是一个值，则调用<code class="calibre10">set_exception()</code>
 成员函数而不是<code class="calibre10">set_value()</code>
 。这通常是在引发异常作为算法的一部分时用在<code class="calibre10">catch</code>
 块中，将该异常填入promise。</p>
<p class="calibre16"><img alt="..\tu\84a.tif" src="Image00080.gif" class="calibre15"/>
</p>
<p class="zw">这里使用<code class="calibre10">std::current_exception()</code>
 来获取已引发的异常。作为替代，可以使用<code class="calibre10">std::copy_exception()</code>
 直接存储新的异常而不对引发。</p>
<p class="calibre16"><img alt="..\tu\新建文件夹\84b.tif" src="Image00081.gif" class="calibre15"/>
</p>
<p class="zw">在异常的类型已知时，这比使用<code class="calibre10">try</code>
 /<code class="calibre10">catch</code>
 块更为简洁，并且应该优先使用，这不仅仅简化了代码，也为编译器提供更多的优化代码的机会。</p>
<p class="zw">另一种将异常存储至future的方式，是销毁与future关联的<code class="calibre10">std::promise</code>
 或<code class="calibre10">std::packaged_task</code>
 ，而无需在promise上调用设置函数或是调用打包任务。在任何一种情况下，如果future尚未<strong class="calibre3">就绪</strong>
 ，<code class="calibre10">std::promise</code>
 或<code class="calibre10">std::packaged_task</code>
 的析构函数会将具有<code class="calibre10">std::future_errc::broken_promise</code>
 错误代码的<code class="calibre10">std::future_error</code>
 异常存储在相关联的状态中。通过创建future，你承诺提供一个值或异常，而通过销毁该值或异常的来源，你违背了承诺。在这种情况下如果编译器没有将任何东西存进future，等待中的线程可能会永远等下去。</p>
<p class="zw">到目前为止，所有的例子都使用了<code class="calibre10">std::future</code>
 。然而，<code class="calibre10">std::future</code>
 有其局限性，最起码，只有一个线程能等待结果。如果需要多于一个的线程等待同一个事件，则需要使用<code class="calibre10">std::shared_future</code>
 来代替。</p>
<h3 id="nav_point_70" class="calibre14">4.2.5　等待自多个线程</h3>
<p class="zw">尽管<code class="calibre10">std::future</code>
 能处理从一个线程向另一线程转移数据所需的全部必要的同步，但是调用某个特定的<code class="calibre10">std::future</code>
 实例的成员函数却并没有相互同步。如果从多个线程访问单个<code class="calibre10">std::future</code>
 对象而不进行额外的同步，就会出现<strong class="calibre3">数据竞争</strong>
 和未定义行为。这是有意为之的，<code class="calibre10">std::future</code>
 模型统一了异步结果的所有权，同时<code class="calibre10">get()</code>
 的单发性质使得这样的并发访问没有意义——只有一个线程可以获取值，因为在首次调用<code class="calibre10">get()</code>
 后，就没有任何可获取的值留下了。</p>
<p class="zw">如果你的并发代码的绝妙设计要求多个线程能够等待同一个事件，目前还无需失去信心；<code class="calibre10">std::shared_future</code>
 完全能够实现这一点。鉴于<code class="calibre10">std::future</code>
 是仅<strong class="calibre3">可移动的</strong>
 ，所以所有权可以在实例间转移，但是一次只有一个实例指向特定的异步结果。<code class="calibre10">std::shared_future</code>
 实例是<strong class="calibre3">可复制的</strong>
 ，因此可以有多个对象引用同一个相关状态。</p>
<p class="zw">现在，即便有了<code class="calibre10">std::shared_future</code>
 ，各个对象的成员函数仍然是不同步的，所以为了避免从多个线程访问单个对象时出现数据竞争，必须使用锁来保护访问。首选的使用方式，是用一个对象的副本来代替，并且让每个线程访问自己的副本。从多个线程访问共享的异步状态，如果每个线程都是通过自己的<code class="calibre10">std::shared_future</code>
 对象去访问该状态，那么就是安全的，见图4.1。</p>
<p class="calibre8"><img alt="..\14-1316(tu)\04-01.tif" src="Image00082.gif" class="calibre15"/>
</p>
<p class="tu_ti">图4.1　使用多个std::shared_future对象避免数据竞争</p>
<p class="zw">
<code class="calibre10">std::shared_future</code>
 的一个潜在用处，是实现类似复杂电子表格的并行执行。每个单元都有一个单独的终值，可以被多个其他单元格中的公式使用。用来计算各个单元格结果的公式可以使用<code class="calibre10">std::shared_future</code>
 来引用第一个单元。如果所有独立单元格的公式被并行执行，那些可以继续完成的任务可以进行，而那些依赖于其他单元格的公式将阻塞，直到其依赖关系准备就绪。这就使得系统能最大限度地利用可用的硬件并发。</p>
<p class="zw">引用了异步状态的<code class="calibre10">std::shared_future</code>
 实例可以通过引用这些状态的<code class="calibre10">std::future</code>
 实例来构造。由于<code class="calibre10">std::future</code>
 对象不和其他对象共享异步状态的所有权，因此该所有权必须通过<code class="calibre10">std::move</code>
 转移到<code class="calibre10">std::shared_future</code>
 ，将<code class="calibre10">std::future</code>
 留在空状态，就像它被默认构造了一样。</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00083.jpg" class="calibre15"/>
</p>
<p class="zw">此处，future <code class="calibre10">f</code>
 刚开始是有效的❶，因为它引用了promise <code class="calibre10">p</code>
 的异步状态，但是将状态转移至<code class="calibre10">sf</code>
 后，<code class="calibre10">f</code>
 不再有效❷，而<code class="calibre10">sf</code>
 有效❸。</p>
<p class="zw">正如其他可移动的对象那样，所有权的转移对于右值是隐式的，因此可以从<code class="calibre10">std::promise</code>
 对象的<code class="calibre10">get_future()</code>
 成员函数的返回值直接构造一个<code class="calibre10">std::shared_future</code>
 ，例如</p>
<p class="calibre16"><img alt="图像说明文字" src="Image00084.jpg" class="calibre15"/>
</p>
<p class="zw">此处，所有权的转移是隐式的，<code class="calibre10">std::shared_future&lt;&gt;</code>
 根据<code class="calibre10">std::future&lt;std::string&gt;</code>
 类型的右值进行构造❶。</p>
<p class="zw">
<code class="calibre10">std::future</code>
 具有一个额外特性，即从变量的初始化自动推断变量类型的功能，使得<code class="calibre10">std::shared_future</code>
 的使用更加方便（参见附录A中A.6节）。<code class="calibre10">std::future</code>
 具有一个<code class="calibre10">share()</code>
 成员函数，可以构造一个新的<code class="calibre10">std::shared_future</code>
 ，并且直接将所有权转移给它。这可以节省大量的录入，也使代码更易于更改。</p>
<p class="calibre16"><img alt="..\tu\86b.tif" src="Image00085.gif" class="calibre15"/>
</p>
<p class="zw">这种情况下，<code class="calibre10">sf</code>
 的类型被推断为相当拗口的<code class="calibre10">std::shared_future&lt;std::map&lt;SomeIndexType,SomeDataType,SomeComparator,SomeAllocator&gt;::iterator&gt;</code>
 。如果比较器或分配器改变了，仅需改变promise的类型，future的类型将自动更新以匹配。</p>
<p class="zw">有些时候，你会想要限制等待事件的时长，无论是因为某段代码能够占用的时间有着硬性的限制，还是因为如果事件不会很快发生，线程就可以去做其他有用的工作。为了处理这个功能，许多等待函数具有能够指定超时的变量。</p>
<h2 id="nav_point_71" class="calibre11">4.3　有时间限制的等待</h2>
<p class="zw">前面介绍的所有阻塞调用都会阻塞一个不确定的时间段，挂起线程直至等待的事件发生。在许多情况下这是没问题的，但在某些情况下你会希望给等待时间加一个限制。这就使得能够发送某种形式的“我还活着”的消息给交互用户或者另一个进程，或是在用户已经放弃等待并且按下取消键时，干脆放弃等待。</p>
<p class="zw">有两类可供指定的超时：一为<strong class="calibre3">基于时间段</strong>
 的超时，即等待一个指定的时间长度（例如30ms），或是<strong class="calibre3">绝对</strong>
 超时，即等到一个指定的时间点（例如世界标准时间2011年11月30日17:30:15.045987023）。大多数等待函数提供处理这两种形式超时的变量，处理基于时间段超时的变量具有_<code class="calibre10">for</code>
 后缀，而处理绝对超时的变量具有_<code class="calibre10">until</code>
 后缀。</p>
<p class="zw">例如，<code class="calibre10">std::condition_variable</code>
 具有两个重载版本的<code class="calibre10">wait_for()</code>
 成员函数和两个重载版本的<code class="calibre10">wait_until()</code>
 成员函数，对应于两个重载版本的<code class="calibre10">wait()</code>
 ——一个重载只是等待到收到信号，或超时，或发生伪唤醒；另一个重载在唤醒时检测所给的断言，并只在所给的断言为true（以及条件变量已收到信号）或超时的情况下才返回。</p>
<p class="zw">在细看使用超时的函数之前，让我们从时钟开始，看一看在C++中是如何指定时间的。</p>
<h3 id="nav_point_72" class="calibre14">4.3.1　时钟</h3>
<p class="zw">就C++标准库所关注的而言，时钟是时间信息的来源。具体来说，时钟是提供以下四个不同部分信息的类。</p>
<ul class="calibre13">
<li class="di_1ji_wu_xu_lie_biao">
<strong class="calibre3">现在（now）</strong>
 <span class="calibre18">时间。</span>
</li>
<li class="di_1ji_wu_xu_lie_biao">
<span class="calibre18">用来表示从时钟获取到的时间值的类型。</span>
</li>
<li class="di_1ji_wu_xu_lie_biao">
<span class="calibre18">时钟的节拍周期。</span>
</li>
<li class="di_1ji_wu_xu_lie_biao">
<span class="calibre18">时钟是否以均匀的速率进行计时，决定其是否为<strong class="calibre3">匀速（steady）</strong>
 时钟。</span>
</li>
</ul>
<p class="zw">时钟的当前时间可以通过调用该时钟类的静态成员函数<code class="calibre10">now()</code>
 来获取。例如，<code class="calibre10">std::chrono::system_clock::now()</code>
 返回系统时钟的当前时间。对于具体某个时钟的时间点类型，是通过<code class="calibre10">time_point</code>
 成员的<code class="calibre10">typedef</code>
 来指定的，因此<code class="calibre10">some_clock::now()</code>
 的返回类型是<code class="calibre10">some_clock::time_point</code>
 。</p>
<p class="zw">时钟的节拍周期是由分数秒指定的，它由时钟的<code class="calibre10">period</code>
 成员<code class="calibre10">typedef</code>
 给出——每秒走25拍的时钟，就具有<code class="calibre10">std::ratio&lt;1,25&gt;</code>
 的<code class="calibre10">period</code>
 ，而每2.5秒走一拍的时钟则具有<code class="calibre10">std::ratio&lt;5,2&gt;</code>
 的<code class="calibre10">period</code>
 。如果时钟的节拍周期直到运行时方可知晓，或者可能所给的应用程序运行期间可变，则<code class="calibre10">period</code>
 可以指定为平均的节拍周期、最小可能的节拍周期，或是编写类库的人认为合适的一个值。在所给的一次程序的执行中，无法保证观察到的节拍周期与该时钟所指定的<code class="calibre10">period</code>
 相符。</p>
<p class="zw">如果一个时钟<strong class="calibre3">以均匀速率计时</strong>
 （无论该时速是否匹配<code class="calibre10">period</code>
 ）且<strong class="calibre3">不能被调整</strong>
 ，则该时钟被称为<strong class="calibre3">匀速（steady）</strong>
 时钟。如果时钟是匀速的，则时钟类的<code class="calibre10">is_steady</code>
 静态数据成员为<code class="calibre10">true</code>
 ，反之为<code class="calibre10">false</code>
 。通常情况下，<code class="calibre10">std::chrono::system_clock</code>
 是<strong class="calibre3">不</strong>
 匀速的，因为时钟可以调整，考虑到本地时钟漂移，这种调整甚至是自动执行的。这样的调整可能会引起调用<code class="calibre10">now()</code>
 所返回的值，比之前调用<code class="calibre10">now()</code>
 所返回的值更早，这违背了均匀计时速率的要求。如你马上要看到的那样，匀速时钟对于计算超时来说非常重要，因此C++标准库提供形式为<code class="calibre10">std::chrono::steady_clock</code>
 的匀速时钟。由C++标准库提供的其他时钟包括<code class="calibre10">std::chrono::system_clock</code>
 （上文已提到），它代表系统的“真实时间”时钟，并为时间点和<code class="calibre10">time_t</code>
 值之间的相互转换提供函数，还有<code class="calibre10">std::chrono::high_resolution_clock</code>
 ，它提供所有类库时钟中最小可能的节拍周期（和可能的最高精度）。它实际上可能是其他时钟之一的<code class="calibre10">typedef</code>
 。这些时钟与其他时间工具都定义在<code class="calibre10">&lt;chrono&gt;</code>
 类库头文件中。</p>
<p class="zw">我们马上要看看如何表示时间点，但在此之前，先来看看时间段是如何表示的。</p>
<h3 id="nav_point_73" class="calibre14">4.3.2　时间段</h3>
<p class="zw">时间段是时间支持中的最简单部分，它们是由<code class="calibre10">std::chrono::duration&lt;&gt;</code>
 类模板（线程库使用的所有C++时间处理工具均位于<code class="calibre10">std::chrono</code>
 的命名空间中）进行处理的。第一个模板参数为所代表类型（如<code class="calibre10">int</code>
 、<code class="calibre10">long</code>
 、或<code class="calibre10">double</code>
 ）；第二个参数是个分数，指定每个时间段单位表示多少秒。例如，以<code class="calibre10">short</code>
 类型存储的几分钟的数目表示为<code class="calibre10">std::chrono::duration&lt;short,std::ratio&lt;60,1&gt;&gt;</code>
 ，因为1分钟有60秒。另一方面，以<code class="calibre10">double</code>
 类型存储的毫秒数则表示为<code class="calibre10">std::chrono::duration&lt;double,std::ratio&lt;1,1000&gt;&gt;</code>
 ，因为1毫秒为1/1000秒。</p>
<p class="zw">标准库在<code class="calibre10">std::chrono</code>
 命名空间中为各种时间段提供了一组预定义的<code class="calibre10">typedef</code>
 ：<code class="calibre10">nanoseconds</code>
 、<code class="calibre10">microseconds</code>
 、<code class="calibre10">milliseconds</code>
 、<code class="calibre10">seconds</code>
 、<code class="calibre10">minutes</code>
 和<code class="calibre10">hours</code>
 。它们均使用一个足够大的整数类型以供表示，以至于如果你希望的话，可以使用合适的单位来表示超过500<strong class="calibre3">年</strong>
 的时间段。还有针对所有国际单位比例的<code class="calibre10">typedef</code>
 可供指定自定义时间段时使用，从<code class="calibre10">std::atto</code>
 （10<sup class="calibre12">−18</sup>
 ）至<code class="calibre10">std::exa</code>
 （10<sup class="calibre12">18</sup>
 ）（还有更大的，若你的平台具有128位整型类型），例如<code class="calibre10">std::duration&lt;double,std::centi&gt;</code>
 是以<code class="calibre10">double</code>
 类型表示的1/100秒的计时。</p>
<p class="zw">在无需截断值的场合，时间段之间的转换是隐式的（因此将小时转换成秒是可以的，但将秒转换成小时则不然）。显式转换可以通过<code class="calibre10">std::chrono::duration_cast&lt;&gt;</code>
 实现：</p>
<p class="calibre16"><img alt="..\tu\89a.tif" src="Image00086.gif" class="calibre15"/>
</p>
<p class="zw">结果是截断而非四舍五入，因此在此例中<code class="calibre10">s</code>
 值为54。</p>
<p class="zw">时间段支持算术运算，因此可以加、减时间段来得到新的时间段，或者可以乘、除一个底层表示类型（第一个模板参数）的常数。因此<code class="calibre10">5*seconds(1)</code>
 和<code class="calibre10">seconds(5)</code>
 或<code class="calibre10">minutes(1)-seconds(55)</code>
 是相同的。时间段中单位数量的计数可以通过<code class="calibre10">count()</code>
 成员函数获取。因此<code class="calibre10">std::chrono::milliseconds(1234).count()</code>
 为1234。</p>
<p class="zw">基于时间段的等待是通过<code class="calibre10">std::chrono::duration&lt;&gt;</code>
 实例完成的。例如，可以等待future就绪最多35毫秒。</p>
<p class="calibre16"><img alt="..\tu\89b.tif" src="Image00087.gif" class="calibre15"/>
</p>
<p class="zw">等待函数都会返回一个状态以表示等待是否超时，或者所等待的事件是否发生。在这种情况下，你在等待一个future，若等待超时，函数返回<code class="calibre10">std::future_status:: timeout</code>
 ，若future就绪，则返回<code class="calibre10">std::future_status::ready</code>
 ，或者如果future任务推迟，则返回<code class="calibre10">std::future_status::deferred</code>
 。基于时间段的等待使用类库内部的匀速时钟来衡量时间，因此35毫秒意味着35毫秒的逝去时间，即便系统时钟在等待期间进行了调整（向前或向后）。当然，系统调度的多变和OS时钟的不同精度意味着线程之间发出调用并返回的实际时间可能远远长于35毫秒。</p>
<p class="zw">在看过时间段后，接下可以继续看看时间点。</p>
<h3 id="nav_point_74" class="calibre14">4.3.3　时间点</h3>
<p class="zw">时钟的时间点是通过<code class="calibre10">std::chrono::time_point&lt;&gt;</code>
 类模板的实例来表示的，它以第一个模板参数指定其参考的时钟，并且以第二个模板参数指定计量单位（<code class="calibre10">std::chrono::duration&lt;&gt;</code>
 的特化）。时间点的值是时间的长度（指定时间段的倍数），因而一个特定时间点被称为时钟的<strong class="calibre3">纪元（epoch）</strong>
 。时钟的纪元是一项基本参数，但却不能直接查询，也未被C++标准指定。典型的纪元包括1970年1月1日00:00，以及运行应用程序的计算机引导启动的瞬间。时钟可以共享纪元或拥有独立的纪元。如果两个时钟共享一个纪元，则在一个类中的<code class="calibre10">time_point typedef</code>
 可指定另一个类作为与<code class="calibre10">time_point</code>
 相关联的时钟类型。虽然无法找出纪元的时间所在，但<strong class="calibre3">可以</strong>
 获取给定<code class="calibre10">time_point</code>
 的<code class="calibre10">time_since_epoch()</code>
 。该成员函数返回一个时间段的值，其指定了从时钟纪元到该时间点的时间长度。</p>
<p class="zw">例如，你可以指定一个时间点为<code class="calibre10">std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::minutes&gt;</code>
 。这将保持时间与系统时钟相关，但却以分钟而不是系统时钟的固有测量精度（通常为秒或更小）进行测量。</p>
<p class="zw">你可以从<code class="calibre10">std::chrono::time_point&lt;&gt;</code>
 的实例加上和减去时间段来产生新的时间点，因此<code class="calibre10">std::chrono::high_resolution_clock::now()+ std::chrono::nanoseconds(500)</code>
 将在future中给你500纳秒的时间。这对于在知道代码块的最大时间段情况下计算绝对超时是极好的，但若其中有对等待函数的多个调用，或是在等待函数之前有非等待函数，就会占据一部分时间预算。</p>
<p class="zw">你还可以从另一个共享同一个时钟的时间点减去一个时间点。结果为指定两个时间点之间长度的时间段。这对于代码块的计时非常有用，例如，</p>
<p class="calibre16"><img alt="..\tu\90a.tif" src="Image00088.gif" class="calibre15"/>
</p>
<p class="zw">然而<code class="calibre10">std::chrono::time_point&lt;&gt;</code>
 实例的时钟参数能做的不仅仅是指定纪元。当你将时间点传给到接受绝对超时的等待函数时，时间点的时钟参数可以用来测量时间。当时钟改变时会产生一个重要的影响，因为这一等待会跟踪时钟的改变，并且在时钟的<code class="calibre10">now()</code>
 函数返回一个晚于指定超时的值之前都不会返回。如果时钟向前调整，将减少等待的总长度（按照匀速时钟计量），反之如果向后调整，就可能增加等待的总长度。</p>
<p class="zw">如你所料，时间点和等待函数的_<code class="calibre10">until</code>
 变种共同使用。典型用例是在用作从程序中一个固定点的<strong class="calibre3">某个时钟</strong>
 <code class="calibre10">::now()</code>
 开始的偏移量，尽管与系统时钟相关联的时间点可以通过在对用户可见的时间，用<code class="calibre10">std::chrono::system_clock::to_time_point()</code>
 静态成员函数从<code class="calibre10">time_t</code>
 转换而来。例如，如果有一个最大值为500毫秒的时间，来等待一个与条件变量相关的事件，你可以按清单4.11所示来做。</p>
<p class="calibre17">
<strong class="calibre3">清单4.11　等待一个具有超时的条件变量</strong>
</p>
<p class="calibre16"><img alt="..\tu\90b.tif" src="Image00089.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\91.tif" src="Image00090.gif" class="calibre15"/>
</p>
<p class="zw">如果没有向等待传递断言，那么这是在有时间限制下等待条件变量的推荐方式。这种方式下，循环的总长度是有限的。如4.1.1节所示，当不传入断言时，需要通过循环来使用条件变量，以便处理伪唤醒。如果在循环中使用<code class="calibre10">wait_for()</code>
 ，可能在伪唤醒前，就已结束等待几乎全部时长，并且在经过下一次等待开始后再来一次。这可能会重复任意次，使得总的等待时间无穷无尽。</p>
<p class="zw">在看过了指定超时的基础知识后，让我们来看看能够使用超时的函数。</p>
<h3 id="nav_point_75" class="calibre14">4.3.4　接受超时的函数</h3>
<p class="zw">超时的最简单用法，是将延迟添加到特定线程的处理过程中，以便在它无所事事的时候避免占用其他线程的处理时间。在4.1节你曾见过这样的例子，在循环中轮询一个“完成”标记。处理它的两个函数是<code class="calibre10">std::this_thread::sleep_for()</code>
 和<code class="calibre10">std::this_thread::sleep_until()</code>
 。它们像一个基本的闹钟一样工作：在指定时间段（使用<code class="calibre10">sleep_for()</code>
 ）或直至指定的时间点（使用<code class="calibre10">sleep_until()</code>
 ），线程进入睡眠状态。<code class="calibre10">sleep_for()</code>
 对于那些类似于4.1节中的例子是有意义的，其中一些事情必须周期性地进行，并且逝去的时间是重要的。另一方面，<code class="calibre10">sleep_until()</code>
 允许安排线程在特定时间点唤醒。这可以用来触发半夜里的备份，或在早上6:00打印工资条，或在做视频回放时暂停线程直至下一帧的刷新。</p>
<p class="zw">当然，睡眠并不是唯一的接受超时的工具。你已经看到了可以将超时与条件变量和future一起使用。如果互斥元支持的话，甚至可以试图在互斥元获得锁时使用超时。普通的<code class="calibre10">std::mutex</code>
 和<code class="calibre10">std::recursive_mutex</code>
 并不支持锁定上的超时，但是<code class="calibre10">std::timed_mutex</code>
 和<code class="calibre10">std::recursive_timed_mutex</code>
 支持。这两种类型均支持<code class="calibre10">try_lock_for()</code>
 和<code class="calibre10">try_lock_until()</code>
 成员函数，它们可以在指定时间段内或在指定时间点之前尝试获取锁。表4.1展示了C++标准库中可以接受超时的函数及其参数和返回值。列作<strong class="calibre3">时间段（duration）</strong>
 的参数必须为<code class="calibre10">std::duration&lt;&gt;</code>
 的实例，而那些列作<code class="calibre10">time_poin</code>
 t的必须为<code class="calibre10">std::time_point&lt;&gt;</code>
 的实例。</p>
<p class="biao_ti">表4.1　接受超时的函数</p>
<table border="1" width="90%" class="calibre19">
<thead class="calibre20">
<tr class="calibre21">
<th class="calibre22">
<p class="calibre2">类/命名空间</p>
</th>
<th class="calibre22">
<p class="calibre2">函数</p>
</th>
<th class="calibre22">
<p class="calibre2">返回值</p>
</th>
</tr>
</thead>
<tbody class="calibre23">
<tr class="calibre21">
<td class="calibre24">
<p class="calibre2">std::this_thread命名空间</p>
</td>
<td class="calibre24">
<p class="calibre2">sleep_for(<em class="calibre9">duration</em>
 ) sleep_until(<em class="calibre9">time_point</em>
 )</p>
</td>
<td class="calibre24">
<p class="calibre2">不可用</p>
</td>
</tr>
<tr class="calibre25">
<td class="calibre24">
<p class="calibre2">std::condition_variable或std::condition_variable_any</p>
</td>
<td class="calibre24">
<p class="calibre2">wait_for(<em class="calibre9">lock, duration</em>
 ) wait_until(<em class="calibre9">lock, time_point</em>
 )</p>
</td>
<td class="calibre24">
<p class="calibre2">std::cv_status::timeout或 std::cv_status::no_timeout</p>
</td>
</tr>
<tr class="calibre21">
<td class="calibre24"><p class="calibre2"/>
</td>
<td class="calibre24">
<p class="calibre2">wait_for(<em class="calibre9">lock, duration, predicate</em>
 ) wait_until(<em class="calibre9">lock, time_point, predicate</em>
 )</p>
</td>
<td class="calibre24">
<p class="calibre2">bool—当唤醒时<strong class="calibre3">predicate</strong>
 的返回值</p>
</td>
</tr>
<tr class="calibre25">
<td class="calibre24">
<p class="calibre2">std::timed_mutex或std::recursive_timed_mutex</p>
</td>
<td class="calibre24">
<p class="calibre2">try_lock_for(<em class="calibre9">duration</em>
 ) try_lock_until(<em class="calibre9">time_point</em>
 )</p>
</td>
<td class="calibre24">
<p class="calibre2">bool—true如果获得了锁，否则false</p>
</td>
</tr>
<tr class="calibre21">
<td class="calibre24">
<p class="calibre2">std::unique_lock&lt;TimedLockable&gt;</p>
</td>
<td class="calibre24">
<p class="calibre2">unique_lock(<em class="calibre9">lockable,duration</em>
 ) unique_lock(<em class="calibre9">lockable,time_point</em>
 )</p>
</td>
<td class="calibre24">
<p class="calibre2">不可用—owns_lock()在新构造的对象上；如果获得了锁返回true，否则false</p>
</td>
</tr>
<tr class="calibre25">
<td class="calibre24"><p class="calibre2"/>
</td>
<td class="calibre24">
<p class="calibre2">try_lock_for(<em class="calibre9">duration</em>
 ) try_lock_until(<em class="calibre9">time_point</em>
 )</p>
</td>
<td class="calibre24">
<p class="calibre2">bool—true如果获得了锁，否则false</p>
</td>
</tr>
<tr class="calibre21">
<td class="calibre24">
<p class="calibre2">std::future&lt;<em class="calibre9">ValueType</em>
 &gt;或std::shared_ future&lt;<em class="calibre9">ValueType</em>
 &gt;</p>
</td>
<td class="calibre24">
<p class="calibre2">wait_for(<em class="calibre9">duration</em>
 ) wait_until(<em class="calibre9">time_point</em>
 )</p>
</td>
<td class="calibre24">
<p class="calibre2">std::future_status::timeout如果等待超时，std::future_status::ready如果future就绪或std::future_status::deferred如果future持有的延迟函数还没有开始</p>
</td>
</tr>
</tbody>
</table>
<p class="zw">目前，我已经介绍了条件变量、future、promise和打包任务的机制，接下来是时候看一看更广的图景，以及如何利用它们来简化线程间操作的同步。</p>
<h2 id="nav_point_76" class="calibre11">4.4　使用操作同步来简化代码</h2>
<p class="zw">使用截至目前在本章中描述的同步工具作为构建模块，允许你着重关注需要同步的操作而非机制。一种可以简化代码的方式，是采用一种更加<strong class="calibre3">函数式的（functional，</strong>
 在<strong class="calibre3">函数式编程</strong>
 意义上）的方法来编写并发程序。并非直接在线程之间共享数据，而是每个任务都可以提供它所需要的数据，并通过使用future将结果传播至需要它的线程。</p>
<h3 id="nav_point_77" class="calibre14">4.4.1　带有future的函数式编程</h3>
<p class="zw">
<strong class="calibre3">函数式编程（functionalprogramming, FP）</strong>
 指的是一种编程风格，函数调用的结果仅单纯依赖于该函数的参数而不依赖于任何外部状态。这与函数的数学概念相关，同时也意味着如果用同一个参数执行一个函数两次，结果是完全一样的。这是许多C++标准库中数学函数，如<code class="calibre10">sin</code>
 、<code class="calibre10">cos</code>
 和<code class="calibre10">sqrt</code>
 ，以及基本类型简单操作如<code class="calibre10">3+3</code>
 、<code class="calibre10">6*9</code>
 、或<code class="calibre10">1.3</code>
 /<code class="calibre10">4.7</code>
 的特性。<strong class="calibre3">纯</strong>
 函数也不<strong class="calibre3">修改</strong>
 任何外部状态，函数的影响完全局限在返回值上。</p>
<p class="zw">这使得事情变得易于思考，尤其当涉及并发时，因为第3章中讨论的许多与共享内存相关的问题不复存在。如果没有修改共享数据，那么就不会有竞争条件，因此也就没有必要使用互斥元来保护共享数据。这是一个如此强大的简化，使得诸如Haskell<a id="ac42" href="text00015.html#anchor42" class="calibre6">
<sup class="calibre12">[2]</sup>
</a>
 这样的编程语言，在<strong class="calibre3">默认情况</strong>
 下其所有函数都是纯函数，开始在编写并发系统中变得更为流行。因为大多数东西都是纯的，实际上<strong class="calibre3">的确</strong>
 修改共享状态的<strong class="calibre3">非纯</strong>
 函数就显得鹤立鸡群，因而也更易于理解它们是如何纳入应用程序整体结构的。</p>
<p class="zw">然而函数式编程的好处不仅仅局限在那些将其作为默认范型的语言。C++是一种多范型语言，它完全可以用FP风格编写程序。随着lambda函数（参见附录A中A.6节）的到来，从Boost到TR1的<code class="calibre10">std::bind</code>
 合并，和自动变量类型推断的引入（参见附录A中A.7节），C++11比C++98更为容易实现函数式编程。future是使得C++中FP风格的并发切实可行的最后一块拼图。一个future可以在线程间来回传递，使得一个线程的计算结果依赖于另一个的结果，<strong class="calibre3">而无需任何对共享数据的显式访问</strong>
 。</p>
<h4 class="sigil_not_in_toc">1．FP风格快速排序</h4>
<p class="zw">为了说明在FP风格并发中future的使用，让我们来看一个简单的快速排序算法的实现。算法的基本思想很简单，给定一列值，取一个元素作为中轴，然后将列表分为两组——比中轴小的为一组，大于等于中轴的为一组。列表的已排序副本，可以通过对这两组进行排序，并按照先是比中轴小的值已排序列表，接着是中轴，再后返回大于等于中轴的值已排序列表的顺序进行返回来获取。图4.2展示了10个整数的列表是如何根据此步骤进行排序的。FP风格的顺序实现在随后的代码中展示；它通过值的形式接受并返回列表，而不是像<code class="calibre10">std::sort()</code>
 那样就地排序。</p>
<p class="calibre8"><img alt="..\14-1316(tu)\04-02.tif" src="Image00091.gif" class="calibre15"/>
</p>
<p class="tu_ti">图4.2　FP风格递归排序</p>
<p class="calibre17">
<strong class="calibre3">清单4.12　快速排序的顺序实现</strong>
</p>
<p class="calibre16"><img alt="..\tu\94.tif" src="Image00092.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\95a.tif" src="Image00093.gif" class="calibre15"/>
</p>
<p class="zw">尽管接口是FP风格的，如果你自始至终使用FP风格，就会制作很多的副本，即你在内部使用了“标准”祈使风格。取出第一个元素作为中轴，方法是用<code class="calibre10">splice()</code>
 ❶将其从列表前端切下。虽然这样可能会导致一个次优排序（考虑到比较和交换的次数），由于列表遍历的缘故，用<code class="calibre10">std::list</code>
 做任何其他事都可能增加很多的时间。你已知要在结果中得到它，因此可以直接将其拼接至将要使用的列表中。现在，你还会想要将其作比较，因此让我们对它进行引用，以避免复制❷。接着可以使用<code class="calibre10">std::partition</code>
 将序列划分成<strong class="calibre3">小于</strong>
 中轴的值和<strong class="calibre3">不</strong>
 小于中轴的值❸。指定划分依据的最简单方式是使用一个lambda函数；使用引用捕获以避免复制<code class="calibre10">pivot</code>
 的值（参见附录A中A.5节更多地了解lambda函数）。</p>
<p class="zw">
<code class="calibre10">std::partition()</code>
 就地重新排列列表，并返回一个迭代器，它标记着第一个<strong class="calibre3">不</strong>
 小于中轴值的元素。迭代器的完整类型可能相当冗长，因此可以使用<code class="calibre10">auto</code>
 类型说明符，使得编译器帮你解决（参见附录A中A.7节）。</p>
<p class="zw">现在，你已经选择了FP风格接口，因此如果打算使用递归来排序这两“半”，则需要创建两个列表。可以通过再次使用<code class="calibre10">splice()</code>
 将从<code class="calibre10">input</code>
 到<code class="calibre10">divide_point</code>
 的值移动至一个新的列表：<code class="calibre10">lower_part</code>
 ❹。这使得<code class="calibre10">input</code>
 中只仅留下剩余的值。你可以接着用递归调用对这两个列表进行排序❺、❻。通过使用<code class="calibre10">std::move()</code>
 传入列表，也可以在此处避免复制——但是结果也将被隐式地移动出来。最后，你可以再次使用<code class="calibre10">splice()</code>
 将<code class="calibre10">result</code>
 以正确的顺序连起来。<code class="calibre10">new_higher</code>
 值在中轴之后直到末尾❼，而<code class="calibre10">new_lower</code>
 值从开始起，直到中轴之前❽。</p>
<h4 class="sigil_not_in_toc">2．FP风格并行快速排序</h4>
<p class="zw">由于已经使用了函数式风格，通过future将其转换成并行版本就很容易了，如清单4.13所示。这组操作与之前相同，区别在于其中一部分现在并行地运行。此版本使用future和函数式风格实现快速排序算法。</p>
<p class="calibre17">
<strong class="calibre3">清单4.13　使用future的并行快速排序</strong>
</p>
<p class="calibre16"><img alt="..\tu\95b.tif" src="Image00094.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\96.tif" src="Image00095.gif" class="calibre15"/>
</p>
<p class="zw">这里最大的变化是，没有在当前线程中对较小的部分进行排序，而是在另一个线程中使用<code class="calibre10">std::async()</code>
 对其进行排序❶。列表的上部分跟之前一样直接递归❷进行排序。通过递归调用<code class="calibre10">parallel_quick_sort()</code>
 ，你可以充分利用现有的硬件并发能力。如果<code class="calibre10">std::async()</code>
 每次启动一个新的线程，那么如果你向下递归三次，就会有8个线程在运行；如果向下递归10次（对大约1000个元素），如果硬件可以处理的话，就将有1024个线程在运行。如果类库认定产生了过多的任务（也许是因为任务的数量超过了可用的硬件并发能力），则可能改为同步地产生新任务。他们会在调用<code class="calibre10">get()</code>
 的线程中运行，而不是在新的线程中，从而避免在不利于性能的情况下把任务传递到另一个线程的开销。值得注意的是，对于<code class="calibre10">std::async</code>
 的实现来说，只有显式指定了<code class="calibre10">std::launch::deferred</code>
 再为每一个任务开启一个新线程（甚至在面对大量的过度订阅时），或是只有显式指定了<code class="calibre10">std::launch::async</code>
 再同步运行所有任务，才是完全符合的。如果依靠类库进行自动判定，建议你查阅一下这一实现的文档，看一看它究竟表现出什么样的行为。</p>
<p class="zw">与其使用<code class="calibre10">std::async()</code>
 ，不如自行编写<code class="calibre10">spawn_task()</code>
 函数作为<code class="calibre10">std::packaged_task</code>
 和<code class="calibre10">std::thread</code>
 的简单封装，如清单4.14所示，为函数调用结果创建了一个<code class="calibre10">std::packaged_task</code>
 ，从中获取future，在线程中运行之并返回future。其本身并不会带来多少优点（实际上可能导致大量的过度订阅），但它为迁移到一个更复杂的实现做好准备，它通过一个工作线程池，将任务添加到一个即将运行的队列里。我们会在第9章研究线程池。相比于使用<code class="calibre10">std::async</code>
 ，只有在你确实知道将要做什么，并且希望想要通过线程池建立的方式进行完全掌控和执行任务的时候，才值得首选这种方法。</p>
<p class="zw">总之，回到<code class="calibre10">parallel_quick_sort</code>
 。因为只是使用直接递归获取<code class="calibre10">new_higher</code>
 ，你可以将其拼接到之前的位置❸。但是现在<code class="calibre10">new_lower</code>
 是<code class="calibre10">std::future&lt;std::list&lt;T&gt;&gt;</code>
 而不仅是列表，因此需要在调用<code class="calibre10">splice()</code>
 之前调用<code class="calibre10">get()</code>
 来获取值❹。这就会等待后台任务完成，并将结果<strong class="calibre3">移动</strong>
 至<code class="calibre10">splice()</code>
 调用；<code class="calibre10">get()</code>
 返回一个引用了所包含结果的右值，所以它可以被移除（参见附录A中A.1.1节更多地了解右值引用和移动语义）。</p>
<p class="zw">即使假设<code class="calibre10">std::async()</code>
 对可用的硬件并发能力进行最优化的使用，这仍不是快速排序的理想并行实现。原因之一是，<code class="calibre10">std::partition</code>
 完成了很多工作，且仍为一个连续调用，但对于目前已经足够好了。如果你对最快可能的并行实现有兴趣，请查阅学术文献。</p>
<p class="calibre17">
<strong class="calibre3">清单4.14　一个简单spawn_task的实现</strong>
</p>
<p class="calibre16"><img alt="..\tu\97.tif" src="Image00096.gif" class="calibre15"/>
</p>
<p class="zw">函数式编程并不是唯一的避开共享可变数据的并发编程范式；另一种范式为CSP（Communicating Sequential Process，通信顺序处理）<a id="ac43" href="text00015.html#anchor43" class="calibre6">
<sup class="calibre12">[3]</sup>
</a>
 ，这种范式下线程在概念上完全独立，没有共享数据，但是具有允许消息在它们之间进行传递的通信通道。这是被编程语言Erlang（<a href="http://www.erlang.org/" class="calibre6">http://www.erlang.org/</a>
 ）所采用的范式，也通常被MPI（Message Passing Interface，消息传递接口）（<a href="http://www.mpi-forum.org/" class="calibre6">http://www.mpi-forum.org/</a>
 ）环境用于C和C++中的高性能计算。我可以肯定到目前为止，你不会对这在C++中也可以在一些准则下得到支持而感到意外，接下来的一节将讨论实现这一点的一种方式。</p>
<h3 id="nav_point_78" class="calibre14">4.4.2　具有消息传递的同步操作</h3>
<p class="zw">CSP的思想很简单：如果没有共享数据，则每一个线程可以完全独立地推理得到，只需基于它对所接收到的消息如何进行反应。因此每个线程实际上可以等效为一个状态机：当它接收到消息时，它会根据初始状态进行操作，并以某种方式更新其状态，并可能向其他线程发送一个或多个消息。编写这种线程的一种方式，是将其形式化并实现一个有限状态机模型，但这并不是唯一的方式。状态机在应用程序结构中可以是隐式的。在任一给定的情况下，究竟哪种方法更佳，取决于具体形势的行为需求和编程团队的专长。但是选择实现每一个线程，则将其分割成独立的进程可能会从共享数据并发中移除很多复杂性，因而使得编程更加容易，降低了错误率。</p>
<p class="zw">真正的通信序列进程并不共享数据，所有的通信都通过消息队列，但由于C++线程共享一个地址空间，因此不可能强制执行这一需求。这就是准则介入的地方。作为应用程序或类库的作者，我们的责任是确保我们不在线程间共享数据。当然，为了线程之间的通信，消息队列必须是共享的，但是其细节可以封装在类库内。</p>
<p class="zw">想象一下，你正在实现ATM的代码。此代码需要处理人试图取钱的交互和与相关银行的交互，还要控制物理机器接受此人的卡片，显示恰当的信息，处理按键，出钞并退回用户的卡片。</p>
<p class="zw">处理这一切事情的其中一种方法，是将代码分成三个独立的线程：一个处理物理机器、一个处理ATM逻辑、还有一个与银行进行通信。这些线程可以单纯地通过传递消息而非共享数据进行通信。例如，当有人在机器旁边将卡插入或按下按钮时，处理机器的线程可以发送消息至逻辑线程，同时逻辑线程将发送消息至机器线程，指示要发多少钱等等。</p>
<p class="zw">对ATM逻辑进行建模的一种方式，是将其视为一个状态机。在每种状态中，线程等待可接受的消息，然后对其进行处理。这样可能会转换到一个新的状态，并且循环继续。一个简单实现中所涉及的状态如图4.3所示。在这个简化了的实现中，系统等待卡片插入。一旦卡片插入，便等待用户输入其密码，每次一个数字。他们可以删除最后输入的数字。一旦输入的数字足够多，就验证密码。如果密码错误，则结束，将卡片退回给用户，并继续等待有人插入卡片。如果密码正确，则等待用户取消交易或选择取出的金额。如果用户取消，则结束，并退出银行卡。如果用户选择了一个金额，则等待银行确认后发放现金并退出其卡片，或者显示“资金不足”的消息并退出其卡片。显然，真正的ATM比这复杂得多，但这已经足以阐述整个想法。</p>
<p class="calibre8"><img alt="..\14-1316(tu)\04-03.tif" src="Image00097.gif" class="calibre15"/>
</p>
<p class="tu_ti">图4.3　ATM的简单状态机模型</p>
<p class="zw">有了ATM逻辑的状态机设计之后，就可以使用一个具有表示每一个状态的成员函数的类来实现之。每一个成员函数都可以等待指定的一组传入消息，并在它们到达后进行处理，其中可能触发切换到另一状态。每个不同的消息类型可以由一个独立的<code class="calibre10">struct</code>
 来表示。清单4.15展示了这样一个系统中ATM逻辑的部分简单实现，包括主循环和第一个状态的实现，即等待卡片插入。</p>
<p class="zw">如你所见，所有消息传递所必需的同步完全隐藏于消息传递库内部（其基本实现以及本示例的完整代码见附录C）。</p>
<p class="calibre17">
<strong class="calibre3">清单4.15　ATM逻辑类的简单实现</strong>
</p>
<p class="calibre16"><img alt="..\tu\99.tif" src="Image00098.gif" class="calibre15"/>
</p>
<p class="calibre16"><img alt="..\tu\100.tif" src="Image00099.gif" class="calibre15"/>
</p>
<p class="zw">正如已经提到的，这里所描述的实现是从ATM所需的真正逻辑中粗略简化而来的，但这确实给你一种消息传递的编程风格的感受。没有必要去考虑同步和并发的问题，只要考虑在任意一个给定的店，可能会接收到哪些消息，以及该发送哪些消息。ATM逻辑的状态机在单线程上运行，而系统的其他部分，比如银行的接口和终端的接口，则在独立的线程上运行。这种程序设计风格被称作行为<strong class="calibre3">角色模型（actormodel）</strong>
 ——系统中有多个离散的<strong class="calibre3">角色</strong>
 （均运行在独立线程上），用来相互发送消息以完成手头任务，除了直接通过消息传递的状态外，没有任何共享状态。</p>
<p class="zw">执行是由<code class="calibre10">run()</code>
 成员函数开始的❺，设置初始状态为<code class="calibre10">waiting_for_card</code>
 ❻并重复执行代表当前状态（不管它是什么）的成员函数❼。状态函数就是<code class="calibre10">atm</code>
 类的简单成员函数。<code class="calibre10">waiting_for_card</code>
 状态函数❶也很简单：发送一则消息至界面以显示“等待卡片”的消息❷，接着等待要处理的消息。这里能处理的唯一消息类型是<code class="calibre10">card_inserted</code>
 消息❸，可以通过lambda函数进行处理❹。你可以将任意函数或函数对象传递给<code class="calibre10">handle</code>
 函数，但是像这种简单的情况，用lambda是最容易的。注意<code class="calibre10">handle()</code>
 函数调用是链接至<code class="calibre10">wait()</code>
 函数的。如果接收到的消息不匹配指定的类型，它将被丢弃，线程将继续等待直至接收到匹配的消息。</p>
<p class="zw">lambda函数本身只是将卡片中的账户号码缓存至一个成员变量中，清除当前密码，发送消息给接口硬件以显示要求用户输入其密码，改为“获取密码”状态。一旦消息处理程序完成，状态函数即返回，同时主循环调用新的状态函数❼。</p>
<p class="zw">
<code class="calibre10">getting_pin</code>
 状态函数略有些复杂，它可以处理三种不同类型的消息，如图4.3所示。由清单4.16加以展示。</p>
<p class="calibre17">
<strong class="calibre3">清单4.16　简单ATM实现的getting_pin状态函数</strong>
</p>
<p class="calibre16"><img alt="..\tu\101.tif" src="Image00100.gif" class="calibre15"/>
</p>
<p class="zw">这时，有三种能够处理的消息类型，所以<code class="calibre10">wait()</code>
 函数有三个<code class="calibre10">handle()</code>
 调用链接至结尾❶、❷、❸。每一次对<code class="calibre10">handle()</code>
 的调用将消息类型指定为模板参数，然后传至接受该特定消息类型作为参数的lambda函数。由于调用通过这种方式链接起来，<code class="calibre10">wait()</code>
 的实现知道它正在等待一个<code class="calibre10">digit_pressed</code>
 消息、<code class="calibre10">clear_last_pressed</code>
 消息或是<code class="calibre10">cancel_pressed</code>
 消息。任何其他类型的消息将再次被丢弃。</p>
<p class="zw">这时，在获取消息之后你并不一定非要改变状态。例如，如果你得到了一个<code class="calibre10">digit_pressed</code>
 消息，仅需将它添加至<code class="calibre10">pin</code>
 ，除非它为最后的数字。清单4.15中的主循环❼将再次调用<code class="calibre10">getting_pin()</code>
 来等待下一个数字（或是清除或取消）。</p>
<p class="zw">这对应于图4.3所示的行为。每一个状态框通过不同的成员函数来实现，它们等待相关的消息并适当地更新状态。</p>
<p class="zw">如你所见，这种编程风格可以大大简化设计并发系统的任务，因为每个线程可以完全独立地对待。这就是使用多线程来划分关注点的一个例子，并且需要你明确决定如何在线程间划分任务。</p>
<h2 id="nav_point_79" class="calibre11">4.5　小结</h2>
<p class="zw">线程间的同步操作，是编写一个使用并发的应用程序的重要组成部分。如果没有同步，那么线程本质上是独立的，就可以被写作独立的应用程序，由于它们之间存在相关活动而作为群组运行。在本章中，我介绍了同步操作的各种方式，从最基本条件变量，到future、promise以及打包任务。我还讨论了解决同步问题的方式，函数式编程，其中每个任务产生的结果完全依赖于它的输入而不是外部环境，以及消息传递，其中线程间的通信是通过一个扮演中介角色的消息子系统发送异步消息来实现的。</p>
<p class="zw">我们已经讨论了许多在C++中可用的高阶工具，现在是时候来看看令这一切得以运转的底层工具了：C++内存模型和原子操作。</p>
<hr class="calibre4"/>
<p class="calibre2">
<a id="anchor41" href="text00015.html#ac41" class="calibre6">[1]</a>
 在<em class="calibre9">The Hitchhiker’s Guide to the Galaxy</em>
 一书中，计算机Deep Thought被建造是用于决定“生命、宇宙和万物的答案”。答案是42。</p>
<p class="calibre2">
<a id="anchor42" href="text00015.html#ac42" class="calibre6">[2]</a>
 参见<a href="http://www.haskell.org/" class="calibre6">http://www.haskell.org/</a>
 。</p>
<p class="calibre2">
<a id="anchor43" href="text00015.html#ac43" class="calibre6">[3]</a>
 <em class="calibre9">Communicating Sequential Processes</em>
 , C.A.R. Hoare, Prentice Hall, 1985. Available free online at <a href="http://www.usingcsp.com/cspbook.pdf" class="calibre6">http://www.usingcsp.com/cspbook.pdf</a>
</p>
<p class="zw"><br class="calibre7"/>
</p>
<div class="calibre5"></div>



  </div>

  
  <div class="calibreToc">
    <h2><a href="../../1w54d-4vylw.html">Table of contents
</a></h2>
    <div>
  <ul>
    <li>
      <a href="text00002.html">版权信息</a>
    </li>
    <li>
      <a href="text00003.html#nav_point_0">版权声明</a>
    </li>
    <li>
      <a href="text00004.html#nav_point_1">内容提要</a>
    </li>
    <li>
      <a href="text00005.html#nav_point_2">序</a>
    </li>
    <li>
      <a href="text00006.html#nav_point_3">译者简介</a>
    </li>
    <li>
      <a href="text00008.html#nav_point_4">致谢</a>
    </li>
    <li>
      <a href="text00009.html#nav_point_5">前言</a>
      <ul>
        <li>
          <a href="text00009.html#nav_point_6">路线图</a>
        </li>
        <li>
          <a href="text00009.html#nav_point_7">谁应该阅读本书</a>
        </li>
        <li>
          <a href="text00009.html#nav_point_8">如何使用本书</a>
        </li>
        <li>
          <a href="text00009.html#nav_point_9">代码约定和下载</a>
        </li>
        <li>
          <a href="text00009.html#nav_point_10">软件需求</a>
        </li>
        <li>
          <a href="text00009.html#nav_point_11">作者在线</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00010.html#nav_point_12">资源</a>
      <ul>
        <li>
          <a href="text00010.html#nav_point_13">印刷资源</a>
        </li>
        <li>
          <a href="text00010.html#nav_point_14">在线资源</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00011.html#nav_point_15">简要目录</a>
    </li>
    <li>
      <a href="text00012.html#nav_point_16">第1章 你好，C++并发世界</a>
      <ul>
        <li>
          <a href="text00012.html#nav_point_17">1.1 什么是并发</a>
          <ul>
            <li>
              <a href="text00012.html#nav_point_18">1.1.1 计算机系统中的并发</a>
            </li>
            <li>
              <a href="text00012.html#nav_point_19">1.1.2 并发的途径</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00012.html#nav_point_20">1.2 为什么使用并发</a>
          <ul>
            <li>
              <a href="text00012.html#nav_point_21">1.2.1 为了划分关注点而使用并发</a>
            </li>
            <li>
              <a href="text00012.html#nav_point_22">1.2.2 为了性能而使用并发</a>
            </li>
            <li>
              <a href="text00012.html#nav_point_23">1.2.3 什么时候不使用并发</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00012.html#nav_point_24">1.3 在C++中使用并发和多线程</a>
          <ul>
            <li>
              <a href="text00012.html#nav_point_25">1.3.1 C++多线程历程</a>
            </li>
            <li>
              <a href="text00012.html#nav_point_26">1.3.2 新标准中的并发支持</a>
            </li>
            <li>
              <a href="text00012.html#nav_point_27">1.3.3 C++线程库的效率</a>
            </li>
            <li>
              <a href="text00012.html#nav_point_28">1.3.4 平台相关的工具</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00012.html#nav_point_29">1.4 开始入门</a>
          <ul>
            <li>
              <a href="text00012.html#nav_point_30">你好，并发世界</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00012.html#nav_point_31">1.5 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00013.html#nav_point_32">第2章 管理线程</a>
      <ul>
        <li>
          <a href="text00013.html#nav_point_33">2.1 基本线程管理</a>
          <ul>
            <li>
              <a href="text00013.html#nav_point_34">2.1.1 启动线程</a>
            </li>
            <li>
              <a href="text00013.html#nav_point_35">2.1.2 等待线程完成</a>
            </li>
            <li>
              <a href="text00013.html#nav_point_36">2.1.3 在异常环境下的等待</a>
            </li>
            <li>
              <a href="text00013.html#nav_point_37">2.1.4 在后台运行线程</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00013.html#nav_point_38">2.2 传递参数给线程函数</a>
        </li>
        <li>
          <a href="text00013.html#nav_point_39">2.3 转移线程的所有权</a>
        </li>
        <li>
          <a href="text00013.html#nav_point_40">2.4 在运行时选择线程数量</a>
        </li>
        <li>
          <a href="text00013.html#nav_point_41">2.5 标识线程</a>
        </li>
        <li>
          <a href="text00013.html#nav_point_42">2.6 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00014.html#nav_point_43">第3章 在线程间共享数据</a>
      <ul>
        <li>
          <a href="text00014.html#nav_point_44">3.1 线程之间共享数据的问题</a>
          <ul>
            <li>
              <a href="text00014.html#nav_point_45">3.1.1 竞争条件</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_46">3.1.2 避免有问题的竞争条件</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00014.html#nav_point_47">3.2 用互斥元保护共享数据</a>
          <ul>
            <li>
              <a href="text00014.html#nav_point_48">3.2.1 使用C++中的互斥元</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_49">3.2.2 为保护共享数据精心组织代码</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_50">3.2.3 发现接口中固有的竞争条件</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_51">3.2.4 死锁：问题和解决方案</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_52">3.2.5 避免死锁的进一步指南</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_53">3.2.6 用std::unique_lock灵活锁定</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_54">3.2.7 在作用域之间转移锁的所有权</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_55">3.2.8 锁定在恰当的粒度</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00014.html#nav_point_56">3.3 用于共享数据保护的替代工具</a>
          <ul>
            <li>
              <a href="text00014.html#nav_point_57">3.3.1 在初始化时保护共享数据</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_58">3.3.2 保护很少更新的数据结构</a>
            </li>
            <li>
              <a href="text00014.html#nav_point_59">3.3.3 递归锁</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00014.html#nav_point_60">3.4 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00015.html#nav_point_61">第4章 同步并发操作</a>
      <ul>
        <li>
          <a href="text00015.html#nav_point_62">4.1 等待事件或其他条件</a>
          <ul>
            <li>
              <a href="text00015.html#nav_point_63">4.1.1 用条件变量等待条件</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_64">4.1.2 使用条件变量建立一个线程安全队列</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00015.html#nav_point_65">4.2 使用future等待一次性事件</a>
          <ul>
            <li>
              <a href="text00015.html#nav_point_66">4.2.1 从后台任务中返回值</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_67">4.2.2 将任务与future相关联</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_68">4.2.3 生成(std::)promise</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_69">4.2.4 为future保存异常</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_70">4.2.5 等待自多个线程</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00015.html#nav_point_71">4.3 有时间限制的等待</a>
          <ul>
            <li>
              <a href="text00015.html#nav_point_72">4.3.1 时钟</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_73">4.3.2 时间段</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_74">4.3.3 时间点</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_75">4.3.4 接受超时的函数</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00015.html#nav_point_76">4.4 使用操作同步来简化代码</a>
          <ul>
            <li>
              <a href="text00015.html#nav_point_77">4.4.1 带有future的函数式编程</a>
            </li>
            <li>
              <a href="text00015.html#nav_point_78">4.4.2 具有消息传递的同步操作</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00015.html#nav_point_79">4.5 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00016.html#nav_point_80">第5章 C++内存模型和原子类型上操作</a>
      <ul>
        <li>
          <a href="text00016.html#nav_point_81">5.1 内存模型基础</a>
          <ul>
            <li>
              <a href="text00016.html#nav_point_82">5.1.1 对象和内存位置</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_83">5.1.2 对象、内存位置以及并发</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_84">5.1.3 修改顺序</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00016.html#nav_point_85">5.2 C++中的原子操作及类型</a>
          <ul>
            <li>
              <a href="text00016.html#nav_point_86">5.2.1 标准原子类型</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_87">5.2.2 std::atomic_flag上的操作</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_88">5.2.3 基于std::atomic&lt;bool&gt;的操作</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_89">5.2.4 std::atomic&lt;T*&gt;上的操作：指针算术运算</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_90">5.2.5 标准原子整型的操作</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_91">5.2.6 std::atomic&lt;&gt;初级类模板</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_92">5.2.7 原子操作的自由函数</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00016.html#nav_point_93">5.3 同步操作和强制顺序</a>
          <ul>
            <li>
              <a href="text00016.html#nav_point_94">5.3.1 synchronizes-with关系</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_95">5.3.2 happens-before关系</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_96">5.3.3 原子操作的内存顺序</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_97">5.3.4 释放序列和synchronizes-with</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_98">5.3.5 屏障</a>
            </li>
            <li>
              <a href="text00016.html#nav_point_99">5.3.6 用原子操作排序非原子操作</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00016.html#nav_point_100">5.4 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00017.html#nav_point_101">第6章 设计基于锁的并发数据结构</a>
      <ul>
        <li>
          <a href="text00017.html#nav_point_102">6.1 为并发设计的含义是什么</a>
          <ul>
            <li>
              <a href="text00017.html#nav_point_103">为并发设计数据结构的准则</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00017.html#nav_point_104">6.2 基于锁的并发数据结构</a>
          <ul>
            <li>
              <a href="text00017.html#nav_point_105">6.2.1 使用锁的线程安全栈</a>
            </li>
            <li>
              <a href="text00017.html#nav_point_106">6.2.2 使用锁和条件变量的线程安全队列</a>
            </li>
            <li>
              <a href="text00017.html#nav_point_107">6.2.3 使用细粒度锁和条件变量的线程安全队列</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00017.html#nav_point_108">6.3 设计更复杂的基于锁的数据结构</a>
          <ul>
            <li>
              <a href="text00017.html#nav_point_109">6.3.1 编写一个使用锁的线程安全查找表</a>
            </li>
            <li>
              <a href="text00017.html#nav_point_110">6.3.2 编写一个使用锁的线程安全链表</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00017.html#nav_point_111">6.4 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00018.html#nav_point_112">第7章 设计无锁的并发数据结构</a>
      <ul>
        <li>
          <a href="text00018.html#nav_point_113">7.1 定义和结果</a>
          <ul>
            <li>
              <a href="text00018.html#nav_point_114">7.1.1 非阻塞数据结构的类型</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_115">7.1.2 无锁数据结构</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_116">7.1.3 无等待的数据结构</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_117">7.1.4 无锁数据结构的优点与缺点</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00018.html#nav_point_118">7.2 无锁数据结构的例子</a>
          <ul>
            <li>
              <a href="text00018.html#nav_point_119">7.2.1 编写不用锁的线程安全栈</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_120">7.2.2 停止恼人的泄漏：在无锁数据结构中管理内存</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_121">7.2.3 用风险指针检测不能被回收的结点</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_122">7.2.4 使用引用计数检测结点</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_123">7.2.5 将内存模型应用至无锁栈</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_124">7.2.6 编写不用锁的线程安全队列</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00018.html#nav_point_125">7.3 编写无锁数据结构的准则</a>
          <ul>
            <li>
              <a href="text00018.html#nav_point_126">7.3.1 准则：使用std::memory_order_seq_cst作为原型</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_127">7.3.2 准则：使用无锁内存回收模式</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_128">7.3.3 准则：当心ABA问题</a>
            </li>
            <li>
              <a href="text00018.html#nav_point_129">7.3.4 准则：识别忙于等待的循环以及辅助其他线程</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00018.html#nav_point_130">7.4 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00019.html#nav_point_131">第8章 设计并发代码</a>
      <ul>
        <li>
          <a href="text00019.html#nav_point_132">8.1 在线程间划分工作的技术</a>
          <ul>
            <li>
              <a href="text00019.html#nav_point_133">8.1.1 处理开始前在线程间划分数据</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_134">8.1.2 递归地划分数据</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_135">8.1.3 以任务类型划分工作</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00019.html#nav_point_136">8.2 影响并发代码性能的因素</a>
          <ul>
            <li>
              <a href="text00019.html#nav_point_137">8.2.1 有多少个处理器？</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_138">8.2.2 数据竞争和乒乓缓存</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_139">8.2.3 假共享</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_140">8.2.4 数据应该多紧密</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_141">8.2.5 过度订阅和过多的任务切换</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00019.html#nav_point_142">8.3 为多线程性能设计数据结构</a>
          <ul>
            <li>
              <a href="text00019.html#nav_point_143">8.3.1 为复杂操作划分数组元素</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_144">8.3.2 其他数据结构中的数据访问方式</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00019.html#nav_point_145">8.4 为并发设计时的额外考虑</a>
          <ul>
            <li>
              <a href="text00019.html#nav_point_146">8.4.1 并行算法中的异常安全</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_147">8.4.2 可扩展性和阿姆达尔定律</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_148">8.4.3 用多线程隐藏延迟</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_149">8.4.4 用并发提高响应性</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00019.html#nav_point_150">8.5 在实践中设计并发代码</a>
          <ul>
            <li>
              <a href="text00019.html#nav_point_151">8.5.1 std::for_each的并行实现</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_152">8.5.2 std::find的并行实现</a>
            </li>
            <li>
              <a href="text00019.html#nav_point_153">8.5.3 std::partial_sum的并行实现</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00019.html#nav_point_154">8.6 总结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00020.html#nav_point_155">第9章 高级线程管理</a>
      <ul>
        <li>
          <a href="text00020.html#nav_point_156">9.1 线程池</a>
          <ul>
            <li>
              <a href="text00020.html#nav_point_157">9.1.1 最简单的线程池</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_158">9.1.2 等待提交给线程池的任务</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_159">9.1.3 等待其他任务的任务</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_160">9.1.4 避免工作队列上的竞争</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_161">9.1.5 工作窃取</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00020.html#nav_point_162">9.2 中断线程</a>
          <ul>
            <li>
              <a href="text00020.html#nav_point_163">9.2.1 启动和中断另一个线程</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_164">9.2.2 检测一个线程是否被中断</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_165">9.2.3 中断等待条件变量</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_166">9.2.4 中断在std::condition_variable_any上的等待</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_167">9.2.5 中断其他阻塞调用</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_168">9.2.6 处理中断</a>
            </li>
            <li>
              <a href="text00020.html#nav_point_169">9.2.7 在应用退出时中断后台任务</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00020.html#nav_point_170">9.3 总结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00021.html#nav_point_171">第10章 多线程应用的测试与调试</a>
      <ul>
        <li>
          <a href="text00021.html#nav_point_172">10.1 并发相关错误的类型</a>
          <ul>
            <li>
              <a href="text00021.html#nav_point_173">10.1.1 不必要的阻塞</a>
            </li>
            <li>
              <a href="text00021.html#nav_point_174">10.1.2 竞争条件</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00021.html#nav_point_175">10.2 定位并发相关的错误的技巧</a>
          <ul>
            <li>
              <a href="text00021.html#nav_point_176">10.2.1 审阅代码以定位潜在的错误</a>
            </li>
            <li>
              <a href="text00021.html#nav_point_177">10.2.2 通过测试定位并发相关的错误</a>
            </li>
            <li>
              <a href="text00021.html#nav_point_178">10.2.3 可测试性设计</a>
            </li>
            <li>
              <a href="text00021.html#nav_point_179">10.2.4 多线程测试技术</a>
            </li>
            <li>
              <a href="text00021.html#nav_point_180">10.2.5 构建多线程的测试代码</a>
            </li>
            <li>
              <a href="text00021.html#nav_point_181">10.2.6 测试多线程代码的性能</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00021.html#nav_point_182">10.3 总结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00022.html#nav_point_183">附录A C++11部分语言特性简明参考</a>
      <ul>
        <li>
          <a href="text00022.html#nav_point_184">A.1 右值引用</a>
          <ul>
            <li>
              <a href="text00022.html#nav_point_185">A.1.1 移动语义</a>
            </li>
            <li>
              <a href="text00022.html#nav_point_186">A.1.2 右值引用与函数模板</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00022.html#nav_point_187">A.2 deleted函数</a>
        </li>
        <li>
          <a href="text00022.html#nav_point_188">A.3 defaulted函数</a>
        </li>
        <li>
          <a href="text00022.html#nav_point_189">A.4 constexpr函数</a>
          <ul>
            <li>
              <a href="text00022.html#nav_point_190">A.4.1 constexpr与用户定义类型</a>
            </li>
            <li>
              <a href="text00022.html#nav_point_191">A.4.2 constexpr对象</a>
            </li>
            <li>
              <a href="text00022.html#nav_point_192">A.4.3 constexpr函数要求</a>
            </li>
            <li>
              <a href="text00022.html#nav_point_193">A.4.4 constexpr与模板</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00022.html#nav_point_194">A.5 lambda函数</a>
          <ul>
            <li>
              <a href="text00022.html#nav_point_195">引用局部变量的lambda函数</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00022.html#nav_point_196">A.6 变参模板</a>
          <ul>
            <li>
              <a href="text00022.html#nav_point_197">展开参数包</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00022.html#nav_point_198">A.7 自动推断变量的类型</a>
        </li>
        <li>
          <a href="text00022.html#nav_point_199">A.8 线程局部变量</a>
        </li>
        <li>
          <a href="text00022.html#nav_point_200">A.9 小结</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00023.html#nav_point_201">附录B 并发类库简要对比</a>
    </li>
    <li>
      <a href="text00024.html#nav_point_202">附录C 消息传递框架与完整的ATM示例</a>
    </li>
    <li>
      <a href="text00025.html#nav_point_203">附录D C++线程类库参考</a>
      <ul>
        <li>
          <a href="text00025.html#nav_point_204">D.1 &lt;chrono&gt;头文件</a>
          <ul>
            <li>
              <a href="text00025.html#nav_point_205">D.1.1 std::chrono::duration类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_206">D.1.2 std::chrono::time_point类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_207">D.1.3 std::chrono::system_clock类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_208">D.1.4 std::chrono::steady_clock类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_209">D.1.5 std::chrono::high_resolution_clock typedef</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00025.html#nav_point_210">D.2 &lt;condition_variable&gt;头文件</a>
          <ul>
            <li>
              <a href="text00025.html#nav_point_211">D.2.1 std::condition_variable类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_212">D.2.2 std::condition_variable_any类</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00025.html#nav_point_213">D.3 &lt;atomic&gt;头文件</a>
          <ul>
            <li>
              <a href="text00025.html#nav_point_214">D.3.1 std::atomic_xxx typedef</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_215">D.3.2 ATOMIC_xxx_LOCK_FREE宏</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_216">D.3.3 ATOMIC_VAR_INIT宏</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_217">D.3.4 std::memory_order枚举</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_218">D.3.5 std::atomic_thread_fence函数</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_219">D.3.6 std::atomic_signal_fence函数</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_220">D.3.7 std::atomic_flag类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_221">D.3.8 std::atomic类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_222">D.3.9 std::atomic模板的特化</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_223">D.3.10 std::atomic&lt;integral-type&gt;特化</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_224">D.3.11 std::atomic&lt;T*&gt;偏特化</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00025.html#nav_point_225">D.4 &lt;future&gt;头文件</a>
          <ul>
            <li>
              <a href="text00025.html#nav_point_226">D.4.1 std::future类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_227">D.4.2 std::shared_future类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_228">D.4.3 std::packaged_task类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_229">D.4.4 std::promise类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_230">D.4.5 std::async函数模板</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00025.html#nav_point_231">D.5 &lt;mutex&gt;头文件</a>
          <ul>
            <li>
              <a href="text00025.html#nav_point_232">D.5.1 std::mutex类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_233">D.5.2 std::recursive_mutex类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_234">D.5.3 std::timed_mutex类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_235">D.5.4 std::recursive_timed_mutex类</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_236">D.5.5 std::lock_guard类模板</a>
            </li>
            <li>
              <a href="text00025.html#nav_point_237">D.5.6 std::unique_lock类模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_1">D.5.7 std::lock函数模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_2">D.5.8 std::try_lock函数模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_3">D.5.9 std::once_flag类</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_4">D.5.10 std::call_once函数模板</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00025.html#sigil_toc_id_5">D.6 &lt;ratio&gt;头文件</a>
          <ul>
            <li>
              <a href="text00025.html#sigil_toc_id_6">D.6.1 std::ratio类模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_7">D.6.2 std::ratio_add模板别名</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_8">D.6.3 std::ratio_subtract模板别名</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_9">D.6.4 std::ratio_multiply模板别名</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_10">D.6.5 std::ratio_divide模板别名</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_11">D.6.6 std::ratio_equal类模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_12">D.6.7 std::ratio_not_equal类模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_13">D.6.8 std::ratio_less类模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_14">D.6.9 std::ratio_greater类模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_15">D.6.10 std::ratio_less_equal类模板</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_16">D.6.11 std::ratio_greater_equal类模板</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00025.html#sigil_toc_id_17">D.7 &lt;thread&gt;头文件</a>
          <ul>
            <li>
              <a href="text00025.html#sigil_toc_id_18">D.7.1 std::thread类</a>
            </li>
            <li>
              <a href="text00025.html#sigil_toc_id_19">D.7.2 this_thread命名空间</a>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00026.html#nav_point_238">欢迎来到异步社区！</a>
      <ul>
        <li>
          <a href="text00026.html#nav_point_239">异步社区的来历</a>
        </li>
        <li>
          <a href="text00026.html#nav_point_240">社区里都有什么？</a>
          <ul>
            <li>
              <a href="text00026.html#nav_point_241">购买图书</a>
            </li>
            <li>
              <a href="text00026.html#nav_point_242">下载资源</a>
            </li>
            <li>
              <a href="text00026.html#nav_point_243">与作译者互动</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00026.html#nav_point_244">灵活优惠的购书</a>
          <ul>
            <li>
              <a href="text00026.html#nav_point_245">纸电图书组合购买</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00026.html#nav_point_246">社区里还可以做什么？</a>
          <ul>
            <li>
              <a href="text00026.html#nav_point_247">提交勘误</a>
            </li>
            <li>
              <a href="text00026.html#nav_point_248">写作</a>
            </li>
            <li>
              <a href="text00026.html#nav_point_249">会议活动早知道</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="text00026.html#nav_point_250">加入异步</a>
        </li>
      </ul>
    </li>
    <li>
      <a href="text00027.html#sigil_toc_id_20">看完了</a>
    </li>
  </ul>
</div>


  </div>
  

  <div class="calibreEbNav">
    
      <a href="text00014.html" class="calibreAPrev">previous page
</a>
    

    <a href="../../1w54d-4vylw.html" class="calibreAHome">start
</a>

    
      <a href="text00016.html" class="calibreANext">next page
</a>
    
  </div>

</div>

</body>
</html>
